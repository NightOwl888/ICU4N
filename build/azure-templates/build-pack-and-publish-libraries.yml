# Runs dotnet build on the solution files,
# dotnet pack on the non-test projects,
# and dotnet publish on the test projects.
# Creates build artifacts for
# * .nuspec files of packable projects (in $(Build.ArtifactStagingDirectory)/$(NugetArtifactName))
# * .pdb files of packable projects (in $(Build.ArtifactStagingDirectory)/$(NugetArtifactName))
# * Published (portable) .dll files and dependencies of test projects (in $(Build.ArtifactStagingDirectory)/$(BinaryArtifactName))

# Publishing only takes into account the target frameworks specified in testTargetFrameworks (semicolon separated list).

parameters:
  artifactFeedID: '' # The GUID of the Azure Artifacts NuGet feed
  testTargetFrameworks: '' # A semicolon separated list of target frameworks indicating which frameworks tests will be run on. See: https://docs.microsoft.com/en-us/dotnet/standard/frameworks.
  informationalVersion: '' # The AssemblyInformationalVersion that will be passed to dotnet build.
  fileVersion: '' # The AssemblyFileVersion that will be passed to dotnet build.
  assemblyVersion: '' # The AssemblyVersion that will be passed to dotnet build.
  packageVersion: '' # The NuGet version that will be passed to dotnet pack.
  buildConfiguration: 'Release' # Defines the build configuration. Default 'Release'.
  buildPlatform: 'Any CPU' # Defines the build platform. Default 'Any CPU'.
  nugetArtifactName: 'nuget' # The name of the Azure DevOps build artifact where the NuGet assets (.nupkg and .pdb files) will be output. Default 'nuget'.
  binaryArtifactName: 'testbinaries' # The name of the Azure DevOps build artifact where the test assemblies will be output. Default 'testbinaries'.
  solutionFilesConvention: '**/*.sln' # The glob pattern where to look for solution files. Default '**\*.sln'.
  packableProjectFilesConvention: '**/*.csproj' # The glob pattern (within $(System.DefaultWorkingDirectory)) where to look for project files to pack into .nupkg files for deployment.
  testProjectFilesConvention: '**/*.Tests.*.csproj' # The glob pattern (within $(System.DefaultWorkingDirectory)) where to look for test project files, so they can be distinguished from other project file types.
  testSymbolFilesConvention: '**/*.Tests.*/**/*.pdb' # The glob pattern (within $(System.DefaultWorkingDirectory)) where to look for test project symbols (.pdb) files, so they can be distinguished from other project file types.


steps:
- powershell: |
    function EnsureNotNullOrEmpty([string]$param, [string]$nameOfParam) {
        if ([string]::IsNullOrEmpty($param)) {
            Write-Host "##vso[task.logissue type=error;]Missing template parameter \"$nameOfParam\""
            Write-Host "##vso[task.complete result=Failed;]"
        }
    }
    EnsureNotNullOrEmpty('${{ parameters.artifactFeedID }}', 'artifactFeedID')
    EnsureNotNullOrEmpty('${{ parameters.testTargetFrameworks }}', 'testTargetFrameworks')
    EnsureNotNullOrEmpty('${{ parameters.informationalVersion }}', 'informationalVersion')
    EnsureNotNullOrEmpty('${{ parameters.fileVersion }}', 'fileVersion')
    EnsureNotNullOrEmpty('${{ parameters.assemblyVersion }}', 'assemblyVersion')
    EnsureNotNullOrEmpty('${{ parameters.packageVersion }}', 'packageVersion')
    EnsureNotNullOrEmpty('${{ parameters.buildConfiguration }}', 'buildConfiguration')
    EnsureNotNullOrEmpty('${{ parameters.buildPlatform }}', 'buildPlatform')
    EnsureNotNullOrEmpty('${{ parameters.nugetArtifactName }}', 'nugetArtifactName')
    EnsureNotNullOrEmpty('${{ parameters.binaryArtifactName }}', 'binaryArtifactName')
    EnsureNotNullOrEmpty('${{ parameters.solutionFilesConvention }}', 'solutionFilesConvention')
    EnsureNotNullOrEmpty('${{ parameters.packableProjectFilesConvention }}', 'packableProjectFilesConvention')
    EnsureNotNullOrEmpty('${{ parameters.testProjectFilesConvention }}', 'testProjectFilesConvention')
    EnsureNotNullOrEmpty('${{ parameters.testSymbolFilesConvention }}', 'testSymbolFilesConvention')
  displayName: 'Validate Template Parameters'

#  # HACK: Using nuget.exe v4.8.1 tasks to do a "pre-restore". This functions, but seems
#  # to only restore the first target in TargetFrameworks. However, it also seems to cache
#  # the credentials so that using dotnet build without --no-restore will function afterward
#  # and correctly restore all TargetFrameworks.
#- task: NuGetToolInstaller@0
#  displayName: 'Use NuGet 4.8.1'
#  inputs:
#    versionSpec: 4.8.1

- task: DotNetCoreInstaller@0
  displayName: 'Use .NET Core sdk 2.2.300'
  inputs:
    version: 2.2.300

#- task: NuGetCommand@2
#  displayName: 'NuGet restore'
#  inputs:
#    restoreSolution: '${{ parameters.solutionFilesConvention }}'
#    vstsFeed: '/${{ parameters.artifactFeedID }}'

  # Runs dotnet build 
- task: DotNetCoreCLI@2
  displayName: 'dotnet build ${{ parameters.solutionFilesConvention }}'
  inputs:
    command: custom
    projects: '${{ parameters.solutionFilesConvention }}'
    custom: build
    arguments: '--configuration ${{ parameters.buildConfiguration }} --verbosity Detailed /p:Platform="${{ parameters.buildPlatform }}" /p:InformationalVersion="${{ parameters.informationalVersion }}" /p:FileVersion="${{ parameters.fileVersion }}" /p:AssemblyVersion="${{ parameters.assemblyVersion }}" /p:TestAllTargetFrameworks=true'

  # Packs the project binaries into .nupkg files (NuGet).
  # Note that we are outputting .symbols.nupkg files as well 
  # as build artifacts, even though they are not used.
- task: DotNetCoreCLI@2
  displayName: 'dotnet pack'
  inputs:
    command: custom
    projects: |
      ${{ parameters.packableProjectFilesConvention }}
      !${{ parameters.testProjectFilesConvention }}
    custom: pack
    arguments: '--configuration ${{ parameters.buildConfiguration }} --output "$(Build.ArtifactStagingDirectory)/${{ parameters.nugetArtifactName }}" --no-build --include-symbols --include-source --verbosity Detailed /p:PackageVersion="${{ parameters.packageVersion }}"'

- task: PublishSymbols@2
  displayName: 'Index symbols path'
  inputs:
    SymbolsFolder: '$(System.DefaultWorkingDirectory)'
    SearchPattern: |
      **/bin/${{ parameters.buildConfiguration }}/**/*.pdb
      !${{ parameters.testSymbolFilesConvention }}
    IndexSources: true
    PublishSymbols: false

  # Copy the .pdb files as build artifacts, which will later be used
  # to push to the Azure Artifacts symbol server.
- task: CopyFiles@2
  displayName: 'Copy .pdb Files to: /${{ parameters.nugetArtifactName }}'
  inputs:
    SourceFolder: '$(System.DefaultWorkingDirectory)'
    Contents: '**/bin/${{ parameters.buildConfiguration }}/**/*.pdb'
    TargetFolder: '$(Build.ArtifactStagingDirectory)/${{ parameters.nugetArtifactName }}'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact: ${{ parameters.nugetArtifactName }}'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/${{ parameters.nugetArtifactName }}'
    ArtifactName: '${{ parameters.nugetArtifactName }}'
  condition: succeededOrFailed()

  # Loops through each framework in the TestTargetFrameworks variable and
  # publishes the project in the artifact staging directory with the framework
  # and project name as part of the folder structure.
- powershell: |
    $testTargetFrameworksString = "${{ parameters.testTargetFrameworks }}"
    $testProjectRootDirectory = "$(System.DefaultWorkingDirectory)"
    $outputRoot = "$(Build.ArtifactStagingDirectory)/${{ parameters.binaryArtifactName }}"
    $configuration = "${{ parameters.buildConfiguration }}"
    $testProjectFilesConvention = "${{ parameters.testProjectFilesConvention }}"
    
    $testTargetFrameworks = $testTargetFrameworksString.Split([char]';',[char]',')
    foreach ($framework in $testTargetFrameworks) {
        $testProjects = Get-ChildItem -Path "$testProjectRootDirectory/$testProjectFilesConvention" -Recurse 
        foreach ($testProject in $testProjects) {
            $projectName = [System.IO.Path]::GetFileNameWithoutExtension($testProject)
            $outputPath = "$outputRoot/$framework/$projectName"
            Write-Host "Publishing '$testProject' on '$framework' to '$outputPath'..."
            dotnet publish "$testProject" --output "$outputPath" --framework "$framework" --configuration "$configuration" --no-build --verbosity Detailed /p:TestAllTargetFrameworks=true
        }
    }
  displayName: 'dotnet publish ${{ parameters.testTargetFrameworks }}'

- task: PublishBuildArtifacts@1
  displayName: 'Publish Artifact: ${{ parameters.binaryArtifactName }}'
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/${{ parameters.binaryArtifactName }}'
    ArtifactName: '${{ parameters.binaryArtifactName }}'
  condition: succeededOrFailed()