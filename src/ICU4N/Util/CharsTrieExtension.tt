<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file
    string settingsPath = System.IO.Path.Combine(Host.ResolveAssemblyReference("$(SolutionDir)"), "src/CodeGenerationSettings.xml");
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System.Text;

namespace ICU4N.Util
{
    public sealed partial class CharsTrie
    {
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Constructs a CharsTrie reader instance.
        /// </summary>
        /// <remarks>
        /// The <see cref="<#=charSequence == "char[]" ? "T:"+charSequence : charSequence#>"/> must contain a copy of a char sequence from the <see cref="CharsTrieBuilder"/>,
        /// with the offset indicating the first char of that sequence.
        /// The <see cref="CharsTrie"/> object will not read more chars than
        /// the <see cref="CharsTrieBuilder"/> generated in the corresponding 
        /// <see cref="CharsTrieBuilder.Build(TrieBuilderOption)"/> call.
        /// <para/>
        /// The <see cref="<#=charSequence == "char[]" ? "T:"+charSequence : charSequence#>"/> is not copied/cloned and must not be modified while
        /// the <see cref="CharsTrie"/> object is in use.
        /// </remarks>
        /// <param name="trieChars"><see cref="<#=charSequence == "char[]" ? "T:"+charSequence : charSequence#>"/> that contains the serialized trie.</param>
        /// <param name="offset">Root offset of the trie in the <see cref="<#=charSequence == "char[]" ? "T:"+charSequence : charSequence#>"/>.</param>
        /// <stable>ICU 4.8</stable>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> CharsTrie(<#=charSequence#> trieChars, int offset) 
        {
<# if (charSequence=="ICharSequence") { #>
            chars_ = trieChars;
<# } else { #>
            chars_ = trieChars.ToCharSequence();
<# } #>
            pos_ = root_ = offset;
            remainingMatchLength_ = -1;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Traverses the trie from the current state for this string.
        /// Equivalent to
        /// <code>
        ///     if(!result.HasNext()) return Result.NoMatch;
        ///     result=Next(c);
        ///     return result;
        /// </code>
        /// </summary>
        /// <param name="s">Contains a string.</param>
        /// <param name="sIndex">The start index of the string in <paramref name="s"/>.</param>
        /// <param name="sLimit">The (exclusive) end index of the string in <paramref name="s"/>.</param>
        /// <returns>The match/value <see cref="Result"/>.</returns>
        /// <stable>ICU 4.8</stable>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> Result Next(<#=charSequence#> s, int sIndex, int sLimit)
        {
            if (sIndex >= sLimit)
            {
                // Empty input.
                return Current;
            }
            int pos = pos_;
            if (pos < 0)
            {
                return Result.NoMatch;
            }
            int length = remainingMatchLength_;  // Actual remaining match length minus 1.
            for (; ; )
            {
                // Fetch the next input unit, if there is one.
                // Continue a linear-match node.
                char inUnit;
                for (; ; )
                {
                    if (sIndex == sLimit)
                    {
                        remainingMatchLength_ = length;
                        pos_ = pos;
                        int node2;
                        return (length < 0 && (node2 = chars_[pos]) >= kMinValueLead) ?
                                valueResults_[node2 >> 15] : Result.NoValue;
                    }
                    inUnit = s[sIndex++];
                    if (length < 0)
                    {
                        remainingMatchLength_ = length;
                        break;
                    }
                    if (inUnit != chars_[pos])
                    {
                        Stop();
                        return Result.NoMatch;
                    }
                    ++pos;
                    --length;
                }
                int node = chars_[pos++];
                for (; ; )
                {
                    if (node < kMinLinearMatch)
                    {
                        Result result = BranchNext(pos, node, inUnit);
                        if (result == Result.NoMatch)
                        {
                            return Result.NoMatch;
                        }
                        // Fetch the next input unit, if there is one.
                        if (sIndex == sLimit)
                        {
                            return result;
                        }
                        if (result == Result.FinalValue)
                        {
                            // No further matching units.
                            Stop();
                            return Result.NoMatch;
                        }
                        inUnit = s[sIndex++];
                        pos = pos_;  // branchNext() advanced pos and wrote it to pos_ .
                        node = chars_[pos++];
                    }
                    else if (node < kMinValueLead)
                    {
                        // Match length+1 units.
                        length = node - kMinLinearMatch;  // Actual match length minus 1.
                        if (inUnit != chars_[pos])
                        {
                            Stop();
                            return Result.NoMatch;
                        }
                        ++pos;
                        --length;
                        break;
                    }
                    else if ((node & kValueIsFinal) != 0)
                    {
                        // No further matching units.
                        Stop();
                        return Result.NoMatch;
                    }
                    else
                    {
                        // Skip intermediate value.
                        pos = SkipNodeValue(pos, node);
                        node &= kNodeTypeMask;
                    }
                }
            }
        }
<# } #>
    }
}