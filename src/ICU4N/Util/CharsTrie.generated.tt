<#@ output extension=".cs" #>
<#@ include file="../../../codegen/FilterDeclarations.tt" #>
<#
CharSequenceFilter = (c) => c.Name != "ReadOnlySpan<char>";
AppendableFilter = (a) => a.Name != "ValueStringBuilder";
string codeGenerationRelativePath = @"../../../codegen";
#><#@ include file="../../../codegen/DataLoader.tt" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System.Text;

namespace ICU4N.Util
{
    public sealed partial class CharsTrie
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Constructs a CharsTrie reader instance.
        /// </summary>
        /// <remarks>
        /// The <see cref="<#=charSequence.NameForDocAsLink#>"/> must contain a copy of a char sequence from the <see cref="CharsTrieBuilder"/>,
        /// with the offset indicating the first char of that sequence.
        /// The <see cref="CharsTrie"/> object will not read more chars than
        /// the <see cref="CharsTrieBuilder"/> generated in the corresponding 
        /// <see cref="CharsTrieBuilder.Build(TrieBuilderOption)"/> call.
        /// <para/>
        /// The <see cref="<#=charSequence.NameForDocAsLink#>"/> is not copied/cloned and must not be modified while
        /// the <see cref="CharsTrie"/> object is in use.
        /// </remarks>
        /// <param name="trieChars"><see cref="<#=charSequence.NameForDocAsLink#>"/> that contains the serialized trie.</param>
        /// <param name="offset">Root offset of the trie in the <see cref="<#=charSequence.NameForDocAsLink#>"/>.</param>
        /// <stable>ICU 4.8</stable>
        <#= charSequence.Name=="ICharSequence" ? charSequenceAccessibility : "public"#> CharsTrie(<#=charSequence#> trieChars, int offset) 
        {
<# if (charSequence.Name=="ICharSequence") { #>
            chars_ = trieChars;
<# } else { #>
            chars_ = trieChars.AsCharSequence();
<# } #>
            pos_ = root_ = offset;
            remainingMatchLength_ = -1;
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Traverses the trie from the current state for this string.
        /// Equivalent to
        /// <code>
        ///     if(!result.HasNext()) return Result.NoMatch;
        ///     result=Next(c);
        ///     return result;
        /// </code>
        /// </summary>
        /// <param name="s">Contains a string.</param>
        /// <param name="sIndex">The start index of the string in <paramref name="s"/>.</param>
        /// <param name="sLimit">The (exclusive) end index of the string in <paramref name="s"/>.</param>
        /// <returns>The match/value <see cref="Result"/>.</returns>
        /// <stable>ICU 4.8</stable>
        <#=charSequence.Accessibility#> Result Next(<#=charSequence#> s, int sIndex, int sLimit)
        {
            if (sIndex >= sLimit)
            {
                // Empty input.
                return Current;
            }
            int pos = pos_;
            if (pos < 0)
            {
                return Result.NoMatch;
            }
            int length = remainingMatchLength_;  // Actual remaining match length minus 1.
            for (; ; )
            {
                // Fetch the next input unit, if there is one.
                // Continue a linear-match node.
                char inUnit;
                for (; ; )
                {
                    if (sIndex == sLimit)
                    {
                        remainingMatchLength_ = length;
                        pos_ = pos;
                        int node2;
                        return (length < 0 && (node2 = chars_[pos]) >= kMinValueLead) ?
                                valueResults_[node2 >> 15] : Result.NoValue;
                    }
                    inUnit = s[sIndex++];
                    if (length < 0)
                    {
                        remainingMatchLength_ = length;
                        break;
                    }
                    if (inUnit != chars_[pos])
                    {
                        Stop();
                        return Result.NoMatch;
                    }
                    ++pos;
                    --length;
                }
                int node = chars_[pos++];
                for (; ; )
                {
                    if (node < kMinLinearMatch)
                    {
                        Result result = BranchNext(pos, node, inUnit);
                        if (result == Result.NoMatch)
                        {
                            return Result.NoMatch;
                        }
                        // Fetch the next input unit, if there is one.
                        if (sIndex == sLimit)
                        {
                            return result;
                        }
                        if (result == Result.FinalValue)
                        {
                            // No further matching units.
                            Stop();
                            return Result.NoMatch;
                        }
                        inUnit = s[sIndex++];
                        pos = pos_;  // branchNext() advanced pos and wrote it to pos_ .
                        node = chars_[pos++];
                    }
                    else if (node < kMinValueLead)
                    {
                        // Match length+1 units.
                        length = node - kMinLinearMatch;  // Actual match length minus 1.
                        if (inUnit != chars_[pos])
                        {
                            Stop();
                            return Result.NoMatch;
                        }
                        ++pos;
                        --length;
                        break;
                    }
                    else if ((node & kValueIsFinal) != 0)
                    {
                        // No further matching units.
                        Stop();
                        return Result.NoMatch;
                    }
                    else
                    {
                        // Skip intermediate value.
                        pos = SkipNodeValue(pos, node);
                        node &= kNodeTypeMask;
                    }
                }
            }
        }
<#= GetEndFeature(charSequence) #>
<# } #>
    }
}
<#@ include file="../../../codegen/SharedObjects.tt" #>