<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
	// Load common settings from the XML file
	string settingsPath = System.IO.Path.Combine(Host.ResolveAssemblyReference("$(SolutionDir)"), "CodeGenerationSettings.xml");
	XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
	string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
	string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Support.Text;
using System;
using System.Text;

namespace ICU4N.Text
{
    public static partial class UTF16
    {
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Extract a single UTF-32 value from a string. Used when iterating forwards or backwards (with
        /// <see cref="UTF16.GetCharCount(int)"/>, as well as random access. If a validity check is
        /// required, use <see cref="Lang.UCharacter.IsLegal(int)"/>
        /// on the return value. If the char retrieved is part of a surrogate pair, its supplementary
        /// character will be returned. If a complete supplementary character is not found the incomplete
        /// character will be returned.
        /// </summary>
        /// <param name="source">Array of UTF-16 chars</param>
        /// <param name="offset16">UTF-16 offset to the start of the character.</param>
        /// <returns>
        /// UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
        /// of that codepoint are the same as in <c>Bounds32()</c>.
        /// </returns>
        /// <exception cref="IndexOutOfRangeException">Thrown if offset16 is out of bounds.</exception>
        /// <stable>ICU 2.1</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int CharAt(<#=charSequence#> source, int offset16)
        {
            if (offset16 < 0 || offset16 >= source.Length)
            {
                throw new IndexOutOfRangeException(nameof(offset16));
            }

            char single = source[offset16];
            if (!IsSurrogate(single))
            {
                return single;
            }

            // Convert the UTF-16 surrogate pair if necessary.
            // For simplicity in usage, and because the frequency of pairs is
            // low, look both directions.

            if (single <= LEAD_SURROGATE_MAX_VALUE)
            {
                ++offset16;
                if (source.Length != offset16)
                {
                    char trail = source[offset16];
                    if (IsTrailSurrogate(trail))
                        return Character.ToCodePoint(single, trail);
                }
            }
            else
            {
                --offset16;
                if (offset16 >= 0)
                {
                    // single is a trail surrogate so
                    char lead = source[offset16];
                    if (IsLeadSurrogate(lead))
                    {
                        return Character.ToCodePoint(lead, single);
                    }
                }
            }
            return single; // return unmatched surrogate
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Utility for getting a code point from a character sequence that contains exactly one code point.
        /// </summary>
        /// <param name="s">to test</param>
        /// <returns>The code point IF the string is non-null and consists of a single code point. Otherwise returns -1.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int GetSingleCodePoint(<#=charSequence#> s)
        {
            if (s == null || s.Length == 0)
            {
                return -1;
            }
            else if (s.Length == 1)
            {
                return s[0];
            }
            else if (s.Length > 2)
            {
                return -1;
            }

            // at this point, len = 2
            int cp = Character.CodePointAt(s, 0);
            if (cp > 0xFFFF)
            { // is surrogate pair
                return cp;
            }
            return -1;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Utility for comparing a code point to a string without having to create a new string. Returns the same results
        /// as a code point comparison of UTF16.ValueOf(codePoint) and s.ToString(). More specifically, if
        /// <code>
        ///    sc = new StringComparer(true,false,0);
        ///    fast = UTF16.CompareCodePoint(codePoint, charSequence)
        ///    slower = sc.Compare(UTF16.ValueOf(codePoint), charSequence == null ? "" : charSequence.ToString())
        /// </code>
        /// then
        /// <code>
        ///    Math.Sign(fast) == Math.Sign(slower)
        /// </code>
        /// </summary>
        /// <param name="codePoint">CodePoint to test.</param>
        /// <param name="s">String to test.</param>
        /// <returns>Equivalent of code point comparator comparing two strings.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int CompareCodePoint(int codePoint, <#=charSequence#> s)
        {
            if (s == null)
            {
                return 1;
            }
            int strLen = s.Length;
            if (strLen == 0)
            {
                return 1;
            }
            int second = Character.CodePointAt(s, 0);
            int diff = codePoint - second;
            if (diff != 0)
            {
                return diff;
            }
            return strLen == Character.CharCount(codePoint) ? 0 : -1;
        }
<# } #>

	}
}