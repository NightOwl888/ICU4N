using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using StringBuffer = System.Text.StringBuilder;

namespace ICU4N.Text
{
    /// <summary>
    /// Exception that signals an error has occurred while parsing the
    /// input to StringPrep or IDNA.
    /// </summary>
    /// <author>Ram Viswanadha</author>
    /// <stable>ICU 2.8</stable>
    public class StringPrepParseException : FormatException
    {
        // Generated by serialver from JDK 1.4.1_01
        //static readonly long serialVersionUID = 7160264827701651255L;

        /**
         * @stable ICU 2.8
         */
        public const int INVALID_CHAR_FOUND = 0;
        /**
         * @stable ICU 2.8
         */
        public const int ILLEGAL_CHAR_FOUND = 1;
        /**
         * @stable ICU 2.8
         */
        public const int PROHIBITED_ERROR = 2;
        /**
         * @stable ICU 2.8
         */
        public const int UNASSIGNED_ERROR = 3;
        /**
         * @stable ICU 2.8
         */
        public const int CHECK_BIDI_ERROR = 4;
        /**
         * @stable ICU 2.8
         */
        public const int STD3_ASCII_RULES_ERROR = 5;
        /**
         * @stable ICU 2.8
         */
        public const int ACE_PREFIX_ERROR = 6;
        /**
         * @stable ICU 2.8
         */
        public const int VERIFICATION_ERROR = 7;
        /**
         * @stable ICU 2.8
         */
        public const int LABEL_TOO_LONG_ERROR = 8;
        /**
         * @stable ICU 2.8
         */
        public const int BUFFER_OVERFLOW_ERROR = 9;

        /**
         * @stable ICU 2.8
         */
        public const int ZERO_LENGTH_LABEL = 10;

        /**
         * @stable ICU 3.8
         */
        public const int DOMAIN_NAME_TOO_LONG_ERROR = 11;

        /**
         * Construct a ParseException object with the given message
         * and error code
         *
         * @param message A string describing the type of error that occurred
         * @param error   The error that has occurred
         * @stable ICU 2.8
         */
        public StringPrepParseException(string message, int error)
            : base(message)
        {
            this.error = error;
            this.line = 0;
        }

        /**
         * Construct a ParseException object with the given message and
         * error code
         *
         * @param message A string describing the type of error that occurred
         * @param error   The error that has occurred
         * @param rules   The input rules string
         * @param pos     The position of error in the rules string
         * @stable ICU 2.8
         */
        public StringPrepParseException(string message, int error, string rules, int pos)
            : base(message)
        {
            this.error = error;
            SetContext(rules, pos);
            this.line = 0;
        }
        /**
         * Construct  a ParseException object with the given message and error code
         *
         * @param message    A string describing the type of error that occurred
         * @param error      The error that has occurred
         * @param rules      The input rules string
         * @param pos        The position of error in the rules string
         * @param lineNumber The line number at which the error has occurred.
         *                   If the parse engine is not using this field, it should set it to zero.  Otherwise
         *                   it should be a positive integer. The default value of this field
         *                   is -1. It will be set to 0 if the code populating this struct is not
         *                   using line numbers.
         * @stable ICU 2.8
         */
        public StringPrepParseException(string message, int error, string rules, int pos, int lineNumber)
            : base(message)
        {
            this.error = error;
            SetContext(rules, pos);
            this.line = lineNumber;
        }
        /**
         * Compare this ParseException to another and evaluate if they are equal.
         * The comparison works only on the type of error and does not compare
         * the rules strings, if any, for equality.
         *
         * @param other The exception that this object should be compared to
         * @return true if the objects are equal, false if unequal
         * @stable ICU 2.8
         */
        public override bool Equals(object other)
        {
            if (!(other is StringPrepParseException))
            {
                return false;
            }
            return ((StringPrepParseException)other).error == this.error;

        }

        /**
         * Mock implementation of hashCode(). This implementation always returns a constant
         * value. When Java assertion is enabled, this method triggers an assertion failure.
         * @internal
         * @deprecated This API is ICU internal only.
         */
        [Obsolete("This API is ICU internal only.")]
        public override int GetHashCode()
        {
            Debug.Assert(false, "hashCode not designed");
            return 42;
        }

        /**
         * Returns the position of error in the rules string
         *
         * @return String
         * @stable ICU 2.8
         */
        public override string ToString()
        {
            StringBuilder buf = new StringBuilder();
            buf.Append(base.Message);
            buf.Append(". line:  ");
            buf.Append(line);
            buf.Append(". preContext:  ");
            buf.Append(preContext);
            buf.Append(". postContext: ");
            buf.Append(postContext);
            buf.Append("\n");
            return buf.ToString();
        }

        private int error;

        /**
         * The line on which the error occurred.  If the parse engine
         * is not using this field, it should set it to zero.  Otherwise
         * it should be a positive integer. The default value of this field
         * is -1. It will be set to 0 if the code populating this struct is not
         * using line numbers.
         */
        private int line;


        /**
         * Textual context before the error.  Null-terminated.
         * May be the empty string if not implemented by parser.
         */
        private StringBuffer preContext = new StringBuffer();

        /**
         * Textual context after the error.  Null-terminated.
         * May be the empty string if not implemented by parser.
         */
        private StringBuffer postContext = new StringBuffer();

        private static readonly int PARSE_CONTEXT_LEN = 16;

        private void SetPreContext(string str, int pos)
        {
            SetPreContext(str.ToCharArray(), pos);
        }

        private void SetPreContext(char[] str, int pos)
        {
            int start = (pos <= PARSE_CONTEXT_LEN) ? 0 : (pos - (PARSE_CONTEXT_LEN - 1));
            int len = (start <= PARSE_CONTEXT_LEN) ? start : PARSE_CONTEXT_LEN;
            preContext.Append(str, start, len);

        }

        private void SetPostContext(String str, int pos)
        {
            SetPostContext(str.ToCharArray(), pos);
        }

        private void SetPostContext(char[] str, int pos)
        {
            int start = pos;
            int len = str.Length - start;
            postContext.Append(str, start, len);

        }

        private void SetContext(String str, int pos)
        {
            SetPreContext(str, pos);
            SetPostContext(str, pos);
        }

        /**
         * Returns the error code of this exception.
         * This method is only used for testing to verify the error.
         * @return The error code
         * @stable ICU 3.8
         */
        public virtual int Error
        {
            get { return error; }
        }


        public virtual int Line // ICU4N specific - FormatException doesn't have a line number
        {
            get { return line; }
        }
    }
}
