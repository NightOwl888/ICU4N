//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Lang;
using ICU4N.Support.Text;
using ICU4N.Text;
using ICU4N.Util;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace ICU4N.Text
{
    public partial class UnicodeSet 
    {

        // TODO: create IAppendable version of UTF16.Append(buf, c),
        // maybe in new class Appendables?
        /// <exception cref="IOException"/>
        private static void AppendCodePoint(StringBuilder app, int c)
        {
            Debug.Assert(0 <= c && c <= 0x10ffff);
            try
            {
                if (c <= 0xffff)
                {
                    app.Append((char)c);
                }
                else
                {
                    app.Append(UTF16.GetLeadSurrogate(c)).Append(UTF16.GetTrailSurrogate(c));
                }
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        // TODO: create IAppendable version of UTF16.Append(buf, c),
        // maybe in new class Appendables?
        /// <exception cref="IOException"/>
        private static void AppendCodePoint(IAppendable app, int c)
        {
            Debug.Assert(0 <= c && c <= 0x10ffff);
            try
            {
                if (c <= 0xffff)
                {
                    app.Append((char)c);
                }
                else
                {
                    app.Append(UTF16.GetLeadSurrogate(c)).Append(UTF16.GetTrailSurrogate(c));
                }
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(StringBuilder app, string s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(StringBuilder app, StringBuilder s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(StringBuilder app, char[] s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(StringBuilder app, ICharSequence s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
		
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(IAppendable app, string s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(IAppendable app, StringBuilder s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(IAppendable app, char[] s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
	    // TODO: create class Appendables?
        /// <exception cref="IOException"/>
        private static void Append(IAppendable app, ICharSequence s)
        {
            try
            {
                app.Append(s);
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
	
        /// <summary>
        /// Append the <see cref="ToPattern(bool)"/> representation of a
        /// string to the given <see cref="StringBuilder"/>.
        /// </summary>
        private static StringBuilder AppendToPat(StringBuilder buf, string s, bool escapeUnprintable)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = s.CodePointAt(i);
                AppendToPat(buf, cp, escapeUnprintable);
            }
            return buf;
        }

        /// <summary>
        /// Append the <see cref="ToPattern(bool)"/> representation of a
        /// string to the given <see cref="IAppendable"/>.
        /// </summary>
        private static T AppendToPat<T>(T buf, string s, bool escapeUnprintable) where T : IAppendable
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = s.CodePointAt(i);
                AppendToPat(buf, cp, escapeUnprintable);
            }
            return buf;
        }

        /// <summary>
        /// Append the <see cref="ToPattern(bool)"/> representation of a
        /// character to the given <see cref="StringBuilder"/>.
        /// </summary>
        private static StringBuilder AppendToPat(StringBuilder buf, int c, bool escapeUnprintable)
        {
            try
            {
                if (escapeUnprintable && Utility.IsUnprintable(c))
                {
                    // Use hex escape notation (<backslash>uxxxx or <backslash>Uxxxxxxxx) for anything
                    // unprintable
                    if (Utility.EscapeUnprintable(buf, c))
                    {
                        return buf;
                    }
                }
                // Okay to let ':' pass through
                switch (c)
                {
                    case '[': // SET_OPEN:
                    case ']': // SET_CLOSE:
                    case '-': // HYPHEN:
                    case '^': // COMPLEMENT:
                    case '&': // INTERSECTION:
                    case '\\': //BACKSLASH:
                    case '{':
                    case '}':
                    case '$':
                    case ':':
                        buf.Append('\\');
                        break;
                    default:
                        // Escape whitespace
                        if (PatternProps.IsWhiteSpace(c))
                        {
                            buf.Append('\\');
                        }
                        break;
                }
                AppendCodePoint(buf, c);
                return buf;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Append the <see cref="ToPattern(bool)"/> representation of a
        /// character to the given <see cref="IAppendable"/>.
        /// </summary>
        private static T AppendToPat<T>(T buf, int c, bool escapeUnprintable) where T : IAppendable
        {
            try
            {
                if (escapeUnprintable && Utility.IsUnprintable(c))
                {
                    // Use hex escape notation (<backslash>uxxxx or <backslash>Uxxxxxxxx) for anything
                    // unprintable
                    if (Utility.EscapeUnprintable(buf, c))
                    {
                        return buf;
                    }
                }
                // Okay to let ':' pass through
                switch (c)
                {
                    case '[': // SET_OPEN:
                    case ']': // SET_CLOSE:
                    case '-': // HYPHEN:
                    case '^': // COMPLEMENT:
                    case '&': // INTERSECTION:
                    case '\\': //BACKSLASH:
                    case '{':
                    case '}':
                    case '$':
                    case ':':
                        buf.Append('\\');
                        break;
                    default:
                        // Escape whitespace
                        if (PatternProps.IsWhiteSpace(c))
                        {
                            buf.Append('\\');
                        }
                        break;
                }
                AppendCodePoint(buf, c);
                return buf;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Append a string representation of this set to result.  This will be
        /// a cleaned version of the string passed to ApplyPattern(), if there
        /// is one.  Otherwise it will be generated.
        /// </summary>
        private StringBuilder ToPattern(StringBuilder result, bool escapeUnprintable)
        {
            if (pat == null)
            {
                return AppendNewPattern(result, escapeUnprintable, true);
            }
            try
            {
                if (!escapeUnprintable)
                {
                    result.Append(pat);
                    return result;
                }
                bool oddNumberOfBackslashes = false;
                for (int i = 0; i < pat.Length;)
                {
                    int c = pat.CodePointAt(i);
                    i += Character.CharCount(c);
                    if (Utility.IsUnprintable(c))
                    {
                        // If the unprintable character is preceded by an odd
                        // number of backslashes, then it has been escaped
                        // and we omit the last backslash.
                        Utility.EscapeUnprintable(result, c);
                        oddNumberOfBackslashes = false;
                    }
                    else if (!oddNumberOfBackslashes && c == '\\')
                    {
                        // Temporarily withhold an odd-numbered backslash.
                        oddNumberOfBackslashes = true;
                    }
                    else
                    {
                        if (oddNumberOfBackslashes)
                        {
                            result.Append('\\');
                        }
                        AppendCodePoint(result, c);
                        oddNumberOfBackslashes = false;
                    }
                }
                if (oddNumberOfBackslashes)
                {
                    result.Append('\\');
                }
                return result;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Append a string representation of this set to result.  This will be
        /// a cleaned version of the string passed to ApplyPattern(), if there
        /// is one.  Otherwise it will be generated.
        /// </summary>
        private T ToPattern<T>(T result, bool escapeUnprintable) where T : IAppendable
        {
            if (pat == null)
            {
                return AppendNewPattern(result, escapeUnprintable, true);
            }
            try
            {
                if (!escapeUnprintable)
                {
                    result.Append(pat);
                    return result;
                }
                bool oddNumberOfBackslashes = false;
                for (int i = 0; i < pat.Length;)
                {
                    int c = pat.CodePointAt(i);
                    i += Character.CharCount(c);
                    if (Utility.IsUnprintable(c))
                    {
                        // If the unprintable character is preceded by an odd
                        // number of backslashes, then it has been escaped
                        // and we omit the last backslash.
                        Utility.EscapeUnprintable(result, c);
                        oddNumberOfBackslashes = false;
                    }
                    else if (!oddNumberOfBackslashes && c == '\\')
                    {
                        // Temporarily withhold an odd-numbered backslash.
                        oddNumberOfBackslashes = true;
                    }
                    else
                    {
                        if (oddNumberOfBackslashes)
                        {
                            result.Append('\\');
                        }
                        AppendCodePoint(result, c);
                        oddNumberOfBackslashes = false;
                    }
                }
                if (oddNumberOfBackslashes)
                {
                    result.Append('\\');
                }
                return result;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        private StringBuilder AppendNewPattern(StringBuilder result, bool escapeUnprintable, bool includeStrings)
        {
            try
            {
                result.Append('[');

                int count = GetRangeCount();

                // If the set contains at least 2 intervals and includes both
                // MIN_VALUE and MAX_VALUE, then the inverse representation will
                // be more economical.
                if (count > 1 &&
                        GetRangeStart(0) == MIN_VALUE &&
                        GetRangeEnd(count - 1) == MAX_VALUE)
                {

                    // Emit the inverse
                    result.Append('^');

                    for (int i = 1; i < count; ++i)
                    {
                        int start = GetRangeEnd(i - 1) + 1;
                        int end = GetRangeStart(i) - 1;
                        AppendToPat(result, start, escapeUnprintable);
                        if (start != end)
                        {
                            if ((start + 1) != end)
                            {
                                result.Append('-');
                            }
                            AppendToPat(result, end, escapeUnprintable);
                        }
                    }
                }

                // Default; emit the ranges as pairs
                else
                {
                    for (int i = 0; i < count; ++i)
                    {
                        int start = GetRangeStart(i);
                        int end = GetRangeEnd(i);
                        AppendToPat(result, start, escapeUnprintable);
                        if (start != end)
                        {
                            if ((start + 1) != end)
                            {
                                result.Append('-');
                            }
                            AppendToPat(result, end, escapeUnprintable);
                        }
                    }
                }

                if (includeStrings && strings.Count > 0)
                {
                    foreach (string s in strings)
                    {
                        result.Append('{');
                        AppendToPat(result, s, escapeUnprintable);
                        result.Append('}');
                    }
                }
                result.Append(']');
                return result;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        private T AppendNewPattern<T>(T result, bool escapeUnprintable, bool includeStrings) where T : IAppendable
        {
            try
            {
                result.Append('[');

                int count = GetRangeCount();

                // If the set contains at least 2 intervals and includes both
                // MIN_VALUE and MAX_VALUE, then the inverse representation will
                // be more economical.
                if (count > 1 &&
                        GetRangeStart(0) == MIN_VALUE &&
                        GetRangeEnd(count - 1) == MAX_VALUE)
                {

                    // Emit the inverse
                    result.Append('^');

                    for (int i = 1; i < count; ++i)
                    {
                        int start = GetRangeEnd(i - 1) + 1;
                        int end = GetRangeStart(i) - 1;
                        AppendToPat(result, start, escapeUnprintable);
                        if (start != end)
                        {
                            if ((start + 1) != end)
                            {
                                result.Append('-');
                            }
                            AppendToPat(result, end, escapeUnprintable);
                        }
                    }
                }

                // Default; emit the ranges as pairs
                else
                {
                    for (int i = 0; i < count; ++i)
                    {
                        int start = GetRangeStart(i);
                        int end = GetRangeEnd(i);
                        AppendToPat(result, start, escapeUnprintable);
                        if (start != end)
                        {
                            if ((start + 1) != end)
                            {
                                result.Append('-');
                            }
                            AppendToPat(result, end, escapeUnprintable);
                        }
                    }
                }

                if (includeStrings && strings.Count > 0)
                {
                    foreach (string s in strings)
                    {
                        result.Append('{');
                        AppendToPat(result, s, escapeUnprintable);
                        result.Append('}');
                    }
                }
                result.Append(']');
                return result;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public virtual int MatchesAt(string text, int offset)
        {
            int lastLen = -1;

            if (strings.Count != 0)
            {
                char firstChar = text[offset];
                string trial = null;
                // find the first string starting with firstChar
                //Iterator<string> it = strings.iterator();
                using (var it = strings.GetEnumerator())
                {
                    while (it.MoveNext())
                    {
                        trial = it.Current;
                        char firstStringChar = trial[0];
                        if (firstStringChar < firstChar) continue;
                        if (firstStringChar > firstChar) goto strings_break;
                    }

                    // now keep checking string until we get the longest one
                    for (; ; )
                    {
                        int tempLen = MatchesAt(text, offset, trial);
                        if (lastLen > tempLen) goto strings_break;
                        lastLen = tempLen;
                        if (!it.MoveNext()) break;
                        trial = it.Current;
                    }
                }
            }
            strings_break: { }

            if (lastLen < 2)
            {
                int cp = UTF16.CharAt(text, offset);
                if (Contains(cp)) lastLen = UTF16.GetCharCount(cp);
            }

            return offset + lastLen;
        }

        /// <summary>
        /// Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public virtual int MatchesAt(StringBuilder text, int offset)
        {
            int lastLen = -1;

            if (strings.Count != 0)
            {
                char firstChar = text[offset];
                string trial = null;
                // find the first string starting with firstChar
                //Iterator<string> it = strings.iterator();
                using (var it = strings.GetEnumerator())
                {
                    while (it.MoveNext())
                    {
                        trial = it.Current;
                        char firstStringChar = trial[0];
                        if (firstStringChar < firstChar) continue;
                        if (firstStringChar > firstChar) goto strings_break;
                    }

                    // now keep checking string until we get the longest one
                    for (; ; )
                    {
                        int tempLen = MatchesAt(text, offset, trial);
                        if (lastLen > tempLen) goto strings_break;
                        lastLen = tempLen;
                        if (!it.MoveNext()) break;
                        trial = it.Current;
                    }
                }
            }
            strings_break: { }

            if (lastLen < 2)
            {
                int cp = UTF16.CharAt(text, offset);
                if (Contains(cp)) lastLen = UTF16.GetCharCount(cp);
            }

            return offset + lastLen;
        }

        /// <summary>
        /// Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public virtual int MatchesAt(char[] text, int offset)
        {
            int lastLen = -1;

            if (strings.Count != 0)
            {
                char firstChar = text[offset];
                string trial = null;
                // find the first string starting with firstChar
                //Iterator<string> it = strings.iterator();
                using (var it = strings.GetEnumerator())
                {
                    while (it.MoveNext())
                    {
                        trial = it.Current;
                        char firstStringChar = trial[0];
                        if (firstStringChar < firstChar) continue;
                        if (firstStringChar > firstChar) goto strings_break;
                    }

                    // now keep checking string until we get the longest one
                    for (; ; )
                    {
                        int tempLen = MatchesAt(text, offset, trial);
                        if (lastLen > tempLen) goto strings_break;
                        lastLen = tempLen;
                        if (!it.MoveNext()) break;
                        trial = it.Current;
                    }
                }
            }
            strings_break: { }

            if (lastLen < 2)
            {
                int cp = UTF16.CharAt(text, offset);
                if (Contains(cp)) lastLen = UTF16.GetCharCount(cp);
            }

            return offset + lastLen;
        }

        /// <summary>
        /// Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        internal virtual int MatchesAt(ICharSequence text, int offset)
        {
            int lastLen = -1;

            if (strings.Count != 0)
            {
                char firstChar = text[offset];
                string trial = null;
                // find the first string starting with firstChar
                //Iterator<string> it = strings.iterator();
                using (var it = strings.GetEnumerator())
                {
                    while (it.MoveNext())
                    {
                        trial = it.Current;
                        char firstStringChar = trial[0];
                        if (firstStringChar < firstChar) continue;
                        if (firstStringChar > firstChar) goto strings_break;
                    }

                    // now keep checking string until we get the longest one
                    for (; ; )
                    {
                        int tempLen = MatchesAt(text, offset, trial);
                        if (lastLen > tempLen) goto strings_break;
                        lastLen = tempLen;
                        if (!it.MoveNext()) break;
                        trial = it.Current;
                    }
                }
            }
            strings_break: { }

            if (lastLen < 2)
            {
                int cp = UTF16.CharAt(text, offset);
                if (Contains(cp)) lastLen = UTF16.GetCharCount(cp);
            }

            return offset + lastLen;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(string text, int offsetInText, string substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(string text, int offsetInText, StringBuilder substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(string text, int offsetInText, char[] substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(string text, int offsetInText, ICharSequence substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
		
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(StringBuilder text, int offsetInText, string substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(StringBuilder text, int offsetInText, StringBuilder substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(StringBuilder text, int offsetInText, char[] substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(StringBuilder text, int offsetInText, ICharSequence substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
		
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(char[] text, int offsetInText, string substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(char[] text, int offsetInText, StringBuilder substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(char[] text, int offsetInText, char[] substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(char[] text, int offsetInText, ICharSequence substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
		
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(ICharSequence text, int offsetInText, string substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(ICharSequence text, int offsetInText, StringBuilder substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(ICharSequence text, int offsetInText, char[] substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Does one string contain another, starting at a specific offset?
        /// </summary>
        /// <param name="text">Text to match.</param>
        /// <param name="offsetInText">Offset within that text.</param>
        /// <param name="substring">Substring to match at offset in text.</param>
        /// <returns>-1 if match fails, otherwise other.Length.</returns>
        // Note: This method was moved from CollectionUtilities
        private static int MatchesAt(ICharSequence text, int offsetInText, ICharSequence substring)
        {
            int len = substring.Length;
            int textLength = text.Length;
            if (textLength + offsetInText > len)
            {
                return -1;
            }
            int i = 0;
            for (int j = offsetInText; i < len; ++i, ++j)
            {
                char pc = substring[i];
                char tc = text[j];
                if (pc != tc) return -1;
            }
            return i;
        }
	
        /// <summary>
        /// Adds the specified multicharacter to this set if it is not already
        /// present.  If this set already contains the multicharacter,
        /// the call leaves this set unchanged.
        /// Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Add(string s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Add(s.ToString());
                pat = null;
            }
            else
            {
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Adds the specified multicharacter to this set if it is not already
        /// present.  If this set already contains the multicharacter,
        /// the call leaves this set unchanged.
        /// Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Add(StringBuilder s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Add(s.ToString());
                pat = null;
            }
            else
            {
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Adds the specified multicharacter to this set if it is not already
        /// present.  If this set already contains the multicharacter,
        /// the call leaves this set unchanged.
        /// Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Add(char[] s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Add(s.ToString());
                pat = null;
            }
            else
            {
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Adds the specified multicharacter to this set if it is not already
        /// present.  If this set already contains the multicharacter,
        /// the call leaves this set unchanged.
        /// Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet Add(ICharSequence s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Add(s.ToString());
                pat = null;
            }
            else
            {
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Utility for getting code point from single code point <see cref="string"/>.
        /// See the public <see cref="UTF16.GetSingleCodePoint()"/>.
        /// </summary>
        /// <param name="s">To test.</param>
        /// <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        private static int GetSingleCP(string s)
        {
            if (s.Length < 1)
            {
                throw new ArgumentException("Can't use zero-length strings in UnicodeSet");
            }
            if (s.Length > 2) return -1;
            if (s.Length == 1) return s[0];

            // at this point, len = 2
            int cp = UTF16.CharAt(s, 0);
            if (cp > 0xFFFF)
            { // is surrogate pair
                return cp;
            }
            return -1;
        }

        /// <summary>
        /// Utility for getting code point from single code point <see cref="StringBuilder"/>.
        /// See the public <see cref="UTF16.GetSingleCodePoint()"/>.
        /// </summary>
        /// <param name="s">To test.</param>
        /// <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        private static int GetSingleCP(StringBuilder s)
        {
            if (s.Length < 1)
            {
                throw new ArgumentException("Can't use zero-length strings in UnicodeSet");
            }
            if (s.Length > 2) return -1;
            if (s.Length == 1) return s[0];

            // at this point, len = 2
            int cp = UTF16.CharAt(s, 0);
            if (cp > 0xFFFF)
            { // is surrogate pair
                return cp;
            }
            return -1;
        }

        /// <summary>
        /// Utility for getting code point from single code point <see cref="char[]"/>.
        /// See the public <see cref="UTF16.GetSingleCodePoint()"/>.
        /// </summary>
        /// <param name="s">To test.</param>
        /// <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        private static int GetSingleCP(char[] s)
        {
            if (s.Length < 1)
            {
                throw new ArgumentException("Can't use zero-length strings in UnicodeSet");
            }
            if (s.Length > 2) return -1;
            if (s.Length == 1) return s[0];

            // at this point, len = 2
            int cp = UTF16.CharAt(s, 0);
            if (cp > 0xFFFF)
            { // is surrogate pair
                return cp;
            }
            return -1;
        }

        /// <summary>
        /// Utility for getting code point from single code point <see cref="ICharSequence"/>.
        /// See the public <see cref="UTF16.GetSingleCodePoint()"/>.
        /// </summary>
        /// <param name="s">To test.</param>
        /// <returns>A code point IF the string consists of a single one. Otherwise returns -1.</returns>
        private static int GetSingleCP(ICharSequence s)
        {
            if (s.Length < 1)
            {
                throw new ArgumentException("Can't use zero-length strings in UnicodeSet");
            }
            if (s.Length > 2) return -1;
            if (s.Length == 1) return s[0];

            // at this point, len = 2
            int cp = UTF16.CharAt(s, 0);
            if (cp > 0xFFFF)
            { // is surrogate pair
                return cp;
            }
            return -1;
        }

        /// <summary>
        /// Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>this object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet AddAll(string s) // ICU4N TODO: Change to UnionWith?
        {
            CheckFrozen();
            int cp;
            for (int i = 0; i < s.Length; i += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(s, i);
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>this object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet AddAll(StringBuilder s) // ICU4N TODO: Change to UnionWith?
        {
            CheckFrozen();
            int cp;
            for (int i = 0; i < s.Length; i += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(s, i);
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>this object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet AddAll(char[] s) // ICU4N TODO: Change to UnionWith?
        {
            CheckFrozen();
            int cp;
            for (int i = 0; i < s.Length; i += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(s, i);
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Adds each of the characters in this string to the set. Thus "ch" =&gt; {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>this object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet AddAll(ICharSequence s) // ICU4N TODO: Change to UnionWith?
        {
            CheckFrozen();
            int cp;
            for (int i = 0; i < s.Length; i += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(s, i);
                AddUnchecked(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet RetainAll(string s) // ICU4N TODO: Change to IntersectWith?
        {
            return RetainAll(FromAll(s));
        }

        /// <summary>
        /// Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet RetainAll(StringBuilder s) // ICU4N TODO: Change to IntersectWith?
        {
            return RetainAll(FromAll(s));
        }

        /// <summary>
        /// Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet RetainAll(char[] s) // ICU4N TODO: Change to IntersectWith?
        {
            return RetainAll(FromAll(s));
        }

        /// <summary>
        /// Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet RetainAll(ICharSequence s) // ICU4N TODO: Change to IntersectWith?
        {
            return RetainAll(FromAll(s));
        }

        /// <summary>
        /// Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet ComplementAll(string s)
        {
            return ComplementAll(FromAll(s));
        }

        /// <summary>
        /// Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet ComplementAll(StringBuilder s)
        {
            return ComplementAll(FromAll(s));
        }

        /// <summary>
        /// Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet ComplementAll(char[] s)
        {
            return ComplementAll(FromAll(s));
        }

        /// <summary>
        /// Complement EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet ComplementAll(ICharSequence s)
        {
            return ComplementAll(FromAll(s));
        }

        /// <summary>
        /// Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet RemoveAll(string s)  // ICU4N TODO: Change to ExceptWith?
        {
            return RemoveAll(FromAll(s));
        }

        /// <summary>
        /// Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet RemoveAll(StringBuilder s)  // ICU4N TODO: Change to ExceptWith?
        {
            return RemoveAll(FromAll(s));
        }

        /// <summary>
        /// Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet RemoveAll(char[] s)  // ICU4N TODO: Change to ExceptWith?
        {
            return RemoveAll(FromAll(s));
        }

        /// <summary>
        /// Remove EACH of the characters in this string. Note: "ch" == {"c", "h"}
        /// If this set already any particular character, it has no effect on that character.
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet RemoveAll(ICharSequence s)  // ICU4N TODO: Change to ExceptWith?
        {
            return RemoveAll(FromAll(s));
        }

        /// <summary>
        /// Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given string.</returns>
        /// <stable>ICU 2.0</stable>
        public static UnicodeSet From(string s)
        {
            return new UnicodeSet().Add(s);
        }

        /// <summary>
        /// Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given string.</returns>
        /// <stable>ICU 2.0</stable>
        public static UnicodeSet From(StringBuilder s)
        {
            return new UnicodeSet().Add(s);
        }

        /// <summary>
        /// Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given string.</returns>
        /// <stable>ICU 2.0</stable>
        public static UnicodeSet From(char[] s)
        {
            return new UnicodeSet().Add(s);
        }

        /// <summary>
        /// Makes a set from a multicharacter string. Thus "ch" =&gt; {"ch"}
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given string.</returns>
        /// <stable>ICU 2.0</stable>
        internal static UnicodeSet From(ICharSequence s)
        {
            return new UnicodeSet().Add(s);
        }

        /// <summary>
        /// Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given characters.</returns>
        /// <stable>ICU 2.0</stable>
        public static UnicodeSet FromAll(string s)
        {
            return new UnicodeSet().AddAll(s);
        }

        /// <summary>
        /// Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given characters.</returns>
        /// <stable>ICU 2.0</stable>
        public static UnicodeSet FromAll(StringBuilder s)
        {
            return new UnicodeSet().AddAll(s);
        }

        /// <summary>
        /// Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given characters.</returns>
        /// <stable>ICU 2.0</stable>
        public static UnicodeSet FromAll(char[] s)
        {
            return new UnicodeSet().AddAll(s);
        }

        /// <summary>
        /// Makes a set from each of the characters in the string. Thus "ch" =&gt; {"c", "h"}
        /// </summary>
        /// <param name="s">The source string.</param>
        /// <returns>A newly created set containing the given characters.</returns>
        /// <stable>ICU 2.0</stable>
        internal static UnicodeSet FromAll(ICharSequence s)
        {
            return new UnicodeSet().AddAll(s);
        }

        /// <summary>
        /// Retain the specified string in this set if it is present.
        /// Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
        /// will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
        /// </summary>
        /// <param name="cs">The string to be retained.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Retain(string cs)
        {
            int cp = GetSingleCP(cs);
            if (cp < 0)
            {
                string s = cs.ToString();
                bool isIn = strings.Contains(s);
                if (isIn && Count == 1)
                {
                    return this;
                }
                Clear();
                strings.Add(s);
                pat = null;
            }
            else
            {
                Retain(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Retain the specified string in this set if it is present.
        /// Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
        /// will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
        /// </summary>
        /// <param name="cs">The string to be retained.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Retain(StringBuilder cs)
        {
            int cp = GetSingleCP(cs);
            if (cp < 0)
            {
                string s = cs.ToString();
                bool isIn = strings.Contains(s);
                if (isIn && Count == 1)
                {
                    return this;
                }
                Clear();
                strings.Add(s);
                pat = null;
            }
            else
            {
                Retain(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Retain the specified string in this set if it is present.
        /// Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
        /// will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
        /// </summary>
        /// <param name="cs">The string to be retained.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Retain(char[] cs)
        {
            int cp = GetSingleCP(cs);
            if (cp < 0)
            {
                string s = cs.ToString();
                bool isIn = strings.Contains(s);
                if (isIn && Count == 1)
                {
                    return this;
                }
                Clear();
                strings.Add(s);
                pat = null;
            }
            else
            {
                Retain(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Retain the specified string in this set if it is present.
        /// Upon return this set will be empty if it did not contain <paramref name="cs"/>, or
        /// will only contain <paramref name="cs"/> if it did contain <paramref name="cs"/>.
        /// </summary>
        /// <param name="cs">The string to be retained.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet Retain(ICharSequence cs)
        {
            int cp = GetSingleCP(cs);
            if (cp < 0)
            {
                string s = cs.ToString();
                bool isIn = strings.Contains(s);
                if (isIn && Count == 1)
                {
                    return this;
                }
                Clear();
                strings.Add(s);
                pat = null;
            }
            else
            {
                Retain(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Removes the specified string from this set if it is present.
        /// The set will not contain the specified string once the call
        /// returns.
        /// </summary>
        /// <param name="s">The string to be removed.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Remove(string s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Remove(s.ToString());
                pat = null;
            }
            else
            {
                Remove(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Removes the specified string from this set if it is present.
        /// The set will not contain the specified string once the call
        /// returns.
        /// </summary>
        /// <param name="s">The string to be removed.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Remove(StringBuilder s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Remove(s.ToString());
                pat = null;
            }
            else
            {
                Remove(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Removes the specified string from this set if it is present.
        /// The set will not contain the specified string once the call
        /// returns.
        /// </summary>
        /// <param name="s">The string to be removed.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Remove(char[] s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Remove(s.ToString());
                pat = null;
            }
            else
            {
                Remove(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Removes the specified string from this set if it is present.
        /// The set will not contain the specified string once the call
        /// returns.
        /// </summary>
        /// <param name="s">The string to be removed.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet Remove(ICharSequence s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                strings.Remove(s.ToString());
                pat = null;
            }
            else
            {
                Remove(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Complement the specified string in this set.
        /// The set will not contain the specified string once the call
        /// returns.
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The string to complement.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Complement(string s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                string s2 = s.ToString();
                if (strings.Contains(s2))
                {
                    strings.Remove(s2);
                }
                else
                {
                    strings.Add(s2);
                }
                pat = null;
            }
            else
            {
                Complement(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Complement the specified string in this set.
        /// The set will not contain the specified string once the call
        /// returns.
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The string to complement.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Complement(StringBuilder s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                string s2 = s.ToString();
                if (strings.Contains(s2))
                {
                    strings.Remove(s2);
                }
                else
                {
                    strings.Add(s2);
                }
                pat = null;
            }
            else
            {
                Complement(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Complement the specified string in this set.
        /// The set will not contain the specified string once the call
        /// returns.
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The string to complement.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        public UnicodeSet Complement(char[] s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                string s2 = s.ToString();
                if (strings.Contains(s2))
                {
                    strings.Remove(s2);
                }
                else
                {
                    strings.Add(s2);
                }
                pat = null;
            }
            else
            {
                Complement(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Complement the specified string in this set.
        /// The set will not contain the specified string once the call
        /// returns.
        /// <para/>
        /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
        /// </summary>
        /// <param name="s">The string to complement.</param>
        /// <returns>This object, for chaining.</returns>
        /// <stable>ICU 2.0</stable>
        internal UnicodeSet Complement(ICharSequence s)
        {
            CheckFrozen();
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                string s2 = s.ToString();
                if (strings.Contains(s2))
                {
                    strings.Remove(s2);
                }
                else
                {
                    strings.Add(s2);
                }
                pat = null;
            }
            else
            {
                Complement(cp, cp);
            }
            return this;
        }

        /// <summary>
        /// Returns <tt>true</tt> if this set contains the given
        /// multicharacter string.
        /// </summary>
        /// <param name="s">String to be checked for containment.</param>
        /// <returns><tt>true</tt> if this set contains the specified string.</returns>
        /// <stable>ICU 2.0</stable>
        public bool Contains(string s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                return strings.Contains(s.ToString());
            }
            else
            {
                return Contains(cp);
            }
        }

        /// <summary>
        /// Returns <tt>true</tt> if this set contains the given
        /// multicharacter string.
        /// </summary>
        /// <param name="s">String to be checked for containment.</param>
        /// <returns><tt>true</tt> if this set contains the specified string.</returns>
        /// <stable>ICU 2.0</stable>
        public bool Contains(StringBuilder s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                return strings.Contains(s.ToString());
            }
            else
            {
                return Contains(cp);
            }
        }

        /// <summary>
        /// Returns <tt>true</tt> if this set contains the given
        /// multicharacter string.
        /// </summary>
        /// <param name="s">String to be checked for containment.</param>
        /// <returns><tt>true</tt> if this set contains the specified string.</returns>
        /// <stable>ICU 2.0</stable>
        public bool Contains(char[] s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                return strings.Contains(s.ToString());
            }
            else
            {
                return Contains(cp);
            }
        }

        /// <summary>
        /// Returns <tt>true</tt> if this set contains the given
        /// multicharacter string.
        /// </summary>
        /// <param name="s">String to be checked for containment.</param>
        /// <returns><tt>true</tt> if this set contains the specified string.</returns>
        /// <stable>ICU 2.0</stable>
        internal bool Contains(ICharSequence s)
        {
            int cp = GetSingleCP(s);
            if (cp < 0)
            {
                return strings.Contains(s.ToString());
            }
            else
            {
                return Contains(cp);
            }
        }

        /// <summary>
        /// Returns true if this set contains none of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the test condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        public virtual bool ContainsNone(string s)
        {
            return Span(s, SpanCondition.NOT_CONTAINED) == s.Length;
        }

        /// <summary>
        /// Returns true if this set contains none of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the test condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        public virtual bool ContainsNone(StringBuilder s)
        {
            return Span(s, SpanCondition.NOT_CONTAINED) == s.Length;
        }

        /// <summary>
        /// Returns true if this set contains none of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the test condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        public virtual bool ContainsNone(char[] s)
        {
            return Span(s, SpanCondition.NOT_CONTAINED) == s.Length;
        }

        /// <summary>
        /// Returns true if this set contains none of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the test condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        internal virtual bool ContainsNone(ICharSequence s)
        {
            return Span(s, SpanCondition.NOT_CONTAINED) == s.Length;
        }

        /// <summary>
        /// Returns true if this set contains one or more of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        public bool ContainsSome(string s)
        {
            return !ContainsNone(s);
        }

        /// <summary>
        /// Returns true if this set contains one or more of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        public bool ContainsSome(StringBuilder s)
        {
            return !ContainsNone(s);
        }

        /// <summary>
        /// Returns true if this set contains one or more of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        public bool ContainsSome(char[] s)
        {
            return !ContainsNone(s);
        }

        /// <summary>
        /// Returns true if this set contains one or more of the characters
        /// of the given string.
        /// </summary>
        /// <param name="s">String containing characters to be checked for containment.</param>
        /// <returns>true if the condition is met.</returns>
        /// <stable>ICU 2.0</stable>
        internal bool ContainsSome(ICharSequence s)
        {
            return !ContainsNone(s);
        }

        /// <summary>
        /// Span a string using this UnicodeSet.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The length of the span.</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int Span(string s, SpanCondition spanCondition)
        {
            return Span(s, 0, spanCondition);
        }

        /// <summary>
        /// Span a string using this UnicodeSet.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The length of the span.</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int Span(StringBuilder s, SpanCondition spanCondition)
        {
            return Span(s, 0, spanCondition);
        }

        /// <summary>
        /// Span a string using this UnicodeSet.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The length of the span.</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int Span(char[] s, SpanCondition spanCondition)
        {
            return Span(s, 0, spanCondition);
        }

        /// <summary>
        /// Span a string using this UnicodeSet.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The length of the span.</returns>
        /// <stable>ICU 4.4</stable>
        internal virtual int Span(ICharSequence s, SpanCondition spanCondition)
        {
            return Span(s, 0, spanCondition);
        }

        /// <summary>
        /// Span a string using this <see cref="UnicodeSet"/>.
        /// <list type="bullet">
        ///     <item><description>If the start index is less than 0, span will start from 0.</description></item>
        ///     <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
        /// </list>
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="start">The start index that the span begins.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which ends the span (i.e. exclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int Span(string s, int start, SpanCondition spanCondition)
        {
			int ignoredOutCount;
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for span().
                return bmpSet.Span(s, start, spanCondition, out ignoredOutCount);
            }
            if (stringSpan != null)
            {
                return stringSpan.Span(s, start, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.Span(s, start, spanCondition);
                }
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out ignoredOutCount);
        }

        /// <summary>
        /// Span a string using this <see cref="UnicodeSet"/>.
        /// <list type="bullet">
        ///     <item><description>If the start index is less than 0, span will start from 0.</description></item>
        ///     <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
        /// </list>
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="start">The start index that the span begins.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which ends the span (i.e. exclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int Span(StringBuilder s, int start, SpanCondition spanCondition)
        {
			int ignoredOutCount;
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for span().
                return bmpSet.Span(s, start, spanCondition, out ignoredOutCount);
            }
            if (stringSpan != null)
            {
                return stringSpan.Span(s, start, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.Span(s, start, spanCondition);
                }
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out ignoredOutCount);
        }

        /// <summary>
        /// Span a string using this <see cref="UnicodeSet"/>.
        /// <list type="bullet">
        ///     <item><description>If the start index is less than 0, span will start from 0.</description></item>
        ///     <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
        /// </list>
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="start">The start index that the span begins.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which ends the span (i.e. exclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int Span(char[] s, int start, SpanCondition spanCondition)
        {
			int ignoredOutCount;
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for span().
                return bmpSet.Span(s, start, spanCondition, out ignoredOutCount);
            }
            if (stringSpan != null)
            {
                return stringSpan.Span(s, start, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.Span(s, start, spanCondition);
                }
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out ignoredOutCount);
        }

        /// <summary>
        /// Span a string using this <see cref="UnicodeSet"/>.
        /// <list type="bullet">
        ///     <item><description>If the start index is less than 0, span will start from 0.</description></item>
        ///     <item><description>If the start index is greater than the string length, span returns the string length.</description></item>
        /// </list>
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="start">The start index that the span begins.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which ends the span (i.e. exclusive).</returns>
        /// <stable>ICU 4.4</stable>
        internal virtual int Span(ICharSequence s, int start, SpanCondition spanCondition)
        {
			int ignoredOutCount;
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for span().
                return bmpSet.Span(s, start, spanCondition, out ignoredOutCount);
            }
            if (stringSpan != null)
            {
                return stringSpan.Span(s, start, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.Span(s, start, spanCondition);
                }
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out ignoredOutCount);
        }

        /// <summary>
        /// Same as <see cref="Span(string, SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="start"></param>
        /// <param name="spanCondition"></param>
        /// <param name="outCount">Returns the count.</param>
        /// <returns>The limit (exclusive end) of the span.</returns>
        [Obsolete("This API is ICU internal only.")]
        public virtual int SpanAndCount(string s, int start, SpanCondition spanCondition, out int outCount)
        {
            outCount = default(int);
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (stringSpan != null)
            {
                // We might also have bmpSet != null,
                // but fully-contained strings are relevant for counting elements.
                return stringSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }
            else if (bmpSet != null)
            {
                return bmpSet.Span(s, start, spanCondition, out outCount);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                which |= UnicodeSetStringSpan.WITH_COUNT;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                return strSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out outCount);
        }

        /// <summary>
        /// Same as <see cref="Span(StringBuilder, SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="start"></param>
        /// <param name="spanCondition"></param>
        /// <param name="outCount">Returns the count.</param>
        /// <returns>The limit (exclusive end) of the span.</returns>
        [Obsolete("This API is ICU internal only.")]
        public virtual int SpanAndCount(StringBuilder s, int start, SpanCondition spanCondition, out int outCount)
        {
            outCount = default(int);
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (stringSpan != null)
            {
                // We might also have bmpSet != null,
                // but fully-contained strings are relevant for counting elements.
                return stringSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }
            else if (bmpSet != null)
            {
                return bmpSet.Span(s, start, spanCondition, out outCount);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                which |= UnicodeSetStringSpan.WITH_COUNT;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                return strSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out outCount);
        }

        /// <summary>
        /// Same as <see cref="Span(char[], SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="start"></param>
        /// <param name="spanCondition"></param>
        /// <param name="outCount">Returns the count.</param>
        /// <returns>The limit (exclusive end) of the span.</returns>
        [Obsolete("This API is ICU internal only.")]
        public virtual int SpanAndCount(char[] s, int start, SpanCondition spanCondition, out int outCount)
        {
            outCount = default(int);
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (stringSpan != null)
            {
                // We might also have bmpSet != null,
                // but fully-contained strings are relevant for counting elements.
                return stringSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }
            else if (bmpSet != null)
            {
                return bmpSet.Span(s, start, spanCondition, out outCount);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                which |= UnicodeSetStringSpan.WITH_COUNT;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                return strSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out outCount);
        }

        /// <summary>
        /// Same as <see cref="Span(ICharSequence, SpanCondition)"/> but also counts the smallest number of set elements on any path across the span.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="start"></param>
        /// <param name="spanCondition"></param>
        /// <param name="outCount">Returns the count.</param>
        /// <returns>The limit (exclusive end) of the span.</returns>
        [Obsolete("This API is ICU internal only.")]
        internal virtual int SpanAndCount(ICharSequence s, int start, SpanCondition spanCondition, out int outCount)
        {
            outCount = default(int);
            int end = s.Length;
            if (start < 0)
            {
                start = 0;
            }
            else if (start >= end)
            {
                return end;
            }
            if (stringSpan != null)
            {
                // We might also have bmpSet != null,
                // but fully-contained strings are relevant for counting elements.
                return stringSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }
            else if (bmpSet != null)
            {
                return bmpSet.Span(s, start, spanCondition, out outCount);
            }
            else if (strings.Count > 0)
            {
                int which = spanCondition == SpanCondition.NOT_CONTAINED ? UnicodeSetStringSpan.FWD_UTF16_NOT_CONTAINED
                        : UnicodeSetStringSpan.FWD_UTF16_CONTAINED;
                which |= UnicodeSetStringSpan.WITH_COUNT;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                return strSpan.SpanAndCount(s, start, spanCondition, out outCount);
            }

            return SpanCodePointsAndCount(s, start, spanCondition, out outCount);
        }

        private int SpanCodePointsAndCount(string s, int start,
            SpanCondition spanCondition, out int outCount)
        {
            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int next = start;
            int length = s.Length;
            int count = 0;
            do
            {
                c = Character.CodePointAt(s, next);
                if (spanContained != Contains(c))
                {
                    break;
                }
                ++count;
                next += Character.CharCount(c);
            } while (next < length);
            outCount = count;
            return next;
        }

        private int SpanCodePointsAndCount(StringBuilder s, int start,
            SpanCondition spanCondition, out int outCount)
        {
            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int next = start;
            int length = s.Length;
            int count = 0;
            do
            {
                c = Character.CodePointAt(s, next);
                if (spanContained != Contains(c))
                {
                    break;
                }
                ++count;
                next += Character.CharCount(c);
            } while (next < length);
            outCount = count;
            return next;
        }

        private int SpanCodePointsAndCount(char[] s, int start,
            SpanCondition spanCondition, out int outCount)
        {
            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int next = start;
            int length = s.Length;
            int count = 0;
            do
            {
                c = Character.CodePointAt(s, next);
                if (spanContained != Contains(c))
                {
                    break;
                }
                ++count;
                next += Character.CharCount(c);
            } while (next < length);
            outCount = count;
            return next;
        }

        private int SpanCodePointsAndCount(ICharSequence s, int start,
            SpanCondition spanCondition, out int outCount)
        {
            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int next = start;
            int length = s.Length;
            int count = 0;
            do
            {
                c = Character.CodePointAt(s, next);
                if (spanContained != Contains(c))
                {
                    break;
                }
                ++count;
                next += Character.CharCount(c);
            } while (next < length);
            outCount = count;
            return next;
        }

        /// <summary>
        /// Span a string backwards (from the end) using this <see cref="UnicodeSet"/>.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int SpanBack(string s, SpanCondition spanCondition)
        {
            return SpanBack(s, s.Length, spanCondition);
        }

        /// <summary>
        /// Span a string backwards (from the end) using this <see cref="UnicodeSet"/>.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int SpanBack(StringBuilder s, SpanCondition spanCondition)
        {
            return SpanBack(s, s.Length, spanCondition);
        }

        /// <summary>
        /// Span a string backwards (from the end) using this <see cref="UnicodeSet"/>.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int SpanBack(char[] s, SpanCondition spanCondition)
        {
            return SpanBack(s, s.Length, spanCondition);
        }

        /// <summary>
        /// Span a string backwards (from the end) using this <see cref="UnicodeSet"/>.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        internal virtual int SpanBack(ICharSequence s, SpanCondition spanCondition)
        {
            return SpanBack(s, s.Length, spanCondition);
        }

        /// <summary>
        /// Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="UnicodeSet"/>.
        /// If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
        /// If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int SpanBack(string s, int fromIndex, SpanCondition spanCondition)
        {
            if (fromIndex <= 0)
            {
                return 0;
            }
            if (fromIndex > s.Length)
            {
                fromIndex = s.Length;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for spanBack().
                return bmpSet.SpanBack(s, fromIndex, spanCondition);
            }
            if (stringSpan != null)
            {
                return stringSpan.SpanBack(s, fromIndex, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = (spanCondition == SpanCondition.NOT_CONTAINED)
                        ? UnicodeSetStringSpan.BACK_UTF16_NOT_CONTAINED
                                : UnicodeSetStringSpan.BACK_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.SpanBack(s, fromIndex, spanCondition);
                }
            }

            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int prev = fromIndex;
            do
            {
                c = Character.CodePointBefore(s, prev);
                if (spanContained != Contains(c))
                {
                    break;
                }
                prev -= Character.CharCount(c);
            } while (prev > 0);
            return prev;
        }

        /// <summary>
        /// Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="UnicodeSet"/>.
        /// If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
        /// If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int SpanBack(StringBuilder s, int fromIndex, SpanCondition spanCondition)
        {
            if (fromIndex <= 0)
            {
                return 0;
            }
            if (fromIndex > s.Length)
            {
                fromIndex = s.Length;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for spanBack().
                return bmpSet.SpanBack(s, fromIndex, spanCondition);
            }
            if (stringSpan != null)
            {
                return stringSpan.SpanBack(s, fromIndex, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = (spanCondition == SpanCondition.NOT_CONTAINED)
                        ? UnicodeSetStringSpan.BACK_UTF16_NOT_CONTAINED
                                : UnicodeSetStringSpan.BACK_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.SpanBack(s, fromIndex, spanCondition);
                }
            }

            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int prev = fromIndex;
            do
            {
                c = Character.CodePointBefore(s, prev);
                if (spanContained != Contains(c))
                {
                    break;
                }
                prev -= Character.CharCount(c);
            } while (prev > 0);
            return prev;
        }

        /// <summary>
        /// Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="UnicodeSet"/>.
        /// If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
        /// If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        public virtual int SpanBack(char[] s, int fromIndex, SpanCondition spanCondition)
        {
            if (fromIndex <= 0)
            {
                return 0;
            }
            if (fromIndex > s.Length)
            {
                fromIndex = s.Length;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for spanBack().
                return bmpSet.SpanBack(s, fromIndex, spanCondition);
            }
            if (stringSpan != null)
            {
                return stringSpan.SpanBack(s, fromIndex, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = (spanCondition == SpanCondition.NOT_CONTAINED)
                        ? UnicodeSetStringSpan.BACK_UTF16_NOT_CONTAINED
                                : UnicodeSetStringSpan.BACK_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.SpanBack(s, fromIndex, spanCondition);
                }
            }

            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int prev = fromIndex;
            do
            {
                c = Character.CodePointBefore(s, prev);
                if (spanContained != Contains(c))
                {
                    break;
                }
                prev -= Character.CharCount(c);
            } while (prev > 0);
            return prev;
        }

        /// <summary>
        /// Span a string backwards (from the <paramref name="fromIndex"/>) using this <see cref="UnicodeSet"/>.
        /// If the <paramref name="fromIndex"/> is less than 0, SpanBack will return 0.
        /// If <paramref name="fromIndex"/> is greater than the string length, SpanBack will start from the string length.
        /// <para/>
        /// To replace, count elements, or delete spans, see <see cref="UnicodeSetSpanner"/>.
        /// </summary>
        /// <param name="s">The string to be spanned.</param>
        /// <param name="fromIndex">The index of the char (exclusive) that the string should be spanned backwards.</param>
        /// <param name="spanCondition">The span condition.</param>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        /// <stable>ICU 4.4</stable>
        internal virtual int SpanBack(ICharSequence s, int fromIndex, SpanCondition spanCondition)
        {
            if (fromIndex <= 0)
            {
                return 0;
            }
            if (fromIndex > s.Length)
            {
                fromIndex = s.Length;
            }
            if (bmpSet != null)
            {
                // Frozen set without strings, or no string is relevant for spanBack().
                return bmpSet.SpanBack(s, fromIndex, spanCondition);
            }
            if (stringSpan != null)
            {
                return stringSpan.SpanBack(s, fromIndex, spanCondition);
            }
            else if (strings.Count > 0)
            {
                int which = (spanCondition == SpanCondition.NOT_CONTAINED)
                        ? UnicodeSetStringSpan.BACK_UTF16_NOT_CONTAINED
                                : UnicodeSetStringSpan.BACK_UTF16_CONTAINED;
                UnicodeSetStringSpan strSpan = new UnicodeSetStringSpan(this, new List<string>(strings), which);
                if (strSpan.NeedsStringSpanUTF16)
                {
                    return strSpan.SpanBack(s, fromIndex, spanCondition);
                }
            }

            // Pin to 0/1 values.
            bool spanContained = (spanCondition != SpanCondition.NOT_CONTAINED);

            int c;
            int prev = fromIndex;
            do
            {
                c = Character.CodePointBefore(s, prev);
                if (spanContained != Contains(c))
                {
                    break;
                }
                prev -= Character.CharCount(c);
            } while (prev > 0);
            return prev;
        }

        /// <seealso cref="ContainsAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual bool ContainsAll(IEnumerable<string> collection)
        {
            foreach (var o in collection)
            {
                if (!Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual bool ContainsAll(IEnumerable<StringBuilder> collection)
        {
            foreach (var o in collection)
            {
                if (!Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual bool ContainsAll(IEnumerable<char[]> collection)
        {
            foreach (var o in collection)
            {
                if (!Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        internal virtual bool ContainsAll<T>(IEnumerable<T> collection) where T : ICharSequence
        {
            foreach (var o in collection)
            {
                if (!Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsNone(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual bool ContainsNone(IEnumerable<string> collection)
        {
            foreach (var o in collection)
            {
                if (Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsNone(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual bool ContainsNone(IEnumerable<StringBuilder> collection)
        {
            foreach (var o in collection)
            {
                if (Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsNone(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual bool ContainsNone(IEnumerable<char[]> collection)
        {
            foreach (var o in collection)
            {
                if (Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsNone(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        internal virtual bool ContainsNone<T>(IEnumerable<T> collection) where T : ICharSequence
        {
            foreach (var o in collection)
            {
                if (Contains(o))
                {
                    return false;
                }
            }
            return true;
        }

        /// <seealso cref="ContainsSome(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public bool ContainsSome(IEnumerable<string> collection)
        {
            return !ContainsNone(collection);
        }

        /// <seealso cref="ContainsSome(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public bool ContainsSome(IEnumerable<StringBuilder> collection)
        {
            return !ContainsNone(collection);
        }

        /// <seealso cref="ContainsSome(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public bool ContainsSome(IEnumerable<char[]> collection)
        {
            return !ContainsNone(collection);
        }

        /// <seealso cref="ContainsSome(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        internal bool ContainsSome<T>(IEnumerable<T> collection) where T : ICharSequence
        {
            return !ContainsNone(collection);
        }

        /// <seealso cref="AddAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        // See ticket #11395, this is safe.
        public virtual UnicodeSet AddAll(params string[] collection)
        {
            CheckFrozen();
            foreach (var csq in collection)
            {
                Add(csq);
            }
            return this;
        }

        /// <seealso cref="AddAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        // See ticket #11395, this is safe.
        public virtual UnicodeSet AddAll(params StringBuilder[] collection)
        {
            CheckFrozen();
            foreach (var csq in collection)
            {
                Add(csq);
            }
            return this;
        }

        /// <seealso cref="AddAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        // See ticket #11395, this is safe.
[CLSCompliant(false)]        public virtual UnicodeSet AddAll(params char[][] collection)
        {
            CheckFrozen();
            foreach (var csq in collection)
            {
                Add(csq);
            }
            return this;
        }

        /// <seealso cref="AddAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        // See ticket #11395, this is safe.
        internal virtual UnicodeSet AddAll(params ICharSequence[] collection)
        {
            CheckFrozen();
            foreach (var csq in collection)
            {
                Add(csq);
            }
            return this;
        }

        /// <seealso cref="RemoveAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual UnicodeSet RemoveAll(IEnumerable<string> collection)
        {
            CheckFrozen();
            foreach (var o in collection)
            {
                Remove(o);
            }
            return this;
        }

        /// <seealso cref="RemoveAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual UnicodeSet RemoveAll(IEnumerable<StringBuilder> collection)
        {
            CheckFrozen();
            foreach (var o in collection)
            {
                Remove(o);
            }
            return this;
        }

        /// <seealso cref="RemoveAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual UnicodeSet RemoveAll(IEnumerable<char[]> collection)
        {
            CheckFrozen();
            foreach (var o in collection)
            {
                Remove(o);
            }
            return this;
        }

        /// <seealso cref="RemoveAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        internal virtual UnicodeSet RemoveAll<T>(IEnumerable<T> collection) where T : ICharSequence
        {
            CheckFrozen();
            foreach (var o in collection)
            {
                Remove(o);
            }
            return this;
        }

        /// <seealso cref="RetainAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual UnicodeSet RetainAll(IEnumerable<string> collection)
        {
            CheckFrozen();
            // TODO optimize
            UnicodeSet toRetain = new UnicodeSet();
            toRetain.AddAll(collection);
            RetainAll(toRetain);
            return this;
        }

        /// <seealso cref="RetainAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual UnicodeSet RetainAll(IEnumerable<StringBuilder> collection)
        {
            CheckFrozen();
            // TODO optimize
            UnicodeSet toRetain = new UnicodeSet();
            toRetain.AddAll(collection);
            RetainAll(toRetain);
            return this;
        }

        /// <seealso cref="RetainAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        public virtual UnicodeSet RetainAll(IEnumerable<char[]> collection)
        {
            CheckFrozen();
            // TODO optimize
            UnicodeSet toRetain = new UnicodeSet();
            toRetain.AddAll(collection);
            RetainAll(toRetain);
            return this;
        }

        /// <seealso cref="RetainAll(UnicodeSet)"/>
        /// <stable>ICU 4.4</stable>
        internal virtual UnicodeSet RetainAll<T>(IEnumerable<T> collection) where T : ICharSequence
        {
            CheckFrozen();
            // TODO optimize
            UnicodeSet toRetain = new UnicodeSet();
            toRetain.AddAll(collection);
            RetainAll(toRetain);
            return this;
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        public static int Compare(string str, int codePoint)
        {
#pragma warning disable 612, 618
            return CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        public static int Compare(StringBuilder str, int codePoint)
        {
#pragma warning disable 612, 618
            return CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        public static int Compare(char[] str, int codePoint)
        {
#pragma warning disable 612, 618
            return CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        internal static int Compare(ICharSequence str, int codePoint)
        {
#pragma warning disable 612, 618
            return CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        public static int Compare(int codePoint, string str)
        {
#pragma warning disable 612, 618
            return -CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        public static int Compare(int codePoint, StringBuilder str)
        {
#pragma warning disable 612, 618
            return -CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        public static int Compare(int codePoint, char[] str)
        {
#pragma warning disable 612, 618
            return -CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        /// <stable>ICU 4.4</stable>
        internal static int Compare(int codePoint, ICharSequence str)
        {
#pragma warning disable 612, 618
            return -CharSequences.Compare(str, codePoint);
#pragma warning restore 612, 618
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. 
        /// Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(string s)
        {
            return CharSequences.GetSingleCodePoint(s);
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. 
        /// Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(StringBuilder s)
        {
            return CharSequences.GetSingleCodePoint(s);
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. 
        /// Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(char[] s)
        {
            return CharSequences.GetSingleCodePoint(s);
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. 
        /// Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        internal static int GetSingleCodePoint(ICharSequence s)
        {
            return CharSequences.GetSingleCodePoint(s);
        }

        /// <summary>
        /// Find the first index at or after <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, length is returned.
        /// </summary>
        [Obsolete("This API is ICU internal only.Use span instead.")]
        public virtual int FindIn(string value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            for (; fromIndex < value.Length; fromIndex += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex;
        }

        /// <summary>
        /// Find the first index at or after <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, length is returned.
        /// </summary>
        [Obsolete("This API is ICU internal only.Use span instead.")]
        public virtual int FindIn(StringBuilder value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            for (; fromIndex < value.Length; fromIndex += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex;
        }

        /// <summary>
        /// Find the first index at or after <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, length is returned.
        /// </summary>
        [Obsolete("This API is ICU internal only.Use span instead.")]
        public virtual int FindIn(char[] value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            for (; fromIndex < value.Length; fromIndex += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex;
        }

        /// <summary>
        /// Find the first index at or after <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the first place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, length is returned.
        /// </summary>
        [Obsolete("This API is ICU internal only.Use span instead.")]
        internal virtual int FindIn(ICharSequence value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            for (; fromIndex < value.Length; fromIndex += UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex;
        }

        /// <summary>
        /// Find the last index before <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, -1 is returned.
        /// BEFORE index is not in the <see cref="UnicodeSet"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only. Use spanBack instead.")]
        public virtual int FindLastIn(string value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            fromIndex -= 1;
            for (; fromIndex >= 0; fromIndex -= UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex < 0 ? -1 : fromIndex;
        }

        /// <summary>
        /// Find the last index before <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, -1 is returned.
        /// BEFORE index is not in the <see cref="UnicodeSet"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only. Use spanBack instead.")]
        public virtual int FindLastIn(StringBuilder value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            fromIndex -= 1;
            for (; fromIndex >= 0; fromIndex -= UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex < 0 ? -1 : fromIndex;
        }

        /// <summary>
        /// Find the last index before <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, -1 is returned.
        /// BEFORE index is not in the <see cref="UnicodeSet"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only. Use spanBack instead.")]
        public virtual int FindLastIn(char[] value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            fromIndex -= 1;
            for (; fromIndex >= 0; fromIndex -= UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex < 0 ? -1 : fromIndex;
        }

        /// <summary>
        /// Find the last index before <paramref name="fromIndex"/> where the <see cref="UnicodeSet"/> matches at that index.
        /// If <paramref name="findNot"/> is true, then reverse the sense of the match: find the last place where the <see cref="UnicodeSet"/> doesn't match.
        /// If there is no match, -1 is returned.
        /// BEFORE index is not in the <see cref="UnicodeSet"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only. Use spanBack instead.")]
        internal virtual int FindLastIn(ICharSequence value, int fromIndex, bool findNot)
        {
            //TODO add strings, optimize, using ICU4C algorithms
            int cp;
            fromIndex -= 1;
            for (; fromIndex >= 0; fromIndex -= UTF16.GetCharCount(cp))
            {
                cp = UTF16.CharAt(value, fromIndex);
                if (Contains(cp) != findNot)
                {
                    break;
                }
            }
            return fromIndex < 0 ? -1 : fromIndex;
        }

        /// <summary>
        /// Strips code points from source. If matches is true, script all that match <i>this</i>. 
        /// If matches is false, then strip all that <i>don't</i> match.
        /// </summary>
        /// <param name="source">The source of the <see cref="string"/> to strip from.</param>
        /// <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="UnicodeSet"/> object.</param>
        /// <returns>The string after it has been stripped.</returns>
        [Obsolete("This API is ICU internal only. Use replaceFrom.")]
        public virtual string StripFrom(string source, bool matches)
        {
            StringBuilder result = new StringBuilder();
            for (int pos = 0; pos < source.Length;)
            {
                int inside = FindIn(source, pos, !matches);
                result.Append(source.SubSequence(pos, inside));
                pos = FindIn(source, inside, matches); // get next start
            }
            return result.ToString();
        }

        /// <summary>
        /// Strips code points from source. If matches is true, script all that match <i>this</i>. 
        /// If matches is false, then strip all that <i>don't</i> match.
        /// </summary>
        /// <param name="source">The source of the <see cref="StringBuilder"/> to strip from.</param>
        /// <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="UnicodeSet"/> object.</param>
        /// <returns>The string after it has been stripped.</returns>
        [Obsolete("This API is ICU internal only. Use replaceFrom.")]
        public virtual string StripFrom(StringBuilder source, bool matches)
        {
            StringBuilder result = new StringBuilder();
            for (int pos = 0; pos < source.Length;)
            {
                int inside = FindIn(source, pos, !matches);
                result.Append(source.SubSequence(pos, inside));
                pos = FindIn(source, inside, matches); // get next start
            }
            return result.ToString();
        }

        /// <summary>
        /// Strips code points from source. If matches is true, script all that match <i>this</i>. 
        /// If matches is false, then strip all that <i>don't</i> match.
        /// </summary>
        /// <param name="source">The source of the <see cref="char[]"/> to strip from.</param>
        /// <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="UnicodeSet"/> object.</param>
        /// <returns>The string after it has been stripped.</returns>
        [Obsolete("This API is ICU internal only. Use replaceFrom.")]
        public virtual string StripFrom(char[] source, bool matches)
        {
            StringBuilder result = new StringBuilder();
            for (int pos = 0; pos < source.Length;)
            {
                int inside = FindIn(source, pos, !matches);
                result.Append(source.SubSequence(pos, inside));
                pos = FindIn(source, inside, matches); // get next start
            }
            return result.ToString();
        }

        /// <summary>
        /// Strips code points from source. If matches is true, script all that match <i>this</i>. 
        /// If matches is false, then strip all that <i>don't</i> match.
        /// </summary>
        /// <param name="source">The source of the <see cref="ICharSequence"/> to strip from.</param>
        /// <param name="matches">A bool to either strip all that matches or don't match with the current <see cref="UnicodeSet"/> object.</param>
        /// <returns>The string after it has been stripped.</returns>
        [Obsolete("This API is ICU internal only. Use replaceFrom.")]
        internal virtual string StripFrom(ICharSequence source, bool matches)
        {
            StringBuilder result = new StringBuilder();
            for (int pos = 0; pos < source.Length;)
            {
                int inside = FindIn(source, pos, !matches);
                result.Append(source.SubSequence(pos, inside));
                pos = FindIn(source, inside, matches); // get next start
            }
            return result.ToString();
        }
	}
}