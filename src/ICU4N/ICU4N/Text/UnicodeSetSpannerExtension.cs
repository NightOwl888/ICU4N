//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Support.Text;
using System;
using System.Text;
using static ICU4N.Text.UnicodeSet;

namespace ICU4N.Text
{
    public partial class UnicodeSetSpanner
    {

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(string sequence)
        {
            return CountIn(sequence, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(StringBuilder sequence)
        {
            return CountIn(sequence, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(char[] sequence)
        {
            return CountIn(sequence, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        internal virtual int CountIn(ICharSequence sequence)
        {
            return CountIn(sequence, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(string sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(StringBuilder sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(char[] sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        internal virtual int CountIn(ICharSequence sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.SIMPLE"/> or <see cref="SpanCondition.CONTAINED"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NOT_CONTAINED"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(string sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.SIMPLE"/> or <see cref="SpanCondition.CONTAINED"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NOT_CONTAINED"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(StringBuilder sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.SIMPLE"/> or <see cref="SpanCondition.CONTAINED"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NOT_CONTAINED"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(char[] sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.SIMPLE"/> or <see cref="SpanCondition.CONTAINED"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NOT_CONTAINED"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        internal virtual int CountIn(ICharSequence sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(string sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(StringBuilder sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(char[] sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string DeleteFrom(ICharSequence sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for {@link UnicodeSetSpanner} for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.CONTAINED"/> or <see cref="SpanCondition.SIMPLE"/>) 
        /// or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(string sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, spanCondition);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for {@link UnicodeSetSpanner} for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.CONTAINED"/> or <see cref="SpanCondition.SIMPLE"/>) 
        /// or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(StringBuilder sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, spanCondition);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for {@link UnicodeSetSpanner} for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.CONTAINED"/> or <see cref="SpanCondition.SIMPLE"/>) 
        /// or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(char[] sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, spanCondition);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for {@link UnicodeSetSpanner} for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.CONTAINED"/> or <see cref="SpanCondition.SIMPLE"/>) 
        /// or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string DeleteFrom(ICharSequence sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WHOLE_SPAN, spanCondition);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(string sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(StringBuilder sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(char[] sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MIN_ELEMENTS"/> using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MIN_ELEMENTS, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(string sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(StringBuilder sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(char[] sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.SIMPLE"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.SIMPLE);
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(string sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(StringBuilder sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(char[] sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
		
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the countMethod and spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.CONTAINED"/> 
        /// or <see cref="SpanCondition.SIMPLE"/>) or the non-matching (<see cref="SpanCondition.NOT_CONTAINED"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NOT_CONTAINED ? SpanCondition.SIMPLE
                    : SpanCondition.NOT_CONTAINED;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WHOLE_SPAN)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	
        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.BOTH"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(string sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.BOTH, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.BOTH"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(StringBuilder sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.BOTH, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.BOTH"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(char[] sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.BOTH, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.BOTH"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(ICharSequence sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.BOTH, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(string sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(StringBuilder sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(char[] sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.SIMPLE"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(ICharSequence sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.SIMPLE);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING, SpanCondition.SIMPLE)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.SIMPLE"/>, <see cref="SpanCondition.CONTAINED"/> or 
        /// <see cref="SpanCondition.NOT_CONTAINED"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(string sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.TRAILING)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".ToCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.LEADING)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ? sequence.ToCharSequence() : sequence.SubSequence(
                    endLeadContained, startTrailContained);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING, SpanCondition.SIMPLE)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.SIMPLE"/>, <see cref="SpanCondition.CONTAINED"/> or 
        /// <see cref="SpanCondition.NOT_CONTAINED"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(StringBuilder sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.TRAILING)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".ToCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.LEADING)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ? sequence.ToCharSequence() : sequence.SubSequence(
                    endLeadContained, startTrailContained);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING, SpanCondition.SIMPLE)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.SIMPLE"/>, <see cref="SpanCondition.CONTAINED"/> or 
        /// <see cref="SpanCondition.NOT_CONTAINED"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(char[] sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.TRAILING)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".ToCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.LEADING)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ? sequence.ToCharSequence() : sequence.SubSequence(
                    endLeadContained, startTrailContained);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.LEADING, SpanCondition.SIMPLE)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.LEADING"/>, <see cref="TrimOption.TRAILING"/>, 
        /// or <see cref="TrimOption.BOTH"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.SIMPLE"/>, <see cref="SpanCondition.CONTAINED"/> or 
        /// <see cref="SpanCondition.NOT_CONTAINED"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(ICharSequence sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.TRAILING)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".ToCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.LEADING)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ? sequence.ToCharSequence() : sequence.SubSequence(
                    endLeadContained, startTrailContained);
        }

	}
}