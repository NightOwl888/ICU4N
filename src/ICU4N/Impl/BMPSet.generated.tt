<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    XElement[] charSequenceElements = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();

    string[] charSequences = new string[charSequenceElements.Length];
    string[] charSequenceForDocs = new string[charSequenceElements.Length];
    string[] charSequenceFeatures = new string[charSequenceElements.Length];

    for (int i = 0; i < charSequenceElements.Length; i++) {
        XElement charSequenceElement = charSequenceElements[i];
        charSequences[i] = charSequenceElement.Value;
        charSequenceForDocs[i] = charSequenceElement.Value.Replace("<", "{").Replace(">", "}");

        XAttribute[] featureAttributes = charSequenceElement.Attributes("feature").ToArray();
        charSequenceFeatures[i] = featureAttributes == null ? "" : (featureAttributes.Length > 0 ? featureAttributes[0].Value : "");
    }
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Text;
using J2N;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class BMPSet
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        /// <summary>
        /// Span the initial substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
        /// It must be <paramref name="spanCondition"/>==0 or 1.
        /// </summary>
        /// <param name="s"></param>
        /// <param name="start">The start index.</param>
        /// <param name="spanCondition"></param>
        /// <param name="outCount">If not null: Receives the number of code points in the span.</param>
        /// <returns>The limit (exclusive end) of the span.</returns>
        /// <remarks>
        /// NOTE: to reduce the overhead of function call to Contains(c), it is manually inlined here. Check for
        /// sufficient length for trail unit for each surrogate pair. Handle single surrogates as surrogate code points
        /// as usual in ICU.
        /// </remarks>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> int Span(<#=charSequence#> s, int start, SpanCondition spanCondition,
            out int outCount)
        {
            char c, c2;
            int i = start;
            int limit = s.Length;
            int numSupplementary = 0;
            if (SpanCondition.NotContained != spanCondition)
            {
                // span
                while (i < limit)
                {
                    c = s[i];
                    if (c <= 0xff)
                    {
                        if (!latin1Contains[c])
                        {
                            break;
                        }
                    }
                    else if (c <= 0x7ff)
                    {
                        if ((table7FF[c & 0x3f] & (1 << (c >> 6))) == 0)
                        {
                            break;
                        }
                    }
                    else if (c < 0xd800 ||
                             c >= 0xdc00 || (i + 1) == limit || (c2 = s[i + 1]) < 0xdc00 || c2 >= 0xe000)
                    {
                        int lead = c >> 12;
                        int twoBits = (bmpBlockBits[(c >> 6) & 0x3f] >> lead) & 0x10001;
                        if (twoBits <= 1)
                        {
                            // All 64 code points with the same bits 15..6
                            // are either in the set or not.
                            if (twoBits == 0)
                            {
                                break;
                            }
                        }
                        else
                        {
                            // Look up the code point in its 4k block of code points.
                            if (!ContainsSlow(c, list4kStarts[lead], list4kStarts[lead + 1]))
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        // surrogate pair
                        int supplementary = Character.ToCodePoint(c, c2);
                        if (!ContainsSlow(supplementary, list4kStarts[0x10], list4kStarts[0x11]))
                        {
                            break;
                        }
                        ++numSupplementary;
                        ++i;
                    }
                    ++i;
                }
            }
            else
            {
                // span not
                while (i < limit)
                {
                    c = s[i];
                    if (c <= 0xff)
                    {
                        if (latin1Contains[c])
                        {
                            break;
                        }
                    }
                    else if (c <= 0x7ff)
                    {
                        if ((table7FF[c & 0x3f] & (1 << (c >> 6))) != 0)
                        {
                            break;
                        }
                    }
                    else if (c < 0xd800 ||
                             c >= 0xdc00 || (i + 1) == limit || (c2 = s[i + 1]) < 0xdc00 || c2 >= 0xe000)
                    {
                        int lead = c >> 12;
                        int twoBits = (bmpBlockBits[(c >> 6) & 0x3f] >> lead) & 0x10001;
                        if (twoBits <= 1)
                        {
                            // All 64 code points with the same bits 15..6
                            // are either in the set or not.
                            if (twoBits != 0)
                            {
                                break;
                            }
                        }
                        else
                        {
                            // Look up the code point in its 4k block of code points.
                            if (ContainsSlow(c, list4kStarts[lead], list4kStarts[lead + 1]))
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        // surrogate pair
                        int supplementary = Character.ToCodePoint(c, c2);
                        if (ContainsSlow(supplementary, list4kStarts[0x10], list4kStarts[0x11]))
                        {
                            break;
                        }
                        ++numSupplementary;
                        ++i;
                    }
                    ++i;
                }
            }
            int spanLength = i - start;
            outCount = spanLength - numSupplementary;  // number of code points
            return i;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        /// <summary>
        /// Symmetrical with <see cref="Span(<#=charSequenceForDoc#>, int, SpanCondition, out int)"/>.
        /// Span the trailing substring for which each character c has <paramref name="spanCondition"/>==Contains(c). 
        /// It must be <paramref name="s"/>.Length >= limit and <paramref name="spanCondition"/>==0 or 1.
        /// </summary>
        /// <returns>The string index which starts the span (i.e. inclusive).</returns>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> int SpanBack(<#=charSequence#> s, int limit, SpanCondition spanCondition)
        {
            char c, c2;

            if (SpanCondition.NotContained != spanCondition)
            {
                // span
                for (; ; )
                {
                    c = s[--limit];
                    if (c <= 0xff)
                    {
                        if (!latin1Contains[c])
                        {
                            break;
                        }
                    }
                    else if (c <= 0x7ff)
                    {
                        if ((table7FF[c & 0x3f] & (1 << (c >> 6))) == 0)
                        {
                            break;
                        }
                    }
                    else if (c < 0xd800 ||
                             c < 0xdc00 || 0 == limit || (c2 = s[limit - 1]) < 0xd800 || c2 >= 0xdc00)
                    {
                        int lead = c >> 12;
                        int twoBits = (bmpBlockBits[(c >> 6) & 0x3f] >> lead) & 0x10001;
                        if (twoBits <= 1)
                        {
                            // All 64 code points with the same bits 15..6
                            // are either in the set or not.
                            if (twoBits == 0)
                            {
                                break;
                            }
                        }
                        else
                        {
                            // Look up the code point in its 4k block of code points.
                            if (!ContainsSlow(c, list4kStarts[lead], list4kStarts[lead + 1]))
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        // surrogate pair
                        int supplementary = Character.ToCodePoint(c2, c);
                        if (!ContainsSlow(supplementary, list4kStarts[0x10], list4kStarts[0x11]))
                        {
                            break;
                        }
                        --limit;
                    }
                    if (0 == limit)
                    {
                        return 0;
                    }
                }
            }
            else
            {
                // span not
                for (; ; )
                {
                    c = s[--limit];
                    if (c <= 0xff)
                    {
                        if (latin1Contains[c])
                        {
                            break;
                        }
                    }
                    else if (c <= 0x7ff)
                    {
                        if ((table7FF[c & 0x3f] & (1 << (c >> 6))) != 0)
                        {
                            break;
                        }
                    }
                    else if (c < 0xd800 ||
                             c < 0xdc00 || 0 == limit || (c2 = s[limit - 1]) < 0xd800 || c2 >= 0xdc00)
                    {
                        int lead = c >> 12;
                        int twoBits = (bmpBlockBits[(c >> 6) & 0x3f] >> lead) & 0x10001;
                        if (twoBits <= 1)
                        {
                            // All 64 code points with the same bits 15..6
                            // are either in the set or not.
                            if (twoBits != 0)
                            {
                                break;
                            }
                        }
                        else
                        {
                            // Look up the code point in its 4k block of code points.
                            if (ContainsSlow(c, list4kStarts[lead], list4kStarts[lead + 1]))
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        // surrogate pair
                        int supplementary = Character.ToCodePoint(c2, c);
                        if (ContainsSlow(supplementary, list4kStarts[0x10], list4kStarts[0x11]))
                        {
                            break;
                        }
                        --limit;
                    }
                    if (0 == limit)
                    {
                        return 0;
                    }
                }
            }
            return limit + 1;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
    }
}