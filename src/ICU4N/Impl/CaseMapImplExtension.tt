<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file
    string settingsPath = System.IO.Path.Combine(Host.ResolveAssemblyReference("$(SolutionDir)"), "src/CodeGenerationSettings.xml");
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Support.Text;
using ICU4N.Text;
using ICU4N.Util;
using System.Diagnostics;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class CaseMapImpl
    {
<# foreach (var appendable in appendables) { #>

        private static int AppendCodePoint(<#=appendable#> a, int c)
        {
            if (c <= char.MaxValue)
            {
                a.Append((char)c);
                return 1;
            }
            else
            {
                a.Append((char)(0xd7c0 + (c >> 10)));
                a.Append((char)(Character.MinLowSurrogate + (c & 0x3ff)));
                return 2;
            }
        }
<# } #>
<# foreach (var appendable in appendables) { #>

        /// <summary>
        /// Appends a full case mapping result, see <see cref="UCaseProps.MaxStringLength"/>
        /// </summary>
        /// <exception cref="IOException"/>
        private static void AppendResult(int result, <#=appendable#> dest,
            int cpLength, int options, Edits edits)
        {
            // Decode the result.
            if (result < 0)
            {
                // (not) original code point
                if (edits != null)
                {
                    edits.AddUnchanged(cpLength);
                }
                if ((options & OMIT_UNCHANGED_TEXT) != 0)
                {
                    return;
                }
                AppendCodePoint(dest, ~result);
            }
            else if (result <= UCaseProps.MaxStringLength)
            {
                // The mapping has already been appended to result.
                if (edits != null)
                {
                    edits.AddReplace(cpLength, result);
                }
            }
            else
            {
                // Append the single-code point mapping.
                int length = AppendCodePoint(dest, result);
                if (edits != null)
                {
                    edits.AddReplace(cpLength, length);
                }
            }
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        private static void AppendUnchanged(<#=charSequence#> src, int start, int length,
            <#=appendable#> dest, int options, Edits edits)
        {
            if (length > 0)
            {
                if (edits != null)
                {
                    edits.AddUnchanged(length);
                }
                if ((options & OMIT_UNCHANGED_TEXT) != 0)
                {
                    return;
                }
<# if (appendable == "IAppendable") { #>
                dest.Append(src, start, start + length);
<# } else { #>
                dest.Append(src, start, length); // ICU4N: (start + length) - start == length
<# } #>
            }
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        private static string ApplyEdits(<#=charSequence#> src, StringBuilder replacementChars, Edits edits)
        {
            if (!edits.HasChanges)
            {
                return src.ToString();
            }
            StringBuilder result = new StringBuilder(src.Length + edits.LengthDelta);
            for (EditsEnumerator ei = edits.GetCoarseEnumerator(); ei.MoveNext();)
            {
                if (ei.HasChange)
                {
                    int i = ei.ReplacementIndex;
                    result.Append(replacementChars, i, ei.NewLength); // ICU4N: (i + ei.NewLength) - i == ei.NewLength
                }
                else
                {
                    int i = ei.SourceIndex;
                    result.Append(src, i, ei.OldLength); // ICU4N: (i + ie.OldLength) - i == ie.OldLength
                }
            }
            return result.ToString();
        }
<# } #>
<# foreach (var appendable in appendables) { #>

        private static void InternalToLower(CaseLocale caseLocale, int options, StringContextIterator iter,
            <#=appendable#> dest, Edits edits)
        {
            int c;
            while ((c = iter.NextCaseMapCP()) >= 0)
            {
                c = UCaseProps.Instance.ToFullLower(c, iter, dest, caseLocale);
                AppendResult(c, dest, iter.CPLength, options, edits);
            }
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static string ToLower(CaseLocale caseLocale, int options, <#=charSequence#> src)
        {
            if (src.Length <= 100 && (options & OMIT_UNCHANGED_TEXT) == 0)
            {
                if (src.Length == 0)
                {
                    return src.ToString();
                }
                // Collect and apply only changes.
                // Good if no or few changes. Bad (slow) if many changes.
                Edits edits = new Edits();
                StringBuilder replacementChars = ToLower(
                        caseLocale, options | OMIT_UNCHANGED_TEXT, src, new StringBuilder(), edits);
                return ApplyEdits(src, replacementChars, edits);
            }
            else
            {
                return ToLower(caseLocale, options, src,
                        new StringBuilder(src.Length), null).ToString();
            }
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

<# if (appendable == "IAppendable") { #>
        <#=charSequenceAccessibility#> static T ToLower<T>(CaseLocale caseLocale, int options,
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static <#=appendable#> ToLower(CaseLocale caseLocale, int options,
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            try
            {
                if (edits != null)
                {
                    edits.Reset();
                }
                StringContextIterator iter = new StringContextIterator(src);
                InternalToLower(caseLocale, options, iter, dest, edits);
                return dest;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static string ToUpper(CaseLocale caseLocale, int options, <#=charSequence#> src)
        {
            if (src.Length <= 100 && (options & OMIT_UNCHANGED_TEXT) == 0)
            {
                if (src.Length == 0)
                {
                    return src.ToString();
                }
                // Collect and apply only changes.
                // Good if no or few changes. Bad (slow) if many changes.
                Edits edits = new Edits();
                StringBuilder replacementChars = ToUpper(
                        caseLocale, options | OMIT_UNCHANGED_TEXT, src, new StringBuilder(), edits);
                return ApplyEdits(src, replacementChars, edits);
            }
            else
            {
                return ToUpper(caseLocale, options, src,
                        new StringBuilder(src.Length), null).ToString();
            }
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

<# if (appendable == "IAppendable") { #>
        <#=charSequenceAccessibility#> static T ToUpper<T>(CaseLocale caseLocale, int options,
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static <#=appendable#> ToUpper(CaseLocale caseLocale, int options,
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            try
            {
                if (edits != null)
                {
                    edits.Reset();
                }
                if (caseLocale == CaseLocale.Greek)
                {
                    return GreekUpper.ToUpper(options, src, dest, edits);
                }
                StringContextIterator iter = new StringContextIterator(src);
                int c;
                while ((c = iter.NextCaseMapCP()) >= 0)
                {
                    c = UCaseProps.Instance.ToFullUpper(c, iter, dest, caseLocale);
                    AppendResult(c, dest, iter.CPLength, options, edits);
                }
                return dest;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static string ToTitle(CaseLocale caseLocale, int options, BreakIterator iter, <#=charSequence#> src)
        {
            if (src.Length <= 100 && (options & OMIT_UNCHANGED_TEXT) == 0)
            {
                if (src.Length == 0)
                {
                    return src.ToString();
                }
                // Collect and apply only changes.
                // Good if no or few changes. Bad (slow) if many changes.
                Edits edits = new Edits();
                StringBuilder replacementChars = ToTitle(
                        caseLocale, options | OMIT_UNCHANGED_TEXT, iter, src,
                        new StringBuilder(), edits);
                return ApplyEdits(src, replacementChars, edits);
            }
            else
            {
                return ToTitle(caseLocale, options, iter, src,
                        new StringBuilder(src.Length), null).ToString();
            }
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

<# if (appendable == "IAppendable") { #>
        <#=charSequenceAccessibility#> static T ToTitle<T>(
            CaseLocale caseLocale, int options, BreakIterator titleIter,
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static <#=appendable#> ToTitle(
            CaseLocale caseLocale, int options, BreakIterator titleIter,
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            try
            {
                if (edits != null)
                {
                    edits.Reset();
                }

                /* set up local variables */
                StringContextIterator iter = new StringContextIterator(src);
                int srcLength = src.Length;
                int prev = 0;
                bool isFirstIndex = true;

                /* titlecasing loop */
                while (prev < srcLength)
                {
                    /* find next index where to titlecase */
                    int index;
                    if (isFirstIndex)
                    {
                        isFirstIndex = false;
                        index = titleIter.First();
                    }
                    else
                    {
                        index = titleIter.Next();
                    }
                    if (index == BreakIterator.Done || index > srcLength)
                    {
                        index = srcLength;
                    }

                    /*
                     * Segment [prev..index[ into 3 parts:
                     * a) skipped characters (copy as-is) [prev..titleStart[
                     * b) first letter (titlecase)              [titleStart..titleLimit[
                     * c) subsequent characters (lowercase)                 [titleLimit..index[
                     */
                    if (prev < index)
                    {
                        // Find and copy skipped characters [prev..titleStart[
                        int titleStart = prev;
                        iter.SetLimit(index);
                        int c = iter.NextCaseMapCP();
                        if ((options & UChar.TitleCaseNoBreakAdjustment) == 0)
                        {
                            // Adjust the titlecasing index to the next cased character,
                            // or to the next letter/number/symbol/private use.
                            // Stop with titleStart<titleLimit<=index
                            // if there is a character to be titlecased,
                            // or else stop with titleStart==titleLimit==index.
                            bool toCased = (options & CaseMapImpl.TITLECASE_ADJUST_TO_CASED) != 0;
                            while ((toCased ?
                                        UCaseProps.None == UCaseProps.Instance.GetType(c) :
                                            !CaseMapImpl.IsLNS(c)) &&
                                    (c = iter.NextCaseMapCP()) >= 0) { }
                            // If c<0 then we have only uncased characters in [prev..index[
                            // and stopped with titleStart==titleLimit==index.
                            titleStart = iter.CPStart;
                            if (prev < titleStart)
                            {
                                AppendUnchanged(src, prev, titleStart - prev, dest, options, edits);
                            }
                        }

                        if (titleStart < index)
                        {
                            int titleLimit = iter.CPLimit;
                            // titlecase c which is from [titleStart..titleLimit[
                            c = UCaseProps.Instance.ToFullTitle(c, iter, dest, caseLocale);
                            AppendResult(c, dest, iter.CPLength, options, edits);

                            // Special case Dutch IJ titlecasing
                            if (titleStart + 1 < index && caseLocale == CaseLocale.Dutch)
                            {
                                char c1 = src[titleStart];
                                if ((c1 == 'i' || c1 == 'I'))
                                {
                                    char c2 = src[titleStart + 1];
                                    if (c2 == 'j')
                                    {
                                        dest.Append('J');
                                        if (edits != null)
                                        {
                                            edits.AddReplace(1, 1);
                                        }
                                        c = iter.NextCaseMapCP();
                                        titleLimit++;
                                        Debug.Assert(c == c2);
                                        Debug.Assert(titleLimit == iter.CPLimit);
                                    }
                                    else if (c2 == 'J')
                                    {
                                        // Keep the capital J from getting lowercased.
                                        AppendUnchanged(src, titleStart + 1, 1, dest, options, edits);
                                        c = iter.NextCaseMapCP();
                                        titleLimit++;
                                        Debug.Assert(c == c2);
                                        Debug.Assert(titleLimit == iter.CPLimit);
                                    }
                                }
                            }

                            // lowercase [titleLimit..index[
                            if (titleLimit < index)
                            {
                                if ((options & UChar.TitleCaseNoLowerCase) == 0)
                                {
                                    // Normal operation: Lowercase the rest of the word.
                                    InternalToLower(caseLocale, options, iter, dest, edits);
                                }
                                else
                                {
                                    // Optionally just copy the rest of the word unchanged.
                                    AppendUnchanged(src, titleLimit, index - titleLimit, dest, options, edits);
                                    iter.MoveToLimit();
                                }
                            }
                        }
                    }

                    prev = index;
                }
                return dest;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static string Fold(int options, <#=charSequence#> src)
        {
            if (src.Length <= 100 && (options & OMIT_UNCHANGED_TEXT) == 0)
            {
                if (src.Length == 0)
                {
                    return src.ToString();
                }
                // Collect and apply only changes.
                // Good if no or few changes. Bad (slow) if many changes.
                Edits edits = new Edits();
                StringBuilder replacementChars = Fold(
                        options | OMIT_UNCHANGED_TEXT, src, new StringBuilder(), edits);
                return ApplyEdits(src, replacementChars, edits);
            }
            else
            {
                return Fold(options, src, new StringBuilder(src.Length), null).ToString();
            }
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

<# if (appendable == "IAppendable") { #>
        <#=charSequenceAccessibility#> static T Fold<T>(int options,
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static <#=appendable#> Fold(int options,
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            try
            {
                if (edits != null)
                {
                    edits.Reset();
                }
                int length = src.Length;
                for (int i = 0; i < length;)
                {
                    int c = Character.CodePointAt(src, i);
                    int cpLength = Character.CharCount(c);
                    i += cpLength;
                    c = UCaseProps.Instance.ToFullFolding(c, dest, options);
                    AppendResult(c, dest, cpLength, options, edits);
                }
                return dest;
            }
            catch (IOException e)
            {
                throw new ICUUncheckedIOException(e);
            }
        }
    <# } #>
<# } #>

        private sealed partial class GreekUpper
        {
<# foreach (var charSequence in charSequences) { #>

            private static bool IsFollowedByCasedLetter(<#=charSequence#> s, int i)
            {
                while (i < s.Length)
                {
                    int c = Character.CodePointAt(s, i);
                    int type = UCaseProps.Instance.GetTypeOrIgnorable(c);
                    if ((type & UCaseProps.IGNORABLE) != 0)
                    {
                        // Case-ignorable, continue with the loop.
                        i += Character.CharCount(c);
                    }
                    else if (type != UCaseProps.None)
                    {
                        return true;  // Followed by cased letter.
                    }
                    else
                    {
                        return false;  // Uncased and not case-ignorable.
                    }
                }
                return false;  // Not followed by cased letter.
            }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

            /// <summary>
            /// Greek string uppercasing with a state machine.
            /// Probably simpler than a stateless function that has to figure out complex context-before
            /// for each character.
            /// <para/>
            /// TODO: Try to re-consolidate one way or another with the non-Greek function.
            /// <para/>
            /// Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
            /// </summary>
            /// <exception cref="IOException"/>
<# if (appendable == "IAppendable") { #>
            <#=charSequenceAccessibility#> static T ToUpper<T>(int options,
                <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
            <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static <#=appendable#> ToUpper(int options,
                <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
            {
                int state = 0;
                for (int i = 0; i < src.Length;)
                {
                    int c = Character.CodePointAt(src, i);
                    int nextIndex = i + Character.CharCount(c);
                    int nextState = 0;
                    int type = UCaseProps.Instance.GetTypeOrIgnorable(c);
                    if ((type & UCaseProps.IGNORABLE) != 0)
                    {
                        // c is case-ignorable
                        nextState |= (state & AFTER_CASED);
                    }
                    else if (type != UCaseProps.None)
                    {
                        // c is cased
                        nextState |= AFTER_CASED;
                    }
                    int data = GetLetterData(c);
                    if (data > 0)
                    {
                        int upper = data & UPPER_MASK;
                        // Add a dialytika to this iota or ypsilon vowel
                        // if we removed a tonos from the previous vowel,
                        // and that previous vowel did not also have (or gain) a dialytika.
                        // Adding one only to the final vowel in a longer sequence
                        // (which does not occur in normal writing) would require lookahead.
                        // Set the same flag as for preserving an existing dialytika.
                        if ((data & HAS_VOWEL) != 0 && (state & AFTER_VOWEL_WITH_ACCENT) != 0 &&
                                (upper == 'Ι' || upper == 'Υ'))
                        {
                            data |= HAS_DIALYTIKA;
                        }
                        int numYpogegrammeni = 0;  // Map each one to a trailing, spacing, capital iota.
                        if ((data & HAS_YPOGEGRAMMENI) != 0)
                        {
                            numYpogegrammeni = 1;
                        }
                        // Skip combining diacritics after this Greek letter.
                        while (nextIndex < src.Length)
                        {
                            int diacriticData = GetDiacriticData(src[nextIndex]);
                            if (diacriticData != 0)
                            {
                                data |= diacriticData;
                                if ((diacriticData & HAS_YPOGEGRAMMENI) != 0)
                                {
                                    ++numYpogegrammeni;
                                }
                                ++nextIndex;
                            }
                            else
                            {
                                break;  // not a Greek diacritic
                            }
                        }
                        if ((data & HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA) == HAS_VOWEL_AND_ACCENT)
                        {
                            nextState |= AFTER_VOWEL_WITH_ACCENT;
                        }
                        // Map according to Greek rules.
                        bool addTonos = false;
                        if (upper == 'Η' &&
                                (data & HAS_ACCENT) != 0 &&
                                numYpogegrammeni == 0 &&
                                (state & AFTER_CASED) == 0 &&
                                !IsFollowedByCasedLetter(src, nextIndex))
                        {
                            // Keep disjunctive "or" with (only) a tonos.
                            // We use the same "word boundary" conditions as for the Final_Sigma test.
                            if (i == nextIndex)
                            {
                                upper = 'Ή';  // Preserve the precomposed form.
                            }
                            else
                            {
                                addTonos = true;
                            }
                        }
                        else if ((data & HAS_DIALYTIKA) != 0)
                        {
                            // Preserve a vowel with dialytika in precomposed form if it exists.
                            if (upper == 'Ι')
                            {
                                upper = 'Ϊ';
                                data &= ~HAS_EITHER_DIALYTIKA;
                            }
                            else if (upper == 'Υ')
                            {
                                upper = 'Ϋ';
                                data &= ~HAS_EITHER_DIALYTIKA;
                            }
                        }

                        bool change;
                        if (edits == null && (options & OMIT_UNCHANGED_TEXT) == 0)
                        {
                            change = true;  // common, simple usage
                        }
                        else
                        {
                            // Find out first whether we are changing the text.
                            change = src[i] != upper || numYpogegrammeni > 0;
                            int i2 = i + 1;
                            if ((data & HAS_EITHER_DIALYTIKA) != 0)
                            {
                                change |= i2 >= nextIndex || src[i2] != 0x308;
                                ++i2;
                            }
                            if (addTonos)
                            {
                                change |= i2 >= nextIndex || src[i2] != 0x301;
                                ++i2;
                            }
                            int oldLength = nextIndex - i;
                            int newLength = (i2 - i) + numYpogegrammeni;
                            change |= oldLength != newLength;
                            if (change)
                            {
                                if (edits != null)
                                {
                                    edits.AddReplace(oldLength, newLength);
                                }
                            }
                            else
                            {
                                if (edits != null)
                                {
                                    edits.AddUnchanged(oldLength);
                                }
                                // Write unchanged text?
                                change = (options & OMIT_UNCHANGED_TEXT) == 0;
                            }
                        }

                        if (change)
                        {
                            dest.Append((char)upper);
                            if ((data & HAS_EITHER_DIALYTIKA) != 0)
                            {
                                dest.Append('\u0308');  // restore or add a dialytika
                            }
                            if (addTonos)
                            {
                                dest.Append('\u0301');
                            }
                            while (numYpogegrammeni > 0)
                            {
                                dest.Append('Ι');
                                --numYpogegrammeni;
                            }
                        }
                    }
                    else
                    {
                        c = UCaseProps.Instance.ToFullUpper(c, null, dest, CaseLocale.Greek);
                        AppendResult(c, dest, nextIndex - i, options, edits);
                    }
                    i = nextIndex;
                    state = nextState;
                }
                return dest;
            }
    <# } #>
<# } #>

        }
    }
}