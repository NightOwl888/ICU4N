<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Where(x => x.Value != "ValueStringBuilder").Select(x => x.Value).ToArray();

    int paramCount = 16;
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Text;
using J2N.Text;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

namespace ICU4N.Impl
{
    public static partial class SimpleFormatterImpl
    {
        #region FormatCompiledPattern/TryFormatCompiledPattern

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">The <#=GetOrdinalString(j + 1)#> argument value.</param>
<# } #>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, <#=GenerateValuesParams(i + 1)#>);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

<# } #>

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
<# } #>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, <#=GenerateValuesParams(i + 1)#>);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

<# } #>

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
<# } #>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
#if FEATURE_METHODIMPLOPTIONS_AGRESSIVEINLINING
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, <#=GenerateValuesParams(i + 1)#>);

<# } #>

        #endregion FormatCompiledPattern/TryFormatCompiledPattern

        #region FormatRawPattern/TryFormatRawPattern

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">The <#=GetOrdinalString(j + 1)#> argument value.</param>
<# } #>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, <#=GenerateValuesParams(i + 1)#>);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

<# } #>

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
<# } #>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, <#=GenerateValuesParams(i + 1)#>);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

<# } #>


<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
<# } #>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, <#=GenerateValuesParams(i + 1)#>);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

<# } #>

        #endregion FormatRawPattern/TryFormatRawPattern

        #region FormatAndAppend

<# for (int i = 3; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
<# } #>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
#if FEATURE_METHODIMPLOPTIONS_AGRESSIVEINLINING
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(<#=GenerateValuesParams(i + 1)#>));

<# } #>

        #endregion FormatAndAppend

        #region FormatAndReplace


<# for (int i = 3; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
<# } #>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
#if FEATURE_METHODIMPLOPTIONS_AGRESSIVEINLINING
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(<#=GenerateValuesParams(i + 1)#>));

<# } #>

        #endregion FormatAndReplace
    }
}
<#+
    public string GenerateValuesParams(int count, string typeName = null) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                result.Append(", ");
            }
            if (!string.IsNullOrEmpty(typeName)) {
                result.Append(typeName);
                result.Append(' ');
            }
            result.Append("value");
            result.Append(i);
        }
        return result.ToString();
    }
    public string GetOrdinalString(int count)
    {
        switch (count)
        {
            case 1:
                return "first";
            case 2:
                return "second";
            case 3:
                return "third";
            case 4:
                return "fourth";
            case 5:
                return "fifth";
            case 6:
                return "sixth";
            case 7:
                return "seventh";
            case 8:
                return "eighth";
            case 9:
                return "ninth";
            case 10:
                return "tenth";
            case 11:
                return "eleventh";
            case 12:
                return "twelveth";
            case 13:
                return "thirteenth";
            case 14:
                return "fourteenth";
            case 15:
                return "fifteenth";
            case 16:
                return "sixteenth";
            default:
                return string.Empty;
        }
    }
#>