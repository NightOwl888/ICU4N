<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
	// Load common settings from the XML file
	string settingsPath = System.IO.Path.Combine(Host.ResolveAssemblyReference("$(SolutionDir)"), "src/CodeGenerationSettings.xml");
	XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
	string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
	string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Globalization;
using ICU4N.Support.Text;
using ICU4N.Text;
using J2N;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class UTS46 : IDNA
    {
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder LabelToASCII(<#=charSequence#> label, StringBuilder dest, IDNAInfo info)
        {
            return Process(label, true, true, dest, info);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder LabelToUnicode(<#=charSequence#> label, StringBuilder dest, IDNAInfo info)
        {
            return Process(label, true, false, dest, info);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder NameToASCII(<#=charSequence#> name, StringBuilder dest, IDNAInfo info)
        {
            Process(name, false, true, dest, info);
            if (dest.Length >= 254 && !info.Errors.Contains(IDNAError.DomainNameTooLong) &&
                IsASCIIString(dest) &&
                (dest.Length > 254 || dest[253] != '.')
            )
            {
#pragma warning disable 612, 618
                AddError(info, IDNAError.DomainNameTooLong);
#pragma warning restore 612, 618
            }
            return dest;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder NameToUnicode(<#=charSequence#> name, StringBuilder dest, IDNAInfo info)
        {
            return Process(name, false, false, dest, info);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        private static bool IsASCIIString(<#=charSequence#> dest)
        {
            int length = dest.Length;
            for (int i = 0; i < length; ++i)
            {
                if (dest[i] > 0x7f)
                {
                    return false;
                }
            }
            return true;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        private StringBuilder Process(<#=charSequence#> src,
            bool isLabel, bool toASCII,
            StringBuilder dest,
            IDNAInfo info)
        {
<# if (charSequence=="StringBuilder" || charSequence=="ICharSequence") { #>
            // uts46Norm2.Normalize() would do all of this error checking and setup,
            // but with the ASCII fastpath we do not always call it, and do not
            // call it first.
<# if (charSequence=="StringBuilder") { #>
            if (dest == src)
<# } else { #>
            if (src is StringBuilderCharSequence && dest == ((StringBuilderCharSequence)src).Value)
<# } #>
            {
                throw new ArgumentException();
            }
<# } #>
            // Arguments are fine, reset output values.
            dest.Delete(0, 0x7fffffff);
#pragma warning disable 612, 618
            ResetInfo(info);
#pragma warning restore 612, 618
            int srcLength = src.Length;
            if (srcLength == 0)
            {
#pragma warning disable 612, 618
                AddError(info, IDNAError.EmptyLabel);
#pragma warning restore 612, 618
                return dest;
            }
            // ASCII fastpath
            bool disallowNonLDHDot = (options & UTS46Options.UseSTD3Rules) != 0;
            int labelStart = 0;
            int i;
            for (i = 0; ; ++i)
            {
                if (i == srcLength)
                {
                    if (toASCII)
                    {
                        if ((i - labelStart) > 63)
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.LabelTooLong);
#pragma warning restore 612, 618
                        }
                        // There is a trailing dot if labelStart==i.
                        if (!isLabel && i >= 254 && (i > 254 || labelStart < i))
                        {
#pragma warning disable 612, 618
                            AddError(info, IDNAError.DomainNameTooLong);
                        }
                    }
                    PromoteAndResetLabelErrors(info);
#pragma warning restore 612, 618
                    return dest;
                }
                char c = src[i];
                if (c > 0x7f)
                {
                    break;
                }
                int cData = asciiData[c];
                if (cData > 0)
                {
                    dest.Append((char)(c + 0x20));  // Lowercase an uppercase ASCII letter.
                }
                else if (cData < 0 && disallowNonLDHDot)
                {
                    break;  // Replacing with U+FFFD can be complicated for toASCII.
                }
                else
                {
                    dest.Append(c);
                    if (c == '-')
                    {  // hyphen
                        if (i == (labelStart + 3) && src[i - 1] == '-')
                        {
                            // "??--..." is Punycode or forbidden.
                            ++i;  // '-' was copied to dest already
                            break;
                        }
#pragma warning disable 612, 618
                        if (i == labelStart)
                        {
                            // label starts with "-"
                            AddLabelError(info, IDNAError.LeadingHyphen);
                        }
                        if ((i + 1) == srcLength || src[i + 1] == '.')
                        {
                            // label ends with "-"
                            AddLabelError(info, IDNAError.TrailingHyphen);
                        }
#pragma warning restore 612, 618
                    }
                    else if (c == '.')
                    {  // dot
                        if (isLabel)
                        {
                            // Replacing with U+FFFD can be complicated for toASCII.
                            ++i;  // '.' was copied to dest already
                            break;
                        }
                        if (i == labelStart)
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.EmptyLabel);
#pragma warning restore 612, 618
                        }
                        if (toASCII && (i - labelStart) > 63)
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.LabelTooLong);
                        }
                        PromoteAndResetLabelErrors(info);
#pragma warning restore 612, 618
                        labelStart = i + 1;
                    }
                }
            }
#pragma warning disable 612, 618
            PromoteAndResetLabelErrors(info);
            ProcessUnicode(src, labelStart, i, isLabel, toASCII, dest, info);
            if (IsBiDi(info) && !HasCertainErrors(info, severeErrors) &&
                (!IsOkBiDi(info) || (labelStart > 0 && !IsASCIIOkBiDi(dest, labelStart)))
            )
            {
                AddError(info, IDNAError.BiDi);
#pragma warning restore 612, 618
            }
            return dest;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        private StringBuilder ProcessUnicode(<#=charSequence#> src,
            int labelStart, int mappingStart,
            bool isLabel, bool toASCII,
            StringBuilder dest,
            IDNAInfo info)
        {
            if (mappingStart == 0)
            {
                uts46Norm2.Normalize(src, dest);
            }
            else
            {
                uts46Norm2.NormalizeSecondAndAppend(dest, src.Subsequence(mappingStart, src.Length - mappingStart)); // ICU4N: Corrected 2nd parameter
            }
            bool doMapDevChars =
                toASCII ? (options & UTS46Options.NontransitionalToASCII) == 0 :
                          (options & UTS46Options.NontransitionalToUnicode) == 0;
            int destLength = dest.Length;
            int labelLimit = labelStart;
            while (labelLimit < destLength)
            {
                char c = dest[labelLimit];
                if (c == '.' && !isLabel)
                {
                    int labelLength = labelLimit - labelStart;
                    int newLength = ProcessLabel(dest, labelStart, labelLength,
                                                    toASCII, info);
#pragma warning disable 612, 618
                    PromoteAndResetLabelErrors(info);
#pragma warning restore 612, 618
                    destLength += newLength - labelLength;
                    labelLimit = labelStart += newLength + 1;
                }
                else if (0xdf <= c && c <= 0x200d && (c == 0xdf || c == 0x3c2 || c >= 0x200c))
                {
#pragma warning disable 612, 618
                    SetTransitionalDifferent(info);
#pragma warning restore 612, 618
                    if (doMapDevChars)
                    {
                        destLength = MapDevChars(dest, labelStart, labelLimit);
                        // Do not increment labelLimit in case c was removed.
                        // All deviation characters have been mapped, no need to check for them again.
                        doMapDevChars = false;
                    }
                    else
                    {
                        ++labelLimit;
                    }
                }
                else
                {
                    ++labelLimit;
                }
            }
            // Permit an empty label at the end (0<labelStart==labelLimit==destLength is ok)
            // but not an empty label elsewhere nor a completely empty domain name.
            // processLabel() sets UIDNA_ERROR_EMPTY_LABEL when labelLength==0.
            if (0 == labelStart || labelStart < labelLimit)
            {
                ProcessLabel(dest, labelStart, labelLimit - labelStart, toASCII, info);
#pragma warning disable 612, 618
                PromoteAndResetLabelErrors(info);
#pragma warning restore 612, 618
            }
            return dest;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        // Replace the label in dest with the label string, if the label was modified.
        // If label==dest then the label was modified in-place and labelLength
        // is the new label length, different from label.Length.
        // If label!=dest then labelLength==label.Length.
        // Returns labelLength (= the new label length).
        private static int ReplaceLabel(StringBuilder dest, int destLabelStart, int destLabelLength,
            <#=charSequence#> label, int labelLength)
        {
<# if (charSequence=="StringBuilder") { #>
            if (label != dest)
<# } else if (charSequence=="ICharSequence") { #>
            if (label is StringBuilderCharSequence && dest != ((StringBuilderCharSequence)label).Value)
<# } #>
            {
                dest.Delete(destLabelStart, destLabelStart + destLabelLength).Insert(destLabelStart, label);
                // or dest.Replace(destLabelStart, destLabelStart+destLabelLength, label.ToString());
                // which would create a String rather than moving characters in the StringBuilder.
            }
            return labelLength;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        // We scan the whole label and check both for whether it contains RTL characters
        // and whether it passes the BiDi Rule.
        // In a BiDi domain name, all labels must pass the BiDi Rule, but we might find
        // that a domain name is a BiDi domain name (has an RTL label) only after
        // processing several earlier labels.
        private void CheckLabelBiDi(<#=charSequence#> label, int labelStart, int labelLength, IDNAInfo info)
        {
            // IDNA2008 BiDi rule
            // Get the directionality of the first character.
            int c;
            int i = labelStart;
            c = Character.CodePointAt(label, i);
            i += Character.CharCount(c);
            int firstMask = U_MASK(UBiDiProps.Instance.GetClass(c).ToInt32());
            // 1. The first character must be a character with BIDI property L, R
            // or AL.  If it has the R or AL property, it is an RTL label; if it
            // has the L property, it is an LTR label.
            if ((firstMask & ~L_R_AL_MASK) != 0)
            {
#pragma warning disable 612, 618
                SetNotOkBiDi(info);
#pragma warning restore 612, 618
            }
            // Get the directionality of the last non-NSM character.
            int lastMask;
            int labelLimit = labelStart + labelLength;
            for (; ; )
            {
                if (i >= labelLimit)
                {
                    lastMask = firstMask;
                    break;
                }
                c = Character.CodePointBefore(label, labelLimit);
                labelLimit -= Character.CharCount(c);
                UCharacterDirection dir = UBiDiProps.Instance.GetClass(c);
                if (dir != UCharacterDirection.DirNonSpacingMark)
                {
                    lastMask = U_MASK(dir.ToInt32());
                    break;
                }
            }
            // 3. In an RTL label, the end of the label must be a character with
            // BIDI property R, AL, EN or AN, followed by zero or more
            // characters with BIDI property NSM.
            // 6. In an LTR label, the end of the label must be a character with
            // BIDI property L or EN, followed by zero or more characters with
            // BIDI property NSM.
            if ((firstMask & L_MASK) != 0 ?
                    (lastMask & ~L_EN_MASK) != 0 :
                    (lastMask & ~R_AL_EN_AN_MASK) != 0
            )
            {
#pragma warning disable 612, 618
                SetNotOkBiDi(info);
#pragma warning restore 612, 618
            }
            // Add the directionalities of the intervening characters.
            int mask = firstMask | lastMask;
            while (i < labelLimit)
            {
                c = Character.CodePointAt(label, i);
                i += Character.CharCount(c);
                mask |= U_MASK(UBiDiProps.Instance.GetClass(c).ToInt32());
            }
            if ((firstMask & L_MASK) != 0)
            {
                // 5. In an LTR label, only characters with the BIDI properties L, EN,
                // ES, CS, ET, ON, BN and NSM are allowed.
                if ((mask & ~L_EN_ES_CS_ET_ON_BN_NSM_MASK) != 0)
                {
#pragma warning disable 612, 618
                    SetNotOkBiDi(info);
#pragma warning restore 612, 618
                }
            }
            else
            {
                // 2. In an RTL label, only characters with the BIDI properties R, AL,
                // AN, EN, ES, CS, ET, ON, BN and NSM are allowed.
                if ((mask & ~R_AL_AN_EN_ES_CS_ET_ON_BN_NSM_MASK) != 0)
                {
#pragma warning disable 612, 618
                    SetNotOkBiDi(info);
#pragma warning restore 612, 618
                }
                // 4. In an RTL label, if an EN is present, no AN may be present, and
                // vice versa.
                if ((mask & EN_AN_MASK) == EN_AN_MASK)
                {
#pragma warning disable 612, 618
                    SetNotOkBiDi(info);
#pragma warning restore 612, 618
                }
            }
            // An RTL label is a label that contains at least one character of type
            // R, AL or AN. [...]
            // A "BIDI domain name" is a domain name that contains at least one RTL
            // label. [...]
            // The following rule, consisting of six conditions, applies to labels
            // in BIDI domain names.
            if ((mask & R_AL_AN_MASK) != 0)
            {
#pragma warning disable 612, 618
                SetBiDi(info);
#pragma warning restore 612, 618
            }
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        // Special code for the ASCII prefix of a BiDi domain name.
        // The ASCII prefix is all-LTR.

        // IDNA2008 BiDi rule, parts relevant to ASCII labels:
        // 1. The first character must be a character with BIDI property L [...]
        // 5. In an LTR label, only characters with the BIDI properties L, EN,
        // ES, CS, ET, ON, BN and NSM are allowed.
        // 6. In an LTR label, the end of the label must be a character with
        // BIDI property L or EN [...]

        // UTF-16 version, called for mapped ASCII prefix.
        // Cannot contain uppercase A-Z.
        // s[length-1] must be the trailing dot.
        private static bool IsASCIIOkBiDi(<#=charSequence#> s, int length)
        {
            int labelStart = 0;
            for (int i = 0; i < length; ++i)
            {
                char c = s[i];
                if (c == '.')
                {  // dot
                    if (i > labelStart)
                    {
                        c = s[i - 1];
                        if (!('a' <= c && c <= 'z') && !('0' <= c && c <= '9'))
                        {
                            // Last character in the label is not an L or EN.
                            return false;
                        }
                    }
                    labelStart = i + 1;
                }
                else if (i == labelStart)
                {
                    if (!('a' <= c && c <= 'z'))
                    {
                        // First character in the label is not an L.
                        return false;
                    }
                }
                else
                {
                    if (c <= 0x20 && (c >= 0x1c || (9 <= c && c <= 0xd)))
                    {
                        // Intermediate character in the label is a B, S or WS.
                        return false;
                    }
                }
            }
            return true;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        private bool IsLabelOkContextJ(<#=charSequence#> label, int labelStart, int labelLength)
        {
            // [IDNA2008-Tables]
            // 200C..200D  ; CONTEXTJ    # ZERO WIDTH NON-JOINER..ZERO WIDTH JOINER
            int labelLimit = labelStart + labelLength;
            for (int i = labelStart; i < labelLimit; ++i)
            {
                if (label[i] == 0x200c)
                {
                    // Appendix A.1. ZERO WIDTH NON-JOINER
                    // Rule Set:
                    //  False;
                    //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
                    //  If RegExpMatch((Joining_Type:{L,D})(Joining_Type:T)*\u200C
                    //     (Joining_Type:T)*(Joining_Type:{R,D})) Then True;
                    if (i == labelStart)
                    {
                        return false;
                    }
                    int c;
                    int j = i;
                    c = Character.CodePointBefore(label, j);
                    j -= Character.CharCount(c);
                    if (uts46Norm2.GetCombiningClass(c) == 9)
                    {
                        continue;
                    }
                    // check precontext (Joining_Type:{L,D})(Joining_Type:T)*
                    for (; ; )
                    {
                        /* UJoiningType */
                        int type = UBiDiProps.Instance.GetJoiningType(c);
                        if (type == JoiningType.Transparent)
                        {
                            if (j == 0)
                            {
                                return false;
                            }
                            c = Character.CodePointBefore(label, j);
                            j -= Character.CharCount(c);
                        }
                        else if (type == JoiningType.LeftJoining || type == JoiningType.DualJoining)
                        {
                            break;  // precontext fulfilled
                        }
                        else
                        {
                            return false;
                        }
                    }
                    // check postcontext (Joining_Type:T)*(Joining_Type:{R,D})
                    for (j = i + 1; ;)
                    {
                        if (j == labelLimit)
                        {
                            return false;
                        }
                        c = Character.CodePointAt(label, j);
                        j += Character.CharCount(c);
                        /* UJoiningType */
                        int type = UBiDiProps.Instance.GetJoiningType(c);
                        if (type == JoiningType.Transparent)
                        {
                            // just skip this character
                        }
                        else if (type == JoiningType.RightJoining || type == JoiningType.DualJoining)
                        {
                            break;  // postcontext fulfilled
                        }
                        else
                        {
                            return false;
                        }
                    }
                }
                else if (label[i] == 0x200d)
                {
                    // Appendix A.2. ZERO WIDTH JOINER (U+200D)
                    // Rule Set:
                    //  False;
                    //  If Canonical_Combining_Class(Before(cp)) .eq.  Virama Then True;
                    if (i == labelStart)
                    {
                        return false;
                    }
                    int c = Character.CodePointBefore(label, i);
                    if (uts46Norm2.GetCombiningClass(c) != 9)
                    {
                        return false;
                    }
                }
            }
            return true;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        private void CheckLabelContextO(<#=charSequence#> label, int labelStart, int labelLength, IDNAInfo info)
        {
            int labelEnd = labelStart + labelLength - 1;  // inclusive
            int arabicDigits = 0;  // -1 for 066x, +1 for 06Fx
            for (int i = labelStart; i <= labelEnd; ++i)
            {
                int c = label[i];
                if (c < 0xb7)
                {
                    // ASCII fastpath
                }
                else if (c <= 0x6f9)
                {
                    if (c == 0xb7)
                    {
                        // Appendix A.3. MIDDLE DOT (U+00B7)
                        // Rule Set:
                        //  False;
                        //  If Before(cp) .eq.  U+006C And
                        //     After(cp) .eq.  U+006C Then True;
                        if (!(labelStart < i && label[i - 1] == 'l' &&
                             i < labelEnd && label[i + 1] == 'l'))
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.ContextOPunctuation);
#pragma warning restore 612, 618
                        }
                    }
                    else if (c == 0x375)
                    {
                        // Appendix A.4. GREEK LOWER NUMERAL SIGN (KERAIA) (U+0375)
                        // Rule Set:
                        //  False;
                        //  If Script(After(cp)) .eq.  Greek Then True;
                        if (!(i < labelEnd &&
                             UScript.Greek == UScript.GetScript(Character.CodePointAt(label, i + 1))))
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.ContextOPunctuation);
#pragma warning restore 612, 618
                        }
                    }
                    else if (c == 0x5f3 || c == 0x5f4)
                    {
                        // Appendix A.5. HEBREW PUNCTUATION GERESH (U+05F3)
                        // Rule Set:
                        //  False;
                        //  If Script(Before(cp)) .eq.  Hebrew Then True;
                        //
                        // Appendix A.6. HEBREW PUNCTUATION GERSHAYIM (U+05F4)
                        // Rule Set:
                        //  False;
                        //  If Script(Before(cp)) .eq.  Hebrew Then True;
                        if (!(labelStart < i &&
                             UScript.Hebrew == UScript.GetScript(Character.CodePointBefore(label, i))))
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.ContextOPunctuation);
#pragma warning restore 612, 618
                        }
                    }
                    else if (0x660 <= c /* && c<=0x6f9 */)
                    {
                        // Appendix A.8. ARABIC-INDIC DIGITS (0660..0669)
                        // Rule Set:
                        //  True;
                        //  For All Characters:
                        //    If cp .in. 06F0..06F9 Then False;
                        //  End For;
                        //
                        // Appendix A.9. EXTENDED ARABIC-INDIC DIGITS (06F0..06F9)
                        // Rule Set:
                        //  True;
                        //  For All Characters:
                        //    If cp .in. 0660..0669 Then False;
                        //  End For;
                        if (c <= 0x669)
                        {
                            if (arabicDigits > 0)
                            {
#pragma warning disable 612, 618
                                AddLabelError(info, IDNAError.ContextODigits);
#pragma warning restore 612, 618
                            }
                            arabicDigits = -1;
                        }
                        else if (0x6f0 <= c)
                        {
                            if (arabicDigits < 0)
                            {
#pragma warning disable 612, 618
                                AddLabelError(info, IDNAError.ContextODigits);
#pragma warning restore 612, 618
                            }
                            arabicDigits = 1;
                        }
                    }
                }
                else if (c == 0x30fb)
                {
                    // Appendix A.7. KATAKANA MIDDLE DOT (U+30FB)
                    // Rule Set:
                    //  False;
                    //  For All Characters:
                    //    If Script(cp) .in. {Hiragana, Katakana, Han} Then True;
                    //  End For;
                    for (int j = labelStart; ; j += Character.CharCount(c))
                    {
                        if (j > labelEnd)
                        {
#pragma warning disable 612, 618
                            AddLabelError(info, IDNAError.ContextOPunctuation);
#pragma warning restore 612, 618
                            break;
                        }
                        c = Character.CodePointAt(label, j);
                        int script = UScript.GetScript(c);
                        if (script == UScript.Hiragana || script == UScript.Katakana || script == UScript.Han)
                        {
                            break;
                        }
                    }
                }
            }
        }
<# } #>
	}
}