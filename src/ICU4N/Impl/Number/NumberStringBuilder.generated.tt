<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    XElement[] charSequenceElements = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Where(x => x.Value != "ValueStringBuilder").Select(x => x.Value).ToArray();

    string[] charSequences = new string[charSequenceElements.Length];
    string[] charSequenceForDocs = new string[charSequenceElements.Length];
    string[] charSequenceFeatures = new string[charSequenceElements.Length];

    for (int i = 0; i < charSequenceElements.Length; i++) {
        XElement charSequenceElement = charSequenceElements[i];
        charSequences[i] = charSequenceElement.Value;
        charSequenceForDocs[i] = charSequenceElement.Value == "ReadOnlySpan<char>" ? "ReadOnlySpan{Char}" : charSequenceElement.Value;

        XAttribute[] featureAttributes = charSequenceElement.Attributes("feature").ToArray();
        charSequenceFeatures[i] = featureAttributes == null ? "" : (featureAttributes.Length > 0 ? featureAttributes[0].Value : "");
    }
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System;
using System.Text;
using Field = ICU4N.Text.NumberFormatField;

namespace ICU4N.Numerics
{
    internal partial class NumberStringBuilder
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Appends the specified <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/> to the end of the string.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/>.</returns>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual int Append(<#=charSequence#> sequence, Field field)
        {
            return Insert(length, sequence, field);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Inserts the specified <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/> at the specified index in the string.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/>.</returns>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual int Insert(int index, <#=charSequence#> sequence, Field field)
        {
            if (sequence.Length == 0)
            {
                // Nothing to insert.
                return 0;
            }
            else if (sequence.Length == 1)
            {
                // Fast path: on a single-char string, using insertCodePoint below is 70% faster than the
                // CharSequence method: 12.2 ns versus 41.9 ns for five operations on my Linux x86-64.
                return InsertCodePoint(index, sequence[0], field);
            }
            else
            {
                return Insert(index, sequence, 0, sequence.Length, field);
            }
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Inserts the specified <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/> at the specified index in the string, reading from the
        /// <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/> from <paramref name="startIndex"/> and including <paramref name="length"/> characters.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="startIndex"></param>
        /// <param name="length"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="<#= charSequence=="char[]" ? "T:char[]" : charSequenceForDoc #>"/>.</returns>
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual int Insert(int index, <#=charSequence#> sequence, int startIndex, int length, Field field)
        {
            int position = PrepareForInsert(index, length);
            for (int i = 0; i < length; i++)
            {
                chars[position + i] = sequence[startIndex + i];
                fields[position + i] = field;
            }
            return length;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
    }
}