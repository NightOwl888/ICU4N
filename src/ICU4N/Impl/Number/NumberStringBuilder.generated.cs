//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System;
using System.Text;
using Field = ICU4N.Text.NumberFormatField;

namespace ICU4N.Numerics
{
    internal partial class NumberStringBuilder
    {

        /// <summary>
        /// Appends the specified <see cref="string"/> to the end of the string.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="string"/>.</returns>
        public virtual int Append(string sequence, Field field)
        {
            return Insert(length, sequence, field);
        }


        /// <summary>
        /// Appends the specified <see cref="StringBuilder"/> to the end of the string.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="StringBuilder"/>.</returns>
        public virtual int Append(StringBuilder sequence, Field field)
        {
            return Insert(length, sequence, field);
        }


        /// <summary>
        /// Appends the specified <see cref="T:char[]"/> to the end of the string.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="T:char[]"/>.</returns>
        public virtual int Append(char[] sequence, Field field)
        {
            return Insert(length, sequence, field);
        }


        /// <summary>
        /// Appends the specified <see cref="ICharSequence"/> to the end of the string.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="ICharSequence"/>.</returns>
        public virtual int Append(ICharSequence sequence, Field field)
        {
            return Insert(length, sequence, field);
        }

#if FEATURE_SPAN
        /// <summary>
        /// Appends the specified <see cref="ReadOnlySpan{Char}"/> to the end of the string.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="ReadOnlySpan{Char}"/>.</returns>
        public virtual int Append(ReadOnlySpan<char> sequence, Field field)
        {
            return Insert(length, sequence, field);
        }
#endif // FEATURE_SPAN

        /// <summary>
        /// Inserts the specified <see cref="string"/> at the specified index in the string.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="string"/>.</returns>
        public virtual int Insert(int index, string sequence, Field field)
        {
            if (sequence.Length == 0)
            {
                // Nothing to insert.
                return 0;
            }
            else if (sequence.Length == 1)
            {
                // Fast path: on a single-char string, using insertCodePoint below is 70% faster than the
                // CharSequence method: 12.2 ns versus 41.9 ns for five operations on my Linux x86-64.
                return InsertCodePoint(index, sequence[0], field);
            }
            else
            {
                return Insert(index, sequence, 0, sequence.Length, field);
            }
        }


        /// <summary>
        /// Inserts the specified <see cref="StringBuilder"/> at the specified index in the string.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="StringBuilder"/>.</returns>
        public virtual int Insert(int index, StringBuilder sequence, Field field)
        {
            if (sequence.Length == 0)
            {
                // Nothing to insert.
                return 0;
            }
            else if (sequence.Length == 1)
            {
                // Fast path: on a single-char string, using insertCodePoint below is 70% faster than the
                // CharSequence method: 12.2 ns versus 41.9 ns for five operations on my Linux x86-64.
                return InsertCodePoint(index, sequence[0], field);
            }
            else
            {
                return Insert(index, sequence, 0, sequence.Length, field);
            }
        }


        /// <summary>
        /// Inserts the specified <see cref="T:char[]"/> at the specified index in the string.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="T:char[]"/>.</returns>
        public virtual int Insert(int index, char[] sequence, Field field)
        {
            if (sequence.Length == 0)
            {
                // Nothing to insert.
                return 0;
            }
            else if (sequence.Length == 1)
            {
                // Fast path: on a single-char string, using insertCodePoint below is 70% faster than the
                // CharSequence method: 12.2 ns versus 41.9 ns for five operations on my Linux x86-64.
                return InsertCodePoint(index, sequence[0], field);
            }
            else
            {
                return Insert(index, sequence, 0, sequence.Length, field);
            }
        }


        /// <summary>
        /// Inserts the specified <see cref="ICharSequence"/> at the specified index in the string.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="ICharSequence"/>.</returns>
        public virtual int Insert(int index, ICharSequence sequence, Field field)
        {
            if (sequence.Length == 0)
            {
                // Nothing to insert.
                return 0;
            }
            else if (sequence.Length == 1)
            {
                // Fast path: on a single-char string, using insertCodePoint below is 70% faster than the
                // CharSequence method: 12.2 ns versus 41.9 ns for five operations on my Linux x86-64.
                return InsertCodePoint(index, sequence[0], field);
            }
            else
            {
                return Insert(index, sequence, 0, sequence.Length, field);
            }
        }

#if FEATURE_SPAN
        /// <summary>
        /// Inserts the specified <see cref="ReadOnlySpan{Char}"/> at the specified index in the string.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="ReadOnlySpan{Char}"/>.</returns>
        public virtual int Insert(int index, ReadOnlySpan<char> sequence, Field field)
        {
            if (sequence.Length == 0)
            {
                // Nothing to insert.
                return 0;
            }
            else if (sequence.Length == 1)
            {
                // Fast path: on a single-char string, using insertCodePoint below is 70% faster than the
                // CharSequence method: 12.2 ns versus 41.9 ns for five operations on my Linux x86-64.
                return InsertCodePoint(index, sequence[0], field);
            }
            else
            {
                return Insert(index, sequence, 0, sequence.Length, field);
            }
        }
#endif // FEATURE_SPAN

        /// <summary>
        /// Inserts the specified <see cref="string"/> at the specified index in the string, reading from the
        /// <see cref="string"/> from <paramref name="startIndex"/> and including <paramref name="length"/> characters.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="startIndex"></param>
        /// <param name="length"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="string"/>.</returns>
        public virtual int Insert(int index, string sequence, int startIndex, int length, Field field)
        {
            int position = PrepareForInsert(index, length);
            for (int i = 0; i < length; i++)
            {
                chars[position + i] = sequence[startIndex + i];
                fields[position + i] = field;
            }
            return length;
        }


        /// <summary>
        /// Inserts the specified <see cref="StringBuilder"/> at the specified index in the string, reading from the
        /// <see cref="StringBuilder"/> from <paramref name="startIndex"/> and including <paramref name="length"/> characters.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="startIndex"></param>
        /// <param name="length"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="StringBuilder"/>.</returns>
        public virtual int Insert(int index, StringBuilder sequence, int startIndex, int length, Field field)
        {
            int position = PrepareForInsert(index, length);
            for (int i = 0; i < length; i++)
            {
                chars[position + i] = sequence[startIndex + i];
                fields[position + i] = field;
            }
            return length;
        }


        /// <summary>
        /// Inserts the specified <see cref="T:char[]"/> at the specified index in the string, reading from the
        /// <see cref="T:char[]"/> from <paramref name="startIndex"/> and including <paramref name="length"/> characters.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="startIndex"></param>
        /// <param name="length"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="T:char[]"/>.</returns>
        public virtual int Insert(int index, char[] sequence, int startIndex, int length, Field field)
        {
            int position = PrepareForInsert(index, length);
            for (int i = 0; i < length; i++)
            {
                chars[position + i] = sequence[startIndex + i];
                fields[position + i] = field;
            }
            return length;
        }


        /// <summary>
        /// Inserts the specified <see cref="ICharSequence"/> at the specified index in the string, reading from the
        /// <see cref="ICharSequence"/> from <paramref name="startIndex"/> and including <paramref name="length"/> characters.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="startIndex"></param>
        /// <param name="length"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="ICharSequence"/>.</returns>
        public virtual int Insert(int index, ICharSequence sequence, int startIndex, int length, Field field)
        {
            int position = PrepareForInsert(index, length);
            for (int i = 0; i < length; i++)
            {
                chars[position + i] = sequence[startIndex + i];
                fields[position + i] = field;
            }
            return length;
        }

#if FEATURE_SPAN
        /// <summary>
        /// Inserts the specified <see cref="ReadOnlySpan{Char}"/> at the specified index in the string, reading from the
        /// <see cref="ReadOnlySpan{Char}"/> from <paramref name="startIndex"/> and including <paramref name="length"/> characters.
        /// </summary>
        /// <param name="index"></param>
        /// <param name="sequence"></param>
        /// <param name="startIndex"></param>
        /// <param name="length"></param>
        /// <param name="field"></param>
        /// <returns>The number of chars added, which is the length of <see cref="ReadOnlySpan{Char}"/>.</returns>
        public virtual int Insert(int index, ReadOnlySpan<char> sequence, int startIndex, int length, Field field)
        {
            int position = PrepareForInsert(index, length);
            for (int i = 0; i < length; i++)
            {
                chars[position + i] = sequence[startIndex + i];
                fields[position + i] = field;
            }
            return length;
        }
#endif // FEATURE_SPAN
    }
}
