//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class ResourceKey
    {

        private bool RegionMatches(int start, string cs, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
        }


        private bool RegionMatches(int start, StringBuilder cs, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
        }


        private bool RegionMatches(int start, char[] cs, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
        }


        private bool RegionMatches(int start, ICharSequence cs, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
        }

#if FEATURE_SPAN

        private bool RegionMatches(int start, ReadOnlySpan<char> cs, int n)
        {
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
        }
#endif 


        public bool ContentEquals(string cs)
        {
            if (cs == null)
            {
                return false;
            }
            return (cs.Length == length && RegionMatches(0, cs, length));
        }


        public bool ContentEquals(StringBuilder cs)
        {
            if (cs == null)
            {
                return false;
            }
            return (cs.Length == length && RegionMatches(0, cs, length));
        }


        public bool ContentEquals(char[] cs)
        {
            if (cs == null)
            {
                return false;
            }
            return (cs.Length == length && RegionMatches(0, cs, length));
        }


        public bool ContentEquals(ICharSequence cs)
        {
            if (cs == null)
            {
                return false;
            }
            if (this == cs)
            {
                return true;
            }
            return (cs.Length == length && RegionMatches(0, cs, length));
        }

#if FEATURE_SPAN

        public bool ContentEquals(ReadOnlySpan<char> cs)
        {
            if (cs == null)
            {
                return false;
            }
            return (cs.Length == length && RegionMatches(0, cs, length));
        }
#endif 


        public bool StartsWith(string cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }


        public bool StartsWith(StringBuilder cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }


        public bool StartsWith(char[] cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }


        public bool StartsWith(ICharSequence cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }

#if FEATURE_SPAN

        public bool StartsWith(ReadOnlySpan<char> cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }
#endif 


        public bool EndsWith(string cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }


        public bool EndsWith(StringBuilder cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }


        public bool EndsWith(char[] cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }


        public bool EndsWith(ICharSequence cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }

#if FEATURE_SPAN

        public bool EndsWith(ReadOnlySpan<char> cs)
        {
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }
#endif 


        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, string cs)
        {
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }


        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, StringBuilder cs)
        {
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }


        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, char[] cs)
        {
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }


        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, ICharSequence cs)
        {
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }

#if FEATURE_SPAN

        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, ReadOnlySpan<char> cs)
        {
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }
#endif 


        public int CompareTo(string cs) // ICU4N TODO: Null reference check (should never throw in .NET here)
        {
            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
        }


        public int CompareTo(StringBuilder cs) // ICU4N TODO: Null reference check (should never throw in .NET here)
        {
            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
        }


        public int CompareTo(char[] cs) // ICU4N TODO: Null reference check (should never throw in .NET here)
        {
            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
        }


        public int CompareTo(ICharSequence cs) // ICU4N TODO: Null reference check (should never throw in .NET here)
        {
            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
        }

#if FEATURE_SPAN

        public int CompareTo(ReadOnlySpan<char> cs) // ICU4N TODO: Null reference check (should never throw in .NET here)
        {
            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
        }
#endif 


    }
}