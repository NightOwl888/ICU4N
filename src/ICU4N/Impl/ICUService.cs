using ICU4N.Support.Collections;
using ICU4N.Support.Globalization;
using ICU4N.Util;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Category = ICU4N.Util.ULocale.Category;

namespace ICU4N.Impl
{
    /// <summary>
    /// An <see cref="ICUService"/> provides access to service objects that implement a
    /// particular service, e.g. transliterators.  Users provide a String
    /// id (for example, a locale string) to the service, and get back an
    /// object for that id.  
    /// </summary>
    /// <remarks>
    /// <see cref="ICUService"/> objects can be any kind of object.
    /// The service object is cached and returned for later queries, so
    /// generally it should not be mutable, or the caller should clone the
    /// object before modifying it.
    /// <para/>
    /// <see cref="ICUService"/>s 'canonicalize' the query id and use the canonical id to
    /// query for the service.  The service also defines a mechanism to
    /// 'fallback' the id multiple times.  Clients can optionally request
    /// the actual id that was matched by a query when they use an id to
    /// retrieve a service object.
    /// <para/>
    /// <see cref="ICUService"/> objects are instantiated by <see cref="IServiceFactory"/> objects registered with
    /// the service.  The service queries each <see cref="IServiceFactory"/> in turn, from most recently
    /// registered to earliest registered, until one returns a service object.
    /// If none responds with a service object, a fallback id is generated,
    /// and the process repeats until a service object is returned or until
    /// the id has no further fallbacks.
    /// <para/>
    /// Factories can be dynamically registered and unregistered with the
    /// service.  When registered, a <see cref="IServiceFactory"/> is installed at the head of
    /// the factory list, and so gets 'first crack' at any keys or fallback
    /// keys.  When unregistered, it is removed from the service and can no
    /// longer be located through it.  Service objects generated by this
    /// factory and held by the client are unaffected.
    /// <para/>
    /// <see cref="ICUService"/> uses <see cref="ICUServiceKey"/>s to query factories and perform
    /// fallback.  The <see cref="ICUServiceKey"/> defines the canonical form of the id, and
    /// implements the fallback strategy.  Custom <see cref="ICUServiceKey"/>s can be defined that
    /// parse complex IDs into components that <see cref="IServiceFactory"/>s can more easily
    /// use.  The <see cref="ICUServiceKey"/> can cache the results of this parsing to save
    /// repeated effort.  <see cref="ICUService"/> provides convenience APIs that
    /// take Strings and generate default <see cref="ICUServiceKey"/>s for use in querying.
    /// <para/>
    /// <see cref="ICUService"/> provides API to get the list of ids publicly
    /// supported by the service (although queries aren't restricted to
    /// this list).  This list contains only 'simple' IDs, and not fully
    /// unique ids.  Factories are associated with each simple ID and
    /// the responsible factory can also return a human-readable localized
    /// version of the simple ID, for use in user interfaces.  <see cref="ICUService"/>
    /// can also provide a sorted collection of the all the localized visible
    /// ids.
    /// <para/>
    /// <see cref="ICUService"/> implements <see cref="ICUNotifier"/>, so that clients can register
    /// to receive notification when factories are added or removed from
    /// the service.  ICUService provides a default <see cref="IEventListener"/> subinterface,
    /// <see cref="IServiceListener"/>, which can be registered with the service.  When
    /// the service changes, the <see cref="IServiceListener.ServiceChanged(ICUService)"/> method
    /// is called, with the service as the only argument.
    /// <para/>
    /// The <see cref="ICUService"/> API is both rich and generic, and it is expected
    /// that most implementations will statically 'wrap' <see cref="ICUService"/> to
    /// present a more appropriate API-- for example, to declare the type
    /// of the objects returned from get, to limit the factories that can
    /// be registered with the service, or to define their own listener
    /// interface with a custom callback method.  They might also customize
    /// <see cref="ICUService"/> by overriding it, for example, to customize the <see cref="ICUServiceKey"/> and
    /// fallback strategy.  <see cref="ICULocaleService"/> is a customized service that
    /// uses Locale names as ids and uses Keys that implement the standard
    /// resource bundle fallback strategy.
    /// </remarks>
    public class ICUService : ICUNotifier
    {
        /// <summary>
        /// Name used for debugging.
        /// </summary>
        protected readonly string m_name;

        /// <summary>
        /// Constructor.
        /// </summary>
        public ICUService()
        {
            m_name = "";
        }

        private static readonly bool DEBUG = ICUDebug.Enabled("service");
        /// <summary>
        /// Construct with a <paramref name="name"/> (useful for debugging).
        /// </summary>
        public ICUService(string name)
        {
            this.m_name = name;
        }

        /// <summary>
        /// Access to factories is protected by a read-write lock.  This is
        /// to allow multiple threads to read concurrently, but keep
        /// changes to the factory list atomic with respect to all readers.
        /// </summary>
        private readonly ICUReaderWriterLock factoryLock = new ICUReaderWriterLock();

        /// <summary>
        /// All the factories registered with this service.
        /// </summary>
        private readonly List<IServiceFactory> factories = new List<IServiceFactory>();

        /// <summary>
        /// Record the default number of factories for this service.
        /// Can be set by <see cref="MarkDefault()"/>.
        /// </summary>
        private int defaultSize = 0;

        // ICU4N: De-nested Key and renamed ICUServiceKey

        // ICU4N: De-nested IFactory and renamed IServiceFactory

        // ICU4N: De-nested SimpleFactory and renamed ICUSimpleFactory

        /// <summary>
        /// Convenience override for <see cref="Get(string, string[])"/>. This uses
        /// <see cref="CreateKey(string)"/> to create a key for the provided <paramref name="descriptor"/>.
        /// </summary>
        public virtual object Get(string descriptor) // ICU4N TODO: API Use indexer?
        {
            return GetKey(CreateKey(descriptor), null);
        }

        /// <summary>
        /// Convenience override for <see cref="GetKey(ICUServiceKey, string[])"/>.  This uses
        /// <see cref="CreateKey(string)"/> to create a key from the provided <paramref name="descriptor"/>.
        /// </summary>
        public virtual object Get(string descriptor, string[] actualReturn) // ICU4N TODO: API Use indexer?
        {
            if (descriptor == null)
            {
                throw new ArgumentNullException("descriptor must not be null");
            }
            return GetKey(CreateKey(descriptor), actualReturn);
        }

        /// <summary>
        /// Convenience override for <see cref="GetKey(ICUServiceKey, string[])"/>.
        /// </summary>
        public virtual object GetKey(ICUServiceKey key)
        {
            return GetKey(key, null);
        }

        /// <summary>
        /// Given a <paramref name="key"/>, return a service object, and, if <paramref name="actualReturn"/>
        /// is not null, the descriptor with which it was found in the
        /// first element of <paramref name="actualReturn"/>.  If no service object matches
        /// this key, return null, and leave <paramref name="actualReturn"/> unchanged.
        /// </summary>
        /// <remarks>
        /// This queries the cache using the <paramref name="key"/>'s descriptor, and if no
        /// object in the cache matches it, tries the <paramref name="key"/> on each
        /// registered factory, in order.  If none generates a service
        /// object for the key, repeats the process with each fallback of
        /// the <paramref name="key"/>, until either one returns a service object, or the <paramref name="key"/>
        /// has no fallback.
        /// <para/>
        /// If <paramref name="key"/> is null, just returns null.
        /// </remarks>
        public virtual object GetKey(ICUServiceKey key, string[] actualReturn)
        {
            return GetKey(key, actualReturn, null);
        }

        // debugging
        // Map hardRef;

        public virtual object GetKey(ICUServiceKey key, string[] actualReturn, IServiceFactory factory)
        {
            if (factories.Count == 0)
            {
                return HandleDefault(key, actualReturn);
            }

            if (DEBUG) Console.Out.WriteLine("Service: " + m_name + " key: " + key.CanonicalID);

            CacheEntry result = null;
            if (key != null)
            {
                try
                {
                    // The factory list can't be modified until we're done,
                    // otherwise we might update the cache with an invalid result.
                    // The cache has to stay in synch with the factory list.
                    factoryLock.AcquireRead();

                    IDictionary<string, CacheEntry> cache = this.cache; // copy so we don't need to sync on this
                    if (cache == null)
                    {
                        if (DEBUG) Console.Out.WriteLine("Service " + m_name + " cache was empty");
                        // synchronized since additions and queries on the cache must be atomic
                        // they can be interleaved, though
                        cache = new ConcurrentDictionary<string, CacheEntry>();
                    }

                    string currentDescriptor = null;
                    List<string> cacheDescriptorList = null;
                    bool putInCache = false;

                    int NDebug = 0;

                    int startIndex = 0;
                    int limit = factories.Count;
                    bool cacheResult = true;
                    if (factory != null)
                    {
                        for (int i = 0; i < limit; ++i)
                        {
                            if (factory == factories[i])
                            {
                                startIndex = i + 1;
                                break;
                            }
                        }
                        if (startIndex == 0)
                        {
                            throw new InvalidOperationException("Factory " + factory + "not registered with service: " + this);
                        }
                        cacheResult = false;
                    }

                    //outer:
                    do
                    {
                        currentDescriptor = key.GetCurrentDescriptor();
                        if (DEBUG) Console.Out.WriteLine(m_name + "[" + NDebug++ + "] looking for: " + currentDescriptor);
                        result = cache.Get(currentDescriptor);
                        if (result != null)
                        {
                            if (DEBUG) Console.Out.WriteLine(m_name + " found with descriptor: " + currentDescriptor);
                            goto outer_break;
                        }
                        else
                        {
                            if (DEBUG) Console.Out.WriteLine("did not find: " + currentDescriptor + " in cache");
                        }

                        // first test of cache failed, so we'll have to update
                        // the cache if we eventually succeed-- that is, if we're
                        // going to update the cache at all.
                        putInCache = cacheResult;

                        //  int n = 0;
                        int index = startIndex;
                        while (index < limit)
                        {
                            IServiceFactory f = factories[index++];
                            if (DEBUG) Console.Out.WriteLine("trying factory[" + (index - 1) + "] " + f.ToString());
                            object service = f.Create(key, this);
                            if (service != null)
                            {
                                result = new CacheEntry(currentDescriptor, service);
                                if (DEBUG) Console.Out.WriteLine(m_name + " factory supported: " + currentDescriptor + ", caching");
                                goto outer_break;
                            }
                            else
                            {
                                if (DEBUG) Console.Out.WriteLine("factory did not support: " + currentDescriptor);
                            }
                        }

                        // prepare to load the cache with all additional ids that
                        // will resolve to result, assuming we'll succeed.  We
                        // don't want to keep querying on an id that's going to
                        // fallback to the one that succeeded, we want to hit the
                        // cache the first time next goaround.
                        if (cacheDescriptorList == null)
                        {
                            cacheDescriptorList = new List<string>(5);
                        }
                        cacheDescriptorList.Add(currentDescriptor);

                    } while (key.Fallback());
                    outer_break: { }

                    if (result != null)
                    {
                        if (putInCache)
                        {
                            if (DEBUG) Console.Out.WriteLine("caching '" + result.actualDescriptor + "'");
                            cache[result.actualDescriptor] = result;
                            if (cacheDescriptorList != null)
                            {
                                foreach (string desc in cacheDescriptorList)
                                {
                                    if (DEBUG) Console.Out.WriteLine(m_name + " adding descriptor: '" + desc + "' for actual: '" + result.actualDescriptor + "'");

                                    cache[desc] = result;
                                }
                            }
                            // Atomic update.  We held the read lock all this time
                            // so we know our cache is consistent with the factory list.
                            // We might stomp over a cache that some other thread
                            // rebuilt, but that's the breaks.  They're both good.
                            this.cache = cache;
                        }

                        if (actualReturn != null)
                        {
                            // strip null prefix
                            if (result.actualDescriptor.IndexOf('/') == 0)
                            {
                                actualReturn[0] = result.actualDescriptor.Substring(1);
                            }
                            else
                            {
                                actualReturn[0] = result.actualDescriptor;
                            }
                        }

                        if (DEBUG) Console.Out.WriteLine("found in service: " + m_name);

                        return result.service;
                    }
                }
                finally
                {
                    factoryLock.ReleaseRead();
                }
            }

            if (DEBUG) Console.Out.WriteLine("not found in service: " + m_name);

            return HandleDefault(key, actualReturn);
        }
        private IDictionary<string, CacheEntry> cache;

        // Record the actual id for this service in the cache, so we can return it
        // even if we succeed later with a different id.
        private sealed class CacheEntry
        {
            internal readonly string actualDescriptor;
            internal readonly object service;
            internal CacheEntry(string actualDescriptor, object service)
            {
                this.actualDescriptor = actualDescriptor;
                this.service = service;
            }
        }

        /// <summary>
        /// Default handler for this service if no factory in the list
        /// handled the <paramref name="key"/>.
        /// </summary>
        protected virtual object HandleDefault(ICUServiceKey key, string[] actualIDReturn)
        {
            return null;
        }

        /// <summary>
        /// Convenience override for <see cref="GetVisibleIDs(string)"/> that passes null
        /// as the fallback, thus returning all visible IDs.
        /// </summary>
        public virtual ICollection<string> GetVisibleIDs() // ICU4N specific - changed return type from ISet to ICollection to avoid O(n)
        {
            return GetVisibleIDs(null);
        }

        /// <summary>
        /// Return a snapshot of the visible IDs for this service.  This
        /// set will not change as Factories are added or removed, but the
        /// supported ids will, so there is no guarantee that all and only
        /// the ids in the returned set are visible and supported by the
        /// service in subsequent calls.
        /// <para/>
        /// <paramref name="matchID"/> is passed to <see cref="CreateKey(string)"/> to create a key.  If the
        /// key is not null, it is used to filter out ids that don't have
        /// the key as a fallback.
        /// </summary>
        public virtual ICollection<string> GetVisibleIDs(string matchID) // ICU4N specific - changed return type from ISet to ICollection to avoid O(n)
        {
            ICollection<string> result = GetVisibleIDMap().Keys;

            ICUServiceKey fallbackKey = CreateKey(matchID);

            if (fallbackKey != null)
            {
                ISet<string> temp = new HashSet<string>(/*result.Count*/);
                foreach (string id in result)
                {
                    if (fallbackKey.IsFallbackOf(id))
                    {
                        temp.Add(id);
                    }
                }
                result = temp;
            }
            return result;
        }

        /// <summary>
        /// Return a map from visible ids to factories.
        /// </summary>
        private IDictionary<string, IServiceFactory> GetVisibleIDMap()
        {
            lock (this)
            { // or idcache-only lock?
                if (idcache == null)
                {
                    try
                    {
                        factoryLock.AcquireRead();
                        IDictionary<string, IServiceFactory> mutableMap = new Dictionary<string, IServiceFactory>();
                        for (int i = factories.Count - 1; i >= 0; i--)
                        {
                            IServiceFactory f = factories[i];
                            f.UpdateVisibleIDs(mutableMap);
                        }

                        this.idcache = mutableMap.ToUnmodifiableDictionary();
                    }
                    finally
                    {
                        factoryLock.ReleaseRead();
                    }
                }
            }
            return idcache;
        }
        private IDictionary<string, IServiceFactory> idcache;

        /// <summary>
        /// Convenience override for <see cref="GetDisplayName(string, ULocale)"/> that
        /// uses the current default locale.
        /// </summary>
        public virtual string GetDisplayName(string id)
        {
            return GetDisplayName(id, ULocale.GetDefault(Category.DISPLAY));
        }

        /// <summary>
        /// Given a visible <paramref name="id"/>, return the display name in the requested <paramref name="locale"/>.
        /// If there is no directly supported id corresponding to this id, return
        /// null.
        /// </summary>
        public virtual string GetDisplayName(string id, ULocale locale)
        {
            IDictionary<string, IServiceFactory> m = GetVisibleIDMap();
            IServiceFactory f = m.Get(id);
            if (f != null)
            {
                return f.GetDisplayName(id, locale);
            }

            ICUServiceKey key = CreateKey(id);
            while (key.Fallback())
            {
                f = m.Get(key.CurrentID);
                if (f != null)
                {
                    return f.GetDisplayName(id, locale);
                }
            }

            return null;
        }

        /// <summary>
        /// Convenience override of <see cref="GetDisplayNames(ULocale, IComparer{string}, string)"/> that
        /// uses the current default Locale as the locale, null as
        /// the comparer, and null for the matchID.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames()
        {
            ULocale locale = ULocale.GetDefault(Category.DISPLAY);
            return GetDisplayNames(locale, (IComparer<string>)null, null);
        }

        /// <summary>
        /// Convenience override of <see cref="GetDisplayNames(ULocale, IComparer{string}, string)"/> that
        /// uses null for the comparer, and null for the matchID.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames(ULocale locale)
        {
            return GetDisplayNames(locale, (IComparer<string>)null, null);
        }

        /// <summary>
        /// Convenience override of <see cref="GetDisplayNames(ULocale, IComparer{string}, string)"/> that
        /// uses null for the matchID, thus returning all display names.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames(ULocale locale, CompareInfo com)
        {
            return GetDisplayNames(locale, com.ToComparer(), null);
        }

        /// <summary>
        /// Convenience override of <see cref="GetDisplayNames(ULocale, IComparer{string}, string)"/> that
        /// uses null for the matchID, thus returning all display names.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames(ULocale locale, IComparer<string> com) // ICU4N TODO: API Add overloads for IComparer<StringBuilder> and IComparer<char[]> ?
        {
            return GetDisplayNames(locale, com, null);
        }

        /// <summary>
        /// Convenience override of <see cref="GetDisplayNames(ULocale, IComparer{string}, string)"/> that
        /// uses null for the comparator.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames(ULocale locale, string matchID)
        {
            return GetDisplayNames(locale, (IComparer<string>)null, matchID);
        }

        /// <summary>
        /// Return a snapshot of the mapping from display names to visible
        /// IDs for this service.  This set will not change as factories
        /// are added or removed, but the supported ids will, so there is
        /// no guarantee that all and only the ids in the returned map will
        /// be visible and supported by the service in subsequent calls,
        /// nor is there any guarantee that the current display names match
        /// those in the set.  The display names are sorted based on the
        /// comparer provided.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames(ULocale locale, CompareInfo com, string matchID)
        {
            return GetDisplayNames(locale, com.ToComparer(), matchID);
        }

        /// <summary>
        /// Return a snapshot of the mapping from display names to visible
        /// IDs for this service.  This set will not change as factories
        /// are added or removed, but the supported ids will, so there is
        /// no guarantee that all and only the ids in the returned map will
        /// be visible and supported by the service in subsequent calls,
        /// nor is there any guarantee that the current display names match
        /// those in the set.  The display names are sorted based on the
        /// comparer provided.
        /// </summary>
        public virtual SortedDictionary<string, string> GetDisplayNames(ULocale locale, IComparer<string> com, string matchID) // ICU4N TODO: API Add overloads for IComparer<StringBuilder> and IComparer<char[]> ?
        {
            SortedDictionary<string, string> dncache = null;
            LocaleRef reference = dnref;

            if (reference != null)
            {
                dncache = reference.Get(locale, com);
            }

            while (dncache == null)
            {
                lock (this)
                {
                    if (reference == dnref || dnref == null)
                    {
                        dncache = new SortedDictionary<string, string>(com); // sorted

                        IDictionary<string, IServiceFactory> m = GetVisibleIDMap();
                        using (var ei = m.GetEnumerator())
                        {
                            while (ei.MoveNext())
                            {
                                var e = ei.Current;
                                string id = e.Key;
                                IServiceFactory f = e.Value;
                                dncache[f.GetDisplayName(id, locale)] = id;
                            }
                        }

                        // ICU4N TODO: Need to make the cache unmodifiable, but stil keep the type a SortedDictionary
                        //dncache = dncache.ToUnmodifiableDictionary();
                        dnref = new LocaleRef(dncache, locale, com);
                    }
                    else
                    {
                        reference = dnref;
                        dncache = reference.Get(locale, com);
                    }
                }
            }

            ICUServiceKey matchKey = CreateKey(matchID);
            if (matchKey == null)
            {
                return dncache;
            }

            // ICU4N: Rather than copying and then removing the items (which isn't allowed with
            // .NET iterators), we reverse the logic and add the items only if they are fallback.
            SortedDictionary<string, string> result = new SortedDictionary<string, string>(((SortedDictionary<string, string>)dncache).Comparer);
            using (var iter = dncache.GetEnumerator())
            {
                while (iter.MoveNext())
                {
                    var e = iter.Current;
                    if (matchKey.IsFallbackOf(e.Value))
                    {
                        result.Add(e.Key, e.Value);
                    }
                }
            }
            return result;
        }

        // we define a class so we get atomic simultaneous access to the
        // locale, comparator, and corresponding map.
        private class LocaleRef
        {
            private readonly ULocale locale;
            private SortedDictionary<string, string> dnCache;
            private IComparer<string> com;

            internal LocaleRef(SortedDictionary<string, string> dnCache, ULocale locale, IComparer<string> com)
            {
                this.locale = locale;
                this.com = com;
                this.dnCache = dnCache;
            }


            internal virtual SortedDictionary<string, string> Get(ULocale loc, IComparer<string> comp)
            {
                SortedDictionary<string, string> m = dnCache;
                if (m != null &&
                    this.locale.Equals(loc) &&
                    (this.com == comp || (this.com != null && this.com.Equals(comp))))
                {

                    return m;
                }
                return null;
            }
        }
        private LocaleRef dnref;

        /// <summary>
        /// Return a snapshot of the currently registered factories.  There
        /// is no guarantee that the list will still match the current
        /// factory list of the service subsequent to this call.
        /// </summary>
        public IList<IServiceFactory> Factories()
        {
            try
            {
                factoryLock.AcquireRead();
                return new List<IServiceFactory>(factories);
            }
            finally
            {
                factoryLock.ReleaseRead();
            }
        }

        /// <summary>
        /// A convenience override of <see cref="RegisterObject(object, string, bool)"/>
        /// that defaults visible to true.
        /// </summary>
        public virtual IServiceFactory RegisterObject(object obj, string id)
        {
            return RegisterObject(obj, id, true);
        }

        /// <summary>
        /// Register an object with the provided <paramref name="id"/>.  The <paramref name="id"/> will be
        /// canonicalized.  The canonicalized ID will be returned by
        /// <see cref="GetVisibleIDs()"/> if visible is true.
        /// </summary>
        public virtual IServiceFactory RegisterObject(object obj, string id, bool visible)
        {
            string canonicalID = CreateKey(id).CanonicalID;
            return RegisterFactory(new ICUSimpleFactory(obj, canonicalID, visible));
        }

        /// <summary>
        /// Register a <see cref="IServiceFactory"/>.  Returns the factory if the service accepts
        /// the factory, otherwise returns null.  The default implementation
        /// accepts all factories.
        /// </summary>
        public IServiceFactory RegisterFactory(IServiceFactory factory)
        {
            if (factory == null)
            {
                throw new ArgumentNullException(nameof(factory));
            }
            try
            {
                factoryLock.AcquireWrite();
                factories.Insert(0, factory);
                ClearCaches();
            }
            finally
            {
                factoryLock.ReleaseWrite();
            }
            NotifyChanged();
            return factory;
        }

        /// <summary>
        /// Unregister a <see cref="IServiceFactory"/>.  The first matching registered factory will
        /// be removed from the list.  Returns true if a matching factory was
        /// removed.
        /// </summary>
        public bool UnregisterFactory(IServiceFactory factory)
        {
            if (factory == null)
            {
                throw new ArgumentNullException(nameof(factory));
            }

            bool result = false;
            try
            {
                factoryLock.AcquireWrite();
                if (factories.Remove(factory))
                {
                    result = true;
                    ClearCaches();
                }
            }
            finally
            {
                factoryLock.ReleaseWrite();
            }

            if (result)
            {
                NotifyChanged();
            }
            return result;
        }

        /// <summary>
        /// Reset the service to the default factories.  The factory
        /// lock is acquired and then <see cref="ReInitializeFactories()"/> is called.
        /// </summary>
        public void Reset()
        {
            try
            {
                factoryLock.AcquireWrite();
                ReInitializeFactories();
                ClearCaches();
            }
            finally
            {
                factoryLock.ReleaseWrite();
            }
            NotifyChanged();
        }

        /// <summary>
        /// Reinitialize the factory list to its default state.  By default
        /// this clears the list.  Subclasses can override to provide other
        /// default initialization of the factory list.  Subclasses must
        /// not call this method directly, as it must only be called while
        /// holding write access to the factory list.
        /// </summary>
        protected virtual void ReInitializeFactories()
        {
            factories.Clear();
        }

        /// <summary>
        /// Return true if the service is in its default state.  The default
        /// implementation returns true if there are no factories registered.
        /// </summary>
        public virtual bool IsDefault
        {
            get { return factories.Count == defaultSize; }
        }

        /// <summary>
        /// Set the default size to the current number of registered factories.
        /// Used by subclasses to customize the behavior of <see cref="IsDefault"/>.
        /// </summary>
        protected virtual void MarkDefault()
        {
            defaultSize = factories.Count;
        }

        /// <summary>
        /// Create a key from an id.  This creates a <see cref="ICUServiceKey"/> instance.
        /// Subclasses can override to define more useful keys appropriate
        /// to the factories they accept.  If id is null, returns null.
        /// </summary>
        public virtual ICUServiceKey CreateKey(string id)
        {
            return id == null ? null : new ICUServiceKey(id);
        }

        /// <summary>
        /// Clear caches maintained by this service.  Subclasses can
        /// override if they implement additional that need to be cleared
        /// when the service changes. Subclasses should generally not call
        /// this method directly, as it must only be called while
        /// synchronized on this.
        /// </summary>
        protected virtual void ClearCaches()
        {
            // we don't synchronize on these because methods that use them
            // copy before use, and check for changes if they modify the
            // caches.
            cache = null;
            idcache = null;
            dnref = null;
        }

        /// <summary>
        /// Clears only the service cache.
        /// This can be called by subclasses when a change affects the service
        /// cache but not the id caches, e.g., when the default locale changes
        /// the resolution of ids changes, but not the visible ids themselves.
        /// </summary>
        protected virtual void ClearServiceCache()
        {
            cache = null;
        }

        // ICU4N: De-nested IServiceListener

        

        /// <summary>
        /// Return true if the listener is accepted; by default this
        /// requires a <see cref="IServiceListener"/>.  Subclasses can override to accept
        /// different listeners.
        /// </summary>
        protected override bool AcceptsListener(IEventListener l)
        {
            return l is IServiceListener;
        }

        /// <summary>
        /// Notify the listener, which by default is a <see cref="IServiceListener"/>.
        /// Subclasses can override to use a different listener.
        /// </summary>
        /// <param name="l"></param>
        protected override void NotifyListener(IEventListener l)
        {
            ((IServiceListener)l).ServiceChanged(this);
        }

        /// <summary>
        /// When the statistics for this service is already enabled,
        /// return the log and resets he statistics.
        /// When the statistics is not enabled, this method enable
        /// the statistics. Used for debugging purposes.
        /// </summary>
        public virtual string Stats()
        {
            ICUReaderWriterLockStats stats = factoryLock.ResetStats();
            if (stats != null)
            {
                return stats.ToString();
            }
            return "no stats";
        }

        /// <summary>
        /// Return the name of this service. This will be the empty string if none was assigned.
        /// </summary>
        public virtual string Name
        {
            get { return m_name; }
        }

        /// <summary>
        /// Returns the result of <c>base.ToString()</c>, appending the name in curly braces.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            // ICU4N TODO: Fix "base" implementation so it returns
            // the same string as ICUNotifier in icu4j
            return base.ToString() + "{" + m_name + "}";
        }
    }


    /// <summary>
    /// Keys are used to communicate with factories to generate an
    /// instance of the service.  Keys define how ids are
    /// canonicalized, provide both a current id and a current
    /// descriptor to use in querying the cache and factories, and
    /// determine the fallback strategy.
    /// </summary>
    /// <remarks>
    /// Keys provide both a <see cref="GetCurrentDescriptor"/> and a <see cref="CurrentID"/>.
    /// The descriptor contains an optional prefix, followed by '/'
    /// and the <see cref="CurrentID"/>.  Factories that handle complex keys,
    /// for example number format factories that generate multiple
    /// kinds of formatters for the same locale, use the descriptor
    /// to provide a fully unique identifier for the service object,
    /// while using the <see cref="CurrentID"/> (in this case, the locale string),
    /// as the visible IDs that can be localized.
    /// <para/>
    /// The default implementation of <see cref="ICUServiceKey"/> has no fallbacks and
    /// has no custom descriptors.
    /// </remarks>
    public class ICUServiceKey
    {
        private readonly string id;

        /// <summary>
        /// Construct a key from an <paramref name="id"/>.
        /// </summary>
        public ICUServiceKey(string id)
        {
            this.id = id;
        }

        /// <summary>
        /// Return the original ID used to construct this key.
        /// </summary>
        public string ID
        {
            get { return id; }
        }

        /// <summary>
        /// Return the canonical version of the original ID.  This implementation
        /// returns the original ID unchanged.
        /// </summary>
        public virtual string CanonicalID
        {
            get { return id; }
        }

        /// <summary>
        /// Return the (canonical) current ID.  This implementation
        /// returns the canonical ID.
        /// </summary>
        public virtual string CurrentID
        {
            get { return CanonicalID; }
        }

        /// <summary>
        /// Return the current descriptor.  This implementation returns
        /// the current ID.  The current descriptor is used to fully
        /// identify an instance of the service in the cache.  A
        /// factory may handle all descriptors for an ID, or just a
        /// particular descriptor.  The factory can either parse the
        /// descriptor or use custom API on the key in order to
        /// instantiate the service.
        /// </summary>
        public virtual string GetCurrentDescriptor() // ICU4N specific - Added "Get"
        {
            return "/" + CurrentID;
        }

        /// <summary>
        /// If the key has a fallback, modify the key and return true,
        /// otherwise return false.  The current ID will change if there
        /// is a fallback.  No <see cref="CurrentID"/>s should be repeated, and fallback
        /// must eventually return false.  This implmentation has no fallbacks
        /// and always returns false.
        /// </summary>
        public virtual bool Fallback()
        {
            return false;
        }

        /// <summary>
        /// If a key created from <paramref name="idToCheck"/> would eventually fallback to match the
        /// <see cref="CanonicalID"/> of this key, return true.
        /// </summary>
        public virtual bool IsFallbackOf(string idToCheck)
        {
            return CanonicalID.Equals(idToCheck);
        }
    }

    /// <summary>
    /// Factories generate the service objects maintained by the
    /// service.  A factory generates a service object from a key,
    /// updates id->factory mappings, and returns the display name for
    /// a supported id.
    /// </summary>
    public interface IServiceFactory
    {
        /// <summary>
        /// Create a service object from the <paramref name="key"/>, if this factory
        /// supports the <paramref name="key"/>.  Otherwise, return null.
        /// </summary>
        /// <remarks>
        /// If the factory supports the key, then it can call
        /// the service's <see cref="ICUService.GetKey(ICUServiceKey, string[], IServiceFactory)"/> method
        /// passing itself as the factory to get the object that
        /// the service would have created prior to the factory's
        /// registration with the service.  This can change the
        /// key, so any information required from the key should
        /// be extracted before making such a callback.
        /// </remarks>
        object Create(ICUServiceKey key, ICUService service);

        /// <summary>
        /// Update the result IDs (not descriptors) to reflect the IDs
        /// this factory handles.  This function and <see cref="GetDisplayName(string, ULocale)"/> are
        /// used to support <see cref="ICUService.GetDisplayNames(ULocale, IComparer{string}, string)"/>.  Basically, the
        /// factory has to determine which IDs it will permit to be
        /// available, and of those, which it will provide localized
        /// display names for.  In most cases this reflects the IDs that
        /// the factory directly supports.
        /// </summary>
        void UpdateVisibleIDs(IDictionary<string, IServiceFactory> result);

        /// <summary>
        /// Return the display name for this id in the provided locale.
        /// This is an localized id, not a descriptor.  If the id is
        /// not visible or not defined by the factory, return null.
        /// If locale is null, return id unchanged.
        /// </summary>
        string GetDisplayName(string id, ULocale locale);
    }

    /// <summary>
    /// A default implementation of factory.  This provides default
    /// implementations for subclasses, and implements a singleton
    /// factory that matches a single id  and returns a single
    /// (possibly deferred-initialized) instance.  This implements
    /// <see cref="UpdateVisibleIDs(IDictionary{string, IServiceFactory})"/> to add a mapping from its ID to itself
    /// if visible is true, or to remove any existing mapping
    /// for its ID if visible is false.
    /// </summary>
    public class ICUSimpleFactory : IServiceFactory
    {
        protected object instance;
        protected string id;
        protected bool visible;

        /// <summary>
        /// Convenience constructor that calls <see cref="ICUSimpleFactory.ICUSimpleFactory(object, string, bool)"/>
        /// with visible true.
        /// </summary>
        public ICUSimpleFactory(object instance, string id)
            : this(instance, id, true)
        {
        }

        /// <summary>
        /// Construct a simple factory that maps a single id to a single
        /// service instance.  If visible is true, the id will be visible.
        /// Neither the instance nor the id can be null.
        /// </summary>
        public ICUSimpleFactory(object instance, string id, bool visible)
        {
            if (instance == null || id == null)
            {
                throw new ArgumentException("Instance or id is null");
            }
            this.instance = instance;
            this.id = id;
            this.visible = visible;
        }

        /// <summary>
        /// Return the service instance if the factory's id is equal to
        /// the <paramref name="key"/>'s <see cref="ICUServiceKey.CurrentID"/>.  
        /// <paramref name="service"/> is ignored.
        /// </summary>
        public virtual object Create(ICUServiceKey key, ICUService service)
        {
            if (id.Equals(key.CurrentID))
            {
                return instance;
            }
            return null;
        }

        /// <summary>
        /// If visible, adds a mapping from id -> this to the <paramref name="result"/>,
        /// otherwise removes id from <paramref name="result"/>.
        /// </summary>
        public virtual void UpdateVisibleIDs(IDictionary<string, IServiceFactory> result)
        {
            if (visible)
            {
                result[id] = this;
            }
            else
            {
                result.Remove(id);
            }
        }

        /// <summary>
        /// If <see cref="id"/> equals <paramref name="identifier"/>, 
        /// returns <paramref name="identifier"/> regardless of locale,
        /// otherwise returns null.  (This default implementation has
        /// no localized id information.)
        /// </summary>
        public virtual string GetDisplayName(string identifier, ULocale locale)
        {
            return (visible && id.Equals(identifier)) ? identifier : null;
        }

        /// <summary>
        /// For debugging.
        /// </summary>
        public override string ToString()
        {
            StringBuilder buf = new StringBuilder(base.ToString());
            buf.Append(", id: ");
            buf.Append(id);
            buf.Append(", visible: ");
            buf.Append(visible);
            return buf.ToString();
        }
    }

    /// <summary>
    /// <see cref="IServiceListener"/> is the listener that <see cref="ICUService"/> provides by default.
    /// <see cref="ICUService"/> will notifiy this listener when factories are added to
    /// or removed from the service.  Subclasses can provide
    /// different listener interfaces that extend <see cref="IEventListener"/>, and modify
    /// <see cref="ICUService.AcceptsListener(IEventListener)"/> and <see cref="ICUService.NotifyListener(IEventListener)"/> as appropriate.
    /// </summary>
    public interface IServiceListener : IEventListener
    {
        void ServiceChanged(ICUService service);
    }
}
