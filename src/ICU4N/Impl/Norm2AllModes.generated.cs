//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Text;
using ICU4N.Util;
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    // Normalizer2 implementation for the old UNORM_NONE.
    public sealed partial class NoopNormalizer2
    {

        public override StringBuilder Normalize(string src, StringBuilder dest)
        {
            dest.Length = 0;
            return dest.Append(src);
        }

        public override StringBuilder Normalize(StringBuilder src, StringBuilder dest)
        {
            if (dest == src)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            dest.Length = 0;
            return dest.Append(src);
        }

        public override StringBuilder Normalize(char[] src, StringBuilder dest)
        {
            dest.Length = 0;
            return dest.Append(src);
        }

        public override StringBuilder Normalize(ICharSequence src, StringBuilder dest)
        {
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            dest.Length = 0;
            return dest.Append(src);
        }

        public override IAppendable Normalize(string src, IAppendable dest)
        {
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }

        public override IAppendable Normalize(StringBuilder src, IAppendable dest)
        {
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }

        public override IAppendable Normalize(char[] src, IAppendable dest)
        {
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }

        public override IAppendable Normalize(ICharSequence src, IAppendable dest)
        {
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, string second)
        {
            return first.Append(second.ToString());
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, StringBuilder second)
        {
            if (first == second)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(second.ToString());
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, char[] second)
        {
            return first.Append(second.ToString());
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, ICharSequence second)
        {
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(second.ToString());
        }

        public override StringBuilder Append(StringBuilder first, string second)
        {
            return first.Append(second);
        }

        public override StringBuilder Append(StringBuilder first, StringBuilder second)
        {
            if (first == second)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(second);
        }

        public override StringBuilder Append(StringBuilder first, char[] second)
        {
            return first.Append(second);
        }

        public override StringBuilder Append(StringBuilder first, ICharSequence second)
        {
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(second);
        }

        public override bool IsNormalized(string s) { return true; }

        public override bool IsNormalized(StringBuilder s) { return true; }

        public override bool IsNormalized(char[] s) { return true; }

        public override bool IsNormalized(ICharSequence s) { return true; }

        public override QuickCheckResult QuickCheck(string s) { return QuickCheckResult.Yes; }

        public override QuickCheckResult QuickCheck(StringBuilder s) { return QuickCheckResult.Yes; }

        public override QuickCheckResult QuickCheck(char[] s) { return QuickCheckResult.Yes; }

        public override QuickCheckResult QuickCheck(ICharSequence s) { return QuickCheckResult.Yes; }

        public override int SpanQuickCheckYes(string s) { return s.Length; }

        public override int SpanQuickCheckYes(StringBuilder s) { return s.Length; }

        public override int SpanQuickCheckYes(char[] s) { return s.Length; }

        public override int SpanQuickCheckYes(ICharSequence s) { return s.Length; }

    }

    public abstract partial class Normalizer2WithImpl
    {

        public override StringBuilder Normalize(string src, StringBuilder dest)
        {
            dest.Length = 0;
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
            return dest;
        }

        public override StringBuilder Normalize(StringBuilder src, StringBuilder dest)
        {
            if (dest == src)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            dest.Length = 0;
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
            return dest;
        }

        public override StringBuilder Normalize(char[] src, StringBuilder dest)
        {
            dest.Length = 0;
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
            return dest;
        }

        public override StringBuilder Normalize(ICharSequence src, StringBuilder dest)
        {
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            dest.Length = 0;
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
            return dest;
        }

        public override IAppendable Normalize(string src, IAppendable dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }

        public override IAppendable Normalize(StringBuilder src, IAppendable dest)
        {
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }

        public override IAppendable Normalize(char[] src, IAppendable dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }

        public override IAppendable Normalize(ICharSequence src, IAppendable dest)
        {
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }

        protected abstract void Normalize(string src, ReorderingBuffer buffer);

        protected abstract void Normalize(StringBuilder src, ReorderingBuffer buffer);

        protected abstract void Normalize(char[] src, ReorderingBuffer buffer);

        public abstract void Normalize(ICharSequence src, ReorderingBuffer buffer);

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, string second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, StringBuilder second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, char[] second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, ICharSequence second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }

        public override StringBuilder Append(StringBuilder first, string second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }

        public override StringBuilder Append(StringBuilder first, StringBuilder second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }

        public override StringBuilder Append(StringBuilder first, char[] second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }

        public override StringBuilder Append(StringBuilder first, ICharSequence second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }

        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, string second, bool doNormalize)
        {
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }

        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, StringBuilder second, bool doNormalize)
        {
            if (first == second)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }

        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, char[] second, bool doNormalize)
        {
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }

        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, ICharSequence second, bool doNormalize)
        {
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }

        protected abstract void NormalizeAndAppend(
            string src, bool doNormalize, ReorderingBuffer buffer);

        protected abstract void NormalizeAndAppend(
            StringBuilder src, bool doNormalize, ReorderingBuffer buffer);

        protected abstract void NormalizeAndAppend(
            char[] src, bool doNormalize, ReorderingBuffer buffer);

        public abstract void NormalizeAndAppend(
            ICharSequence src, bool doNormalize, ReorderingBuffer buffer);

        public override bool IsNormalized(string s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }

        public override bool IsNormalized(StringBuilder s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }

        public override bool IsNormalized(char[] s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }

        public override bool IsNormalized(ICharSequence s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }

        public override QuickCheckResult QuickCheck(string s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }

        public override QuickCheckResult QuickCheck(StringBuilder s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }

        public override QuickCheckResult QuickCheck(char[] s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }

        public override QuickCheckResult QuickCheck(ICharSequence s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }
    }

    public sealed partial class DecomposeNormalizer2
    {

        protected override void Normalize(string src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer);
        }

        protected override void Normalize(StringBuilder src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer);
        }

        protected override void Normalize(char[] src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer);
        }

        public override void Normalize(ICharSequence src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer);
        }

        protected override void NormalizeAndAppend(string src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }

        protected override void NormalizeAndAppend(StringBuilder src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }

        protected override void NormalizeAndAppend(char[] src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }

        public override void NormalizeAndAppend(ICharSequence src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }

        public override int SpanQuickCheckYes(string s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }

        public override int SpanQuickCheckYes(StringBuilder s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }

        public override int SpanQuickCheckYes(char[] s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }

        public override int SpanQuickCheckYes(ICharSequence s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }
    }

    public sealed partial class ComposeNormalizer2
    {

        protected override void Normalize(string src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer);
        }

        protected override void Normalize(StringBuilder src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer);
        }

        protected override void Normalize(char[] src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer);
        }

        public override void Normalize(ICharSequence src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer);
        }

        protected override void NormalizeAndAppend(
            string src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }

        protected override void NormalizeAndAppend(
            StringBuilder src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }

        protected override void NormalizeAndAppend(
            char[] src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }

        public override void NormalizeAndAppend(
            ICharSequence src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }

        public override bool IsNormalized(string s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5));
        }

        public override bool IsNormalized(StringBuilder s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5));
        }

        public override bool IsNormalized(char[] s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5));
        }

        public override bool IsNormalized(ICharSequence s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5));
        }

        public override QuickCheckResult QuickCheck(string s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }

        public override QuickCheckResult QuickCheck(StringBuilder s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }

        public override QuickCheckResult QuickCheck(char[] s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }

        public override QuickCheckResult QuickCheck(ICharSequence s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }

        public override int SpanQuickCheckYes(string s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1);
        }

        public override int SpanQuickCheckYes(StringBuilder s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1);
        }

        public override int SpanQuickCheckYes(char[] s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1);
        }

        public override int SpanQuickCheckYes(ICharSequence s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1);
        }

    }

    public sealed partial class FCDNormalizer2
    {

        protected override void Normalize(string src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer);
        }

        protected override void Normalize(StringBuilder src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer);
        }

        protected override void Normalize(char[] src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer);
        }

        public override void Normalize(ICharSequence src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer);
        }

        protected override void NormalizeAndAppend(
            string src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }

        protected override void NormalizeAndAppend(
            StringBuilder src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }

        protected override void NormalizeAndAppend(
            char[] src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }

        public override void NormalizeAndAppend(
            ICharSequence src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }

        public override int SpanQuickCheckYes(string s)
        {
            return Impl.MakeFCDSpanQuickCheckYes(s, 0, s.Length);
        }

        public override int SpanQuickCheckYes(StringBuilder s)
        {
            return Impl.MakeFCDSpanQuickCheckYes(s, 0, s.Length);
        }

        public override int SpanQuickCheckYes(char[] s)
        {
            return Impl.MakeFCDSpanQuickCheckYes(s, 0, s.Length);
        }

        public override int SpanQuickCheckYes(ICharSequence s)
        {
            return Impl.MakeFCDSpanQuickCheckYes(s, 0, s.Length);
        }

    }
}