//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Support.Text;
using ICU4N.Text;
using ICU4N.Util;
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    // Normalizer2 implementation for the old UNORM_NONE.
    public sealed partial class NoopNormalizer2
    {
    
        public override StringBuilder Normalize(string src, StringBuilder dest)
        {
            dest.Length = 0;
            return dest.Append(src);
        }

    
        public override T Normalize<T>(string src, T dest)
        {
            // ICU4N: Removed unnecessary try/catch for IOException
            return (T)dest.Append(src);
        }

        
        public override StringBuilder Normalize(StringBuilder src, StringBuilder dest)
        {
            if (dest == src)
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            dest.Length = 0;
            return dest.Append(src);
        }

    
        public override T Normalize<T>(StringBuilder src, T dest)
        {
            if (dest == src)
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            // ICU4N: Removed unnecessary try/catch for IOException
            return (T)dest.Append(src);
        }

        
        public override StringBuilder Normalize(char[] src, StringBuilder dest)
        {
            dest.Length = 0;
            return dest.Append(src);
        }

    
        public override T Normalize<T>(char[] src, T dest)
        {
            // ICU4N: Removed unnecessary try/catch for IOException
            return (T)dest.Append(src);
        }

        
        public override StringBuilder Normalize(ICharSequence src, StringBuilder dest)
        {
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            dest.Length = 0;
            return dest.Append(src);
        }

    
        public override T Normalize<T>(ICharSequence src, T dest)
        {
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            // ICU4N: Removed unnecessary try/catch for IOException
            return (T)dest.Append(src);
        }

        #if FEATURE_SPAN
        public override StringBuilder Normalize(ReadOnlySpan<char> src, StringBuilder dest)
        {
            dest.Length = 0;
            return dest.Append(src);
        }
#endif // FEATURE_SPAN
    #if FEATURE_SPAN
        public override T Normalize<T>(ReadOnlySpan<char> src, T dest)
        {
            // ICU4N: Removed unnecessary try/catch for IOException
            return (T)dest.Append(src);
        }
#endif // FEATURE_SPAN
    
        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, string second)
        {
            return first.Append(second);
        }


        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, StringBuilder second)
        {
            if (first == second)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(charSequence: second);
        }


        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, char[] second)
        {
            return first.Append(second);
        }


        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, ICharSequence second)
        {
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(charSequence: second);
        }

#if FEATURE_SPAN
        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, ReadOnlySpan<char> second)
        {
            return first.Append(second);
        }
#endif // FEATURE_SPAN

        public override StringBuilder Append(StringBuilder first, string second)
        {
            return first.Append(second);
        }


        public override StringBuilder Append(StringBuilder first, StringBuilder second)
        {
            if (first == second)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(charSequence: second);
        }


        public override StringBuilder Append(StringBuilder first, char[] second)
        {
            return first.Append(second);
        }


        public override StringBuilder Append(StringBuilder first, ICharSequence second)
        {
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(charSequence: second);
        }

#if FEATURE_SPAN
        public override StringBuilder Append(StringBuilder first, ReadOnlySpan<char> second)
        {
            return first.Append(second);
        }
#endif // FEATURE_SPAN

        public override bool IsNormalized(string s) { return true; }


        public override bool IsNormalized(StringBuilder s) { return true; }


        public override bool IsNormalized(char[] s) { return true; }


        public override bool IsNormalized(ICharSequence s) { return true; }

#if FEATURE_SPAN
        public override bool IsNormalized(ReadOnlySpan<char> s) { return true; }
#endif // FEATURE_SPAN

        public override QuickCheckResult QuickCheck(string s) { return QuickCheckResult.Yes; }


        public override QuickCheckResult QuickCheck(StringBuilder s) { return QuickCheckResult.Yes; }


        public override QuickCheckResult QuickCheck(char[] s) { return QuickCheckResult.Yes; }


        public override QuickCheckResult QuickCheck(ICharSequence s) { return QuickCheckResult.Yes; }

#if FEATURE_SPAN
        public override QuickCheckResult QuickCheck(ReadOnlySpan<char> s) { return QuickCheckResult.Yes; }
#endif // FEATURE_SPAN

        public override int SpanQuickCheckYes(string s) { return s.Length; }


        public override int SpanQuickCheckYes(StringBuilder s) { return s.Length; }


        public override int SpanQuickCheckYes(char[] s) { return s.Length; }


        public override int SpanQuickCheckYes(ICharSequence s) { return s.Length; }

#if FEATURE_SPAN
        public override int SpanQuickCheckYes(ReadOnlySpan<char> s) { return s.Length; }
#endif // FEATURE_SPAN

    }

    public abstract partial class Normalizer2WithImpl
    {
    
        public override StringBuilder Normalize(string src, StringBuilder dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);

            return dest;
        }

    
        public override T Normalize<T>(string src, T dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();

            return dest;
        }

        
        public override StringBuilder Normalize(StringBuilder src, StringBuilder dest)
        {
            if (src == dest)
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);

            return dest;
        }

    
        public override T Normalize<T>(StringBuilder src, T dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();

            return dest;
        }

        
        public override StringBuilder Normalize(char[] src, StringBuilder dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);

            return dest;
        }

    
        public override T Normalize<T>(char[] src, T dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();

            return dest;
        }

        
        public override StringBuilder Normalize(ICharSequence src, StringBuilder dest)
        {
            if (src is StringBuilderCharSequence stringBuilderCharSequence && stringBuilderCharSequence.Value == dest)
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);

            return dest;
        }

    
        public override T Normalize<T>(ICharSequence src, T dest)
        {
            if (src is StringBuilderCharSequence stringBuilderCharSequence && ReferenceEquals(stringBuilderCharSequence.Value, dest))
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();

            return dest;
        }

        #if FEATURE_SPAN
        public override StringBuilder Normalize(ReadOnlySpan<char> src, StringBuilder dest)
        {
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Length = 0;
                dest.Append(buffer.AsSpan());
            }
            finally
            {
                buffer.Dispose();
            }
            return dest;
        }
#endif // FEATURE_SPAN
    #if FEATURE_SPAN
        public override T Normalize<T>(ReadOnlySpan<char> src, T dest)
        {
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Append(buffer.AsSpan());
                buffer.Flush();
            }
            finally
            {
                buffer.Dispose();
            }
            return dest;
        }
#endif // FEATURE_SPAN
    
        public override T Normalize<T>(string src, T dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }


        public override T Normalize<T>(StringBuilder src, T dest)
        {
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }


        public override T Normalize<T>(char[] src, T dest)
        {
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }


        public override T Normalize<T>(ICharSequence src, T dest)
        {
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }

#if FEATURE_SPAN
        public override T Normalize<T>(ReadOnlySpan<char> src, T dest)
        {
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Append(buffer.AsSpan());
                buffer.Flush();
            }
            finally
            {
                buffer.Dispose();
            }
            return dest;
        }
#endif // FEATURE_SPAN

        protected abstract void Normalize(string src, ReorderingBuffer buffer);


        protected abstract void Normalize(StringBuilder src, ReorderingBuffer buffer);


        protected abstract void Normalize(char[] src, ReorderingBuffer buffer);


        protected abstract void Normalize(ICharSequence src, ReorderingBuffer buffer);

#if FEATURE_SPAN
        protected abstract void Normalize(ReadOnlySpan<char> src, ref ValueReorderingBuffer buffer);
#endif // FEATURE_SPAN

        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, string second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }


        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, StringBuilder second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }


        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, char[] second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }


        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, ICharSequence second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }

#if FEATURE_SPAN
        public override StringBuilder NormalizeSecondAndAppend(StringBuilder first, ReadOnlySpan<char> second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }
#endif // FEATURE_SPAN

        public override StringBuilder Append(StringBuilder first, string second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }


        public override StringBuilder Append(StringBuilder first, StringBuilder second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }


        public override StringBuilder Append(StringBuilder first, char[] second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }


        public override StringBuilder Append(StringBuilder first, ICharSequence second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }

#if FEATURE_SPAN
        public override StringBuilder Append(StringBuilder first, ReadOnlySpan<char> second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }
#endif // FEATURE_SPAN

        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, string second, bool doNormalize)
        {
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }


        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, StringBuilder second, bool doNormalize)
        {
            if (first == second)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }


        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, char[] second, bool doNormalize)
        {
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }


        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, ICharSequence second, bool doNormalize)
        {
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }

#if FEATURE_SPAN
        public virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, ReadOnlySpan<char> second, bool doNormalize)
        {
            int length = first.Length + second.Length;
            var sb = length <= CharStackBufferSize
                ? new ValueStringBuilder(stackalloc char[CharStackBufferSize])
                : new ValueStringBuilder(length);
            try
            {
                sb.Append(first);
                var buffer = new ValueReorderingBuffer(Impl, ref sb, length);
                NormalizeAndAppend(second, doNormalize, ref buffer);
                first.Length = 0;
                first.Append(buffer.AsSpan());
            }
            finally
            {
                sb.Dispose();
            }
            return first;
        }
#endif // FEATURE_SPAN

        protected abstract void NormalizeAndAppend(
            string src, bool doNormalize, ReorderingBuffer buffer);


        protected abstract void NormalizeAndAppend(
            StringBuilder src, bool doNormalize, ReorderingBuffer buffer);


        protected abstract void NormalizeAndAppend(
            char[] src, bool doNormalize, ReorderingBuffer buffer);


        protected abstract void NormalizeAndAppend(
            ICharSequence src, bool doNormalize, ReorderingBuffer buffer);

#if FEATURE_SPAN
        protected abstract void NormalizeAndAppend(
            ReadOnlySpan<char> src, bool doNormalize, ref ValueReorderingBuffer buffer);
#endif // FEATURE_SPAN

        public override bool IsNormalized(string s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }


        public override bool IsNormalized(StringBuilder s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }


        public override bool IsNormalized(char[] s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }


        public override bool IsNormalized(ICharSequence s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }

#if FEATURE_SPAN
        public override bool IsNormalized(ReadOnlySpan<char> s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }
#endif // FEATURE_SPAN

        public override QuickCheckResult QuickCheck(string s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }


        public override QuickCheckResult QuickCheck(StringBuilder s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }


        public override QuickCheckResult QuickCheck(char[] s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }


        public override QuickCheckResult QuickCheck(ICharSequence s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }

#if FEATURE_SPAN
        public override QuickCheckResult QuickCheck(ReadOnlySpan<char> s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }
#endif // FEATURE_SPAN
    }

    public sealed partial class DecomposeNormalizer2
    {

        protected override void Normalize(string src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(StringBuilder src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(char[] src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(ICharSequence src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }

#if FEATURE_SPAN
        protected override void Normalize(ReadOnlySpan<char> src, ref ValueReorderingBuffer buffer)
        {
            Impl.Decompose(src, ref buffer);
        }
#endif // FEATURE_SPAN

        protected override void NormalizeAndAppend(string src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }


        protected override void NormalizeAndAppend(StringBuilder src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }


        protected override void NormalizeAndAppend(char[] src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }


        protected override void NormalizeAndAppend(ICharSequence src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }

#if FEATURE_SPAN
        protected override void NormalizeAndAppend(ReadOnlySpan<char> src, bool doNormalize, ref ValueReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, ref buffer);
        }
#endif // FEATURE_SPAN

        public override int SpanQuickCheckYes(string s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }


        public override int SpanQuickCheckYes(StringBuilder s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }


        public override int SpanQuickCheckYes(char[] s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }


        public override int SpanQuickCheckYes(ICharSequence s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }

#if FEATURE_SPAN
        public override int SpanQuickCheckYes(ReadOnlySpan<char> s)
        {
            return Impl.DecomposeQuickCheck(s); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }
#endif // FEATURE_SPAN
    }

    public sealed partial class ComposeNormalizer2
    {

        protected override void Normalize(string src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(StringBuilder src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(char[] src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(ICharSequence src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer); // ICU4N: Checked 3rd parameter
        }

#if FEATURE_SPAN
        protected override void Normalize(ReadOnlySpan<char> src, ref ValueReorderingBuffer buffer)
        {
            Impl.Compose(src, onlyContiguous, true, ref buffer);
        }
#endif // FEATURE_SPAN

        protected override void NormalizeAndAppend(
            string src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }


        protected override void NormalizeAndAppend(
            StringBuilder src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }


        protected override void NormalizeAndAppend(
            char[] src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }


        protected override void NormalizeAndAppend(
            ICharSequence src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }

#if FEATURE_SPAN
        protected override void NormalizeAndAppend(
            ReadOnlySpan<char> src, bool doNormalize, ref ValueReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, ref buffer);
        }
#endif // FEATURE_SPAN

        public override bool IsNormalized(string s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5)); // ICU4N: Checked 3rd parameter
        }


        public override bool IsNormalized(StringBuilder s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5)); // ICU4N: Checked 3rd parameter
        }


        public override bool IsNormalized(char[] s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5)); // ICU4N: Checked 3rd parameter
        }


        public override bool IsNormalized(ICharSequence s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5)); // ICU4N: Checked 3rd parameter
        }

#if FEATURE_SPAN
        public override bool IsNormalized(ReadOnlySpan<char> s)
        {
            // 5: small destCapacity for substring normalization
            var buffer = new ValueReorderingBuffer(Impl, stackalloc char[5]);
            try
            {
                return Impl.Compose(s, onlyContiguous, false, ref buffer);
            }
            finally
            {
                buffer.Dispose();
            }
        }
#endif // FEATURE_SPAN

        public override QuickCheckResult QuickCheck(string s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }


        public override QuickCheckResult QuickCheck(StringBuilder s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }


        public override QuickCheckResult QuickCheck(char[] s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }


        public override QuickCheckResult QuickCheck(ICharSequence s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }

#if FEATURE_SPAN
        public override QuickCheckResult QuickCheck(ReadOnlySpan<char> s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }
#endif // FEATURE_SPAN

        public override int SpanQuickCheckYes(string s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }


        public override int SpanQuickCheckYes(StringBuilder s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }


        public override int SpanQuickCheckYes(char[] s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }


        public override int SpanQuickCheckYes(ICharSequence s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }

#if FEATURE_SPAN
        public override int SpanQuickCheckYes(ReadOnlySpan<char> s)
        {
            return Impl.ComposeQuickCheck(s, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }
#endif // FEATURE_SPAN

    }

    public sealed partial class FCDNormalizer2
    {

        protected override void Normalize(string src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(StringBuilder src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(char[] src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }


        protected override void Normalize(ICharSequence src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
        }

#if FEATURE_SPAN
        protected override void Normalize(ReadOnlySpan<char> src, ref ValueReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, ref buffer);
        }
#endif // FEATURE_SPAN

        protected override void NormalizeAndAppend(
            string src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }


        protected override void NormalizeAndAppend(
            StringBuilder src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }


        protected override void NormalizeAndAppend(
            char[] src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }


        protected override void NormalizeAndAppend(
            ICharSequence src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }

#if FEATURE_SPAN
        protected override void NormalizeAndAppend(
            ReadOnlySpan<char> src, bool doNormalize, ref ValueReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, ref buffer);
        }
#endif // FEATURE_SPAN

        public override int SpanQuickCheckYes(string s)
        {
            return Impl.MakeFCDQuickCheck(s, 0, s.Length); // ICU4N: Checked 3rd parameter
        }


        public override int SpanQuickCheckYes(StringBuilder s)
        {
            return Impl.MakeFCDQuickCheck(s, 0, s.Length); // ICU4N: Checked 3rd parameter
        }


        public override int SpanQuickCheckYes(char[] s)
        {
            return Impl.MakeFCDQuickCheck(s, 0, s.Length); // ICU4N: Checked 3rd parameter
        }


        public override int SpanQuickCheckYes(ICharSequence s)
        {
            return Impl.MakeFCDQuickCheck(s, 0, s.Length); // ICU4N: Checked 3rd parameter
        }

#if FEATURE_SPAN
        public override int SpanQuickCheckYes(ReadOnlySpan<char> s)
        {
            return Impl.MakeFCDQuickCheck(s); // ICU4N: Checked 3rd parameter
        }
#endif // FEATURE_SPAN

    }
}
