//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Support.Text;
using ICU4N.Text;
using ICU4N.Util;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class Hangul
    {

        /// <summary>
        /// Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer
        /// and returns the length of the decomposition (2 or 3).
        /// </summary>
        public static int Decompose(int c, StringBuilder buffer)
        {
            try
            {
                c -= HANGUL_BASE;
                int c2 = c % JAMO_T_COUNT;
                c /= JAMO_T_COUNT;
                buffer.Append((char)(JAMO_L_BASE + c / JAMO_V_COUNT));
                buffer.Append((char)(JAMO_V_BASE + c % JAMO_V_COUNT));
                if (c2 == 0)
                {
                    return 2;
                }
                else
                {
                    buffer.Append((char)(JAMO_T_BASE + c2));
                    return 3;
                }
            }
            catch (IOException e)
            {
                // Will not occur because we do not write to I/O.
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer
        /// and returns the length of the decomposition (2 or 3).
        /// </summary>
        internal static int Decompose(int c, IAppendable buffer)
        {
            try
            {
                c -= HANGUL_BASE;
                int c2 = c % JAMO_T_COUNT;
                c /= JAMO_T_COUNT;
                buffer.Append((char)(JAMO_L_BASE + c / JAMO_V_COUNT));
                buffer.Append((char)(JAMO_V_BASE + c % JAMO_V_COUNT));
                if (c2 == 0)
                {
                    return 2;
                }
                else
                {
                    buffer.Append((char)(JAMO_T_BASE + c2));
                    return 3;
                }
            }
            catch (IOException e)
            {
                // Will not occur because we do not write to I/O.
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer.
        /// This is the raw, not recursive, decomposition. Its length is always 2.
        /// </summary>
        public static void GetRawDecomposition(int c, StringBuilder buffer)
        {
            try
            {
                int orig = c;
                c -= HANGUL_BASE;
                int c2 = c % JAMO_T_COUNT;
                if (c2 == 0)
                {
                    c /= JAMO_T_COUNT;
                    buffer.Append((char)(JAMO_L_BASE + c / JAMO_V_COUNT));
                    buffer.Append((char)(JAMO_V_BASE + c % JAMO_V_COUNT));
                }
                else
                {
                    buffer.Append((char)(orig - c2));  // LV syllable
                    buffer.Append((char)(JAMO_T_BASE + c2));
                }
            }
            catch (IOException e)
            {
                // Will not occur because we do not write to I/O.
                throw new ICUUncheckedIOException(e);
            }
        }

        /// <summary>
        /// Decomposes <paramref name="c"/>, which must be a Hangul syllable, into buffer.
        /// This is the raw, not recursive, decomposition. Its length is always 2.
        /// </summary>
        internal static void GetRawDecomposition(int c, IAppendable buffer)
        {
            try
            {
                int orig = c;
                c -= HANGUL_BASE;
                int c2 = c % JAMO_T_COUNT;
                if (c2 == 0)
                {
                    c /= JAMO_T_COUNT;
                    buffer.Append((char)(JAMO_L_BASE + c / JAMO_V_COUNT));
                    buffer.Append((char)(JAMO_V_BASE + c % JAMO_V_COUNT));
                }
                else
                {
                    buffer.Append((char)(orig - c2));  // LV syllable
                    buffer.Append((char)(JAMO_T_BASE + c2));
                }
            }
            catch (IOException e)
            {
                // Will not occur because we do not write to I/O.
                throw new ICUUncheckedIOException(e);
            }
        }
    }

    public sealed partial class ReorderingBuffer
    {

        public bool Equals(string s, int start, int limit)
        {
            return UTF16Plus.Equal(str, 0, str.Length, s, start, limit);
        }

        public bool Equals(StringBuilder s, int start, int limit)
        {
            return UTF16Plus.Equal(str, 0, str.Length, s, start, limit);
        }

        public bool Equals(char[] s, int start, int limit)
        {
            return UTF16Plus.Equal(str, 0, str.Length, s, start, limit);
        }

        internal bool Equals(ICharSequence s, int start, int limit)
        {
            return UTF16Plus.Equal(str, 0, str.Length, s, start, limit);
        }

        // s must be in NFD, otherwise change the implementation.
        public void Append(string s, int start, int limit,
            int leadCC, int trailCC)
        {
            if (start == limit)
            {
                return;
            }
            if (lastCC <= leadCC || leadCC == 0)
            {
                if (trailCC <= 1)
                {
                    reorderStart = str.Length + (limit - start);
                }
                else if (leadCC <= 1)
                {
                    reorderStart = str.Length + 1;  // Ok if not a code point boundary.
                }
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = trailCC;
            }
            else
            {
                int c = Character.CodePointAt(s, start);
                start += Character.CharCount(c);
                Insert(c, leadCC);  // insert first code point
                while (start < limit)
                {
                    c = Character.CodePointAt(s, start);
                    start += Character.CharCount(c);
                    if (start < limit)
                    {
                        // s must be in NFD, otherwise we need to use getCC().
                        leadCC = Normalizer2Impl.GetCCFromYesOrMaybe(impl.GetNorm16(c));
                    }
                    else
                    {
                        leadCC = trailCC;
                    }
                    Append(c, leadCC);
                }
            }
        }

        // s must be in NFD, otherwise change the implementation.
        public void Append(StringBuilder s, int start, int limit,
            int leadCC, int trailCC)
        {
            if (start == limit)
            {
                return;
            }
            if (lastCC <= leadCC || leadCC == 0)
            {
                if (trailCC <= 1)
                {
                    reorderStart = str.Length + (limit - start);
                }
                else if (leadCC <= 1)
                {
                    reorderStart = str.Length + 1;  // Ok if not a code point boundary.
                }
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = trailCC;
            }
            else
            {
                int c = Character.CodePointAt(s, start);
                start += Character.CharCount(c);
                Insert(c, leadCC);  // insert first code point
                while (start < limit)
                {
                    c = Character.CodePointAt(s, start);
                    start += Character.CharCount(c);
                    if (start < limit)
                    {
                        // s must be in NFD, otherwise we need to use getCC().
                        leadCC = Normalizer2Impl.GetCCFromYesOrMaybe(impl.GetNorm16(c));
                    }
                    else
                    {
                        leadCC = trailCC;
                    }
                    Append(c, leadCC);
                }
            }
        }

        // s must be in NFD, otherwise change the implementation.
        public void Append(char[] s, int start, int limit,
            int leadCC, int trailCC)
        {
            if (start == limit)
            {
                return;
            }
            if (lastCC <= leadCC || leadCC == 0)
            {
                if (trailCC <= 1)
                {
                    reorderStart = str.Length + (limit - start);
                }
                else if (leadCC <= 1)
                {
                    reorderStart = str.Length + 1;  // Ok if not a code point boundary.
                }
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = trailCC;
            }
            else
            {
                int c = Character.CodePointAt(s, start);
                start += Character.CharCount(c);
                Insert(c, leadCC);  // insert first code point
                while (start < limit)
                {
                    c = Character.CodePointAt(s, start);
                    start += Character.CharCount(c);
                    if (start < limit)
                    {
                        // s must be in NFD, otherwise we need to use getCC().
                        leadCC = Normalizer2Impl.GetCCFromYesOrMaybe(impl.GetNorm16(c));
                    }
                    else
                    {
                        leadCC = trailCC;
                    }
                    Append(c, leadCC);
                }
            }
        }

        // s must be in NFD, otherwise change the implementation.
        internal void Append(ICharSequence s, int start, int limit,
            int leadCC, int trailCC)
        {
            if (start == limit)
            {
                return;
            }
            if (lastCC <= leadCC || leadCC == 0)
            {
                if (trailCC <= 1)
                {
                    reorderStart = str.Length + (limit - start);
                }
                else if (leadCC <= 1)
                {
                    reorderStart = str.Length + 1;  // Ok if not a code point boundary.
                }
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = trailCC;
            }
            else
            {
                int c = Character.CodePointAt(s, start);
                start += Character.CharCount(c);
                Insert(c, leadCC);  // insert first code point
                while (start < limit)
                {
                    c = Character.CodePointAt(s, start);
                    start += Character.CharCount(c);
                    if (start < limit)
                    {
                        // s must be in NFD, otherwise we need to use getCC().
                        leadCC = Normalizer2Impl.GetCCFromYesOrMaybe(impl.GetNorm16(c));
                    }
                    else
                    {
                        leadCC = trailCC;
                    }
                    Append(c, leadCC);
                }
            }
        }

        public ReorderingBuffer Append(string s)
        {
            if (s.Length != 0)
            {
                str.Append(s);
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        public ReorderingBuffer Append(StringBuilder s)
        {
            if (s.Length != 0)
            {
                str.Append(s);
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        public ReorderingBuffer Append(char[] s)
        {
            if (s.Length != 0)
            {
                str.Append(s);
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        internal ReorderingBuffer Append(ICharSequence s)
        {
            if (s.Length != 0)
            {
                str.Append(s);
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        public ReorderingBuffer Append(string s, int start, int limit)
        {
            if (start != limit)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        public ReorderingBuffer Append(StringBuilder s, int start, int limit)
        {
            if (start != limit)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        public ReorderingBuffer Append(char[] s, int start, int limit)
        {
            if (start != limit)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        internal ReorderingBuffer Append(ICharSequence s, int start, int limit)
        {
            if (start != limit)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                lastCC = 0;
                reorderStart = str.Length;
            }
            return this;
        }

        /// <summary>
        /// Flushes from the intermediate <see cref="System.Text.StringBuilder"/> to the <see cref="IAppendable"/>,
        /// if they are different objects.
        /// Then appends the new text to the <see cref="IAppendable"/> or <see cref="System.Text.StringBuilder"/>.
        /// Normally used after quick check loops find a non-empty sequence.
        /// </summary>
        public ReorderingBuffer FlushAndAppendZeroCC(string s, int start, int limit)
        {
            if (appIsStringBuilder)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                reorderStart = str.Length;
            }
            else
            {
                try
                {
                    app.Append(str).Append(s, start, limit);
                    str.Length = 0;
                    reorderStart = 0;
                }
                catch (IOException e)
                {
                    throw new ICUUncheckedIOException(e);  // Avoid declaring "throws IOException".
                }
            }
            lastCC = 0;
            return this;
        }

        /// <summary>
        /// Flushes from the intermediate <see cref="System.Text.StringBuilder"/> to the <see cref="IAppendable"/>,
        /// if they are different objects.
        /// Then appends the new text to the <see cref="IAppendable"/> or <see cref="System.Text.StringBuilder"/>.
        /// Normally used after quick check loops find a non-empty sequence.
        /// </summary>
        public ReorderingBuffer FlushAndAppendZeroCC(StringBuilder s, int start, int limit)
        {
            if (appIsStringBuilder)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                reorderStart = str.Length;
            }
            else
            {
                try
                {
                    app.Append(str).Append(s, start, limit);
                    str.Length = 0;
                    reorderStart = 0;
                }
                catch (IOException e)
                {
                    throw new ICUUncheckedIOException(e);  // Avoid declaring "throws IOException".
                }
            }
            lastCC = 0;
            return this;
        }

        /// <summary>
        /// Flushes from the intermediate <see cref="System.Text.StringBuilder"/> to the <see cref="IAppendable"/>,
        /// if they are different objects.
        /// Then appends the new text to the <see cref="IAppendable"/> or <see cref="System.Text.StringBuilder"/>.
        /// Normally used after quick check loops find a non-empty sequence.
        /// </summary>
        public ReorderingBuffer FlushAndAppendZeroCC(char[] s, int start, int limit)
        {
            if (appIsStringBuilder)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                reorderStart = str.Length;
            }
            else
            {
                try
                {
                    app.Append(str).Append(s, start, limit);
                    str.Length = 0;
                    reorderStart = 0;
                }
                catch (IOException e)
                {
                    throw new ICUUncheckedIOException(e);  // Avoid declaring "throws IOException".
                }
            }
            lastCC = 0;
            return this;
        }

        /// <summary>
        /// Flushes from the intermediate <see cref="System.Text.StringBuilder"/> to the <see cref="IAppendable"/>,
        /// if they are different objects.
        /// Then appends the new text to the <see cref="IAppendable"/> or <see cref="System.Text.StringBuilder"/>.
        /// Normally used after quick check loops find a non-empty sequence.
        /// </summary>
        internal ReorderingBuffer FlushAndAppendZeroCC(ICharSequence s, int start, int limit)
        {
            if (appIsStringBuilder)
            {
                str.Append(s, start, limit - start); // ICU4N: corrected 3rd parameter
                reorderStart = str.Length;
            }
            else
            {
                try
                {
                    app.Append(str).Append(s, start, limit);
                    str.Length = 0;
                    reorderStart = 0;
                }
                catch (IOException e)
                {
                    throw new ICUUncheckedIOException(e);  // Avoid declaring "throws IOException".
                }
            }
            lastCC = 0;
            return this;
        }
    }

    public sealed partial class UTF16Plus
    {
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(string s1, string s2)
        {
            if (s1 == s2)
            {
                return true;
            }
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(string s1, StringBuilder s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(string s1, char[] s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(string s1, ICharSequence s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(StringBuilder s1, string s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(StringBuilder s1, StringBuilder s2)
        {
            if (s1 == s2)
            {
                return true;
            }
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(StringBuilder s1, char[] s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(StringBuilder s1, ICharSequence s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(char[] s1, string s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(char[] s1, StringBuilder s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        public static bool Equal(char[] s1, char[] s2)
        {
            if (s1 == s2)
            {
                return true;
            }
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(char[] s1, ICharSequence s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(ICharSequence s1, string s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(ICharSequence s1, StringBuilder s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(ICharSequence s1, char[] s2)
        {
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character sequence objects for binary equality.
        /// </summary>
        /// <param name="s1">s1 first sequence</param>
        /// <param name="s2">s2 second sequence</param>
        /// <returns>true if s1 contains the same text as s2.</returns>
        internal static bool Equal(ICharSequence s1, ICharSequence s2)
        {
            if (s1 == s2)
            {
                return true;
            }
            int length = s1.Length;
            if (length != s2.Length)
            {
                return false;
            }
            for (int i = 0; i < length; ++i)
            {
                if (s1[i] != s2[i])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(string s1, int start1, int limit1,
            string s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            if (s1 == s2 && start1 == start2)
            {
                return true;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(string s1, int start1, int limit1,
            StringBuilder s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(string s1, int start1, int limit1,
            char[] s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(string s1, int start1, int limit1,
            ICharSequence s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(StringBuilder s1, int start1, int limit1,
            string s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(StringBuilder s1, int start1, int limit1,
            StringBuilder s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            if (s1 == s2 && start1 == start2)
            {
                return true;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(StringBuilder s1, int start1, int limit1,
            char[] s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(StringBuilder s1, int start1, int limit1,
            ICharSequence s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(char[] s1, int start1, int limit1,
            string s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(char[] s1, int start1, int limit1,
            StringBuilder s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        public static bool Equal(char[] s1, int start1, int limit1,
            char[] s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            if (s1 == s2 && start1 == start2)
            {
                return true;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(char[] s1, int start1, int limit1,
            ICharSequence s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
        
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(ICharSequence s1, int start1, int limit1,
            string s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(ICharSequence s1, int start1, int limit1,
            StringBuilder s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(ICharSequence s1, int start1, int limit1,
            char[] s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
    
        /// <summary>
        /// Compares two character subsequences for binary equality.
        /// </summary>
        /// <param name="s1">first sequence</param>
        /// <param name="start1">start offset in first sequence</param>
        /// <param name="limit1">limit offset in first sequence</param>
        /// <param name="s2">second sequence</param>
        /// <param name="start2">start offset in second sequence</param>
        /// <param name="limit2">limit offset in second sequence</param>
        /// <returns>true if s1.SubSequence(start1, limit1) contains the same text as s2.SubSequence(start2, limit2).</returns>
        internal static bool Equal(ICharSequence s1, int start1, int limit1,
            ICharSequence s2, int start2, int limit2)
        {
            if ((limit1 - start1) != (limit2 - start2))
            {
                return false;
            }
            if (s1 == s2 && start1 == start2)
            {
                return true;
            }
            while (start1 < limit1)
            {
                if (s1[start1++] != s2[start2++])
                {
                    return false;
                }
            }
            return true;
        }
        }



    public sealed partial class Normalizer2Impl
    {



        // NFD without an NFD Normalizer2 instance.
        public StringBuilder Decompose(string s, StringBuilder dest)
        {
            Decompose(s, 0, s.Length, dest, s.Length);
            return dest;
        }

        // NFD without an NFD Normalizer2 instance.
        public StringBuilder Decompose(StringBuilder s, StringBuilder dest)
        {
            Decompose(s, 0, s.Length, dest, s.Length);
            return dest;
        }

        // NFD without an NFD Normalizer2 instance.
        public StringBuilder Decompose(char[] s, StringBuilder dest)
        {
            Decompose(s, 0, s.Length, dest, s.Length);
            return dest;
        }

        // NFD without an NFD Normalizer2 instance.
        internal StringBuilder Decompose(ICharSequence s, StringBuilder dest)
        {
            Decompose(s, 0, s.Length, dest, s.Length);
            return dest;
        }

        /// <summary>
        /// Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
        /// limit can be NULL if src is NUL-terminated.
        /// <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
        /// </summary>
        public void Decompose(string s, int src, int limit, StringBuilder dest,
            int destLengthEstimate)
        {
            if (destLengthEstimate < 0)
            {
                destLengthEstimate = limit - src;
            }
            dest.Length = 0;
            ReorderingBuffer buffer = new ReorderingBuffer(this, dest, destLengthEstimate);
            Decompose(s, src, limit, buffer);
        }

        /// <summary>
        /// Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
        /// limit can be NULL if src is NUL-terminated.
        /// <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
        /// </summary>
        public void Decompose(StringBuilder s, int src, int limit, StringBuilder dest,
            int destLengthEstimate)
        {
            if (destLengthEstimate < 0)
            {
                destLengthEstimate = limit - src;
            }
            dest.Length = 0;
            ReorderingBuffer buffer = new ReorderingBuffer(this, dest, destLengthEstimate);
            Decompose(s, src, limit, buffer);
        }

        /// <summary>
        /// Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
        /// limit can be NULL if src is NUL-terminated.
        /// <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
        /// </summary>
        public void Decompose(char[] s, int src, int limit, StringBuilder dest,
            int destLengthEstimate)
        {
            if (destLengthEstimate < 0)
            {
                destLengthEstimate = limit - src;
            }
            dest.Length = 0;
            ReorderingBuffer buffer = new ReorderingBuffer(this, dest, destLengthEstimate);
            Decompose(s, src, limit, buffer);
        }

        /// <summary>
        /// Decomposes s[src, limit[ and writes the result to <paramref name="dest"/>.
        /// limit can be NULL if src is NUL-terminated.
        /// <paramref name="destLengthEstimate"/> is the initial <paramref name="dest"/> buffer capacity and can be -1.
        /// </summary>
        internal void Decompose(ICharSequence s, int src, int limit, StringBuilder dest,
            int destLengthEstimate)
        {
            if (destLengthEstimate < 0)
            {
                destLengthEstimate = limit - src;
            }
            dest.Length = 0;
            ReorderingBuffer buffer = new ReorderingBuffer(this, dest, destLengthEstimate);
            Decompose(s, src, limit, buffer);
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        public int Decompose(string s, int src, int limit,
            ReorderingBuffer buffer)
        {
            int minNoCP = minDecompNoCP;

            int prevSrc;
            int c = 0;
            int norm16 = 0;

            // only for quick check
            int prevBoundary = src;
            int prevCC = 0;

            for (; ; )
            {
                // count code units below the minimum or with irrelevant data for the quick check
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minNoCP ||
                        IsMostDecompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else if (!UTF16.IsSurrogate((char)c))
                    {
                        break;
                    }
                    else
                    {
                        char c2;
                        if (UTF16Plus.IsSurrogateLead(c))
                        {
                            if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                            {
                                c = Character.ToCodePoint((char)c, c2);
                            }
                        }
                        else /* trail surrogate */
                        {
                            if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                            {
                                --src;
                                c = Character.ToCodePoint(c2, (char)c);
                            }
                        }
                        if (IsMostDecompYesAndZeroCC(norm16 = GetNorm16(c)))
                        {
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (buffer != null)
                    {
                        buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                    }
                    else
                    {
                        prevCC = 0;
                        prevBoundary = src;
                    }
                }
                if (src == limit)
                {
                    break;
                }

                // Check one above-minimum, relevant code point.
                src += Character.CharCount(c);
                if (buffer != null)
                {
                    Decompose(c, norm16, buffer);
                }
                else
                {
                    if (IsDecompYes(norm16))
                    {
                        int cc = GetCCFromYesOrMaybe(norm16);
                        if (prevCC <= cc || cc == 0)
                        {
                            prevCC = cc;
                            if (cc <= 1)
                            {
                                prevBoundary = src;
                            }
                            continue;
                        }
                    }
                    return prevBoundary;  // "no" or cc out of order
                }
            }
            return src;
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        public int Decompose(StringBuilder s, int src, int limit,
            ReorderingBuffer buffer)
        {
            int minNoCP = minDecompNoCP;

            int prevSrc;
            int c = 0;
            int norm16 = 0;

            // only for quick check
            int prevBoundary = src;
            int prevCC = 0;

            for (; ; )
            {
                // count code units below the minimum or with irrelevant data for the quick check
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minNoCP ||
                        IsMostDecompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else if (!UTF16.IsSurrogate((char)c))
                    {
                        break;
                    }
                    else
                    {
                        char c2;
                        if (UTF16Plus.IsSurrogateLead(c))
                        {
                            if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                            {
                                c = Character.ToCodePoint((char)c, c2);
                            }
                        }
                        else /* trail surrogate */
                        {
                            if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                            {
                                --src;
                                c = Character.ToCodePoint(c2, (char)c);
                            }
                        }
                        if (IsMostDecompYesAndZeroCC(norm16 = GetNorm16(c)))
                        {
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (buffer != null)
                    {
                        buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                    }
                    else
                    {
                        prevCC = 0;
                        prevBoundary = src;
                    }
                }
                if (src == limit)
                {
                    break;
                }

                // Check one above-minimum, relevant code point.
                src += Character.CharCount(c);
                if (buffer != null)
                {
                    Decompose(c, norm16, buffer);
                }
                else
                {
                    if (IsDecompYes(norm16))
                    {
                        int cc = GetCCFromYesOrMaybe(norm16);
                        if (prevCC <= cc || cc == 0)
                        {
                            prevCC = cc;
                            if (cc <= 1)
                            {
                                prevBoundary = src;
                            }
                            continue;
                        }
                    }
                    return prevBoundary;  // "no" or cc out of order
                }
            }
            return src;
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        public int Decompose(char[] s, int src, int limit,
            ReorderingBuffer buffer)
        {
            int minNoCP = minDecompNoCP;

            int prevSrc;
            int c = 0;
            int norm16 = 0;

            // only for quick check
            int prevBoundary = src;
            int prevCC = 0;

            for (; ; )
            {
                // count code units below the minimum or with irrelevant data for the quick check
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minNoCP ||
                        IsMostDecompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else if (!UTF16.IsSurrogate((char)c))
                    {
                        break;
                    }
                    else
                    {
                        char c2;
                        if (UTF16Plus.IsSurrogateLead(c))
                        {
                            if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                            {
                                c = Character.ToCodePoint((char)c, c2);
                            }
                        }
                        else /* trail surrogate */
                        {
                            if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                            {
                                --src;
                                c = Character.ToCodePoint(c2, (char)c);
                            }
                        }
                        if (IsMostDecompYesAndZeroCC(norm16 = GetNorm16(c)))
                        {
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (buffer != null)
                    {
                        buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                    }
                    else
                    {
                        prevCC = 0;
                        prevBoundary = src;
                    }
                }
                if (src == limit)
                {
                    break;
                }

                // Check one above-minimum, relevant code point.
                src += Character.CharCount(c);
                if (buffer != null)
                {
                    Decompose(c, norm16, buffer);
                }
                else
                {
                    if (IsDecompYes(norm16))
                    {
                        int cc = GetCCFromYesOrMaybe(norm16);
                        if (prevCC <= cc || cc == 0)
                        {
                            prevCC = cc;
                            if (cc <= 1)
                            {
                                prevBoundary = src;
                            }
                            continue;
                        }
                    }
                    return prevBoundary;  // "no" or cc out of order
                }
            }
            return src;
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        internal int Decompose(ICharSequence s, int src, int limit,
            ReorderingBuffer buffer)
        {
            int minNoCP = minDecompNoCP;

            int prevSrc;
            int c = 0;
            int norm16 = 0;

            // only for quick check
            int prevBoundary = src;
            int prevCC = 0;

            for (; ; )
            {
                // count code units below the minimum or with irrelevant data for the quick check
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minNoCP ||
                        IsMostDecompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else if (!UTF16.IsSurrogate((char)c))
                    {
                        break;
                    }
                    else
                    {
                        char c2;
                        if (UTF16Plus.IsSurrogateLead(c))
                        {
                            if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                            {
                                c = Character.ToCodePoint((char)c, c2);
                            }
                        }
                        else /* trail surrogate */
                        {
                            if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                            {
                                --src;
                                c = Character.ToCodePoint(c2, (char)c);
                            }
                        }
                        if (IsMostDecompYesAndZeroCC(norm16 = GetNorm16(c)))
                        {
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (buffer != null)
                    {
                        buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                    }
                    else
                    {
                        prevCC = 0;
                        prevBoundary = src;
                    }
                }
                if (src == limit)
                {
                    break;
                }

                // Check one above-minimum, relevant code point.
                src += Character.CharCount(c);
                if (buffer != null)
                {
                    Decompose(c, norm16, buffer);
                }
                else
                {
                    if (IsDecompYes(norm16))
                    {
                        int cc = GetCCFromYesOrMaybe(norm16);
                        if (prevCC <= cc || cc == 0)
                        {
                            prevCC = cc;
                            if (cc <= 1)
                            {
                                prevBoundary = src;
                            }
                            continue;
                        }
                    }
                    return prevBoundary;  // "no" or cc out of order
                }
            }
            return src;
        }

        public void DecomposeAndAppend(string s, bool doDecompose, ReorderingBuffer buffer)
        {
            int limit = s.Length;
            if (limit == 0)
            {
                return;
            }
            if (doDecompose)
            {
                Decompose(s, 0, limit, buffer);
                return;
            }
            // Just merge the strings at the boundary.
            int c = Character.CodePointAt(s, 0);
            int src = 0;
            int firstCC, prevCC, cc;
            firstCC = prevCC = cc = GetCC(GetNorm16(c));
            while (cc != 0)
            {
                prevCC = cc;
                src += Character.CharCount(c);
                if (src >= limit)
                {
                    break;
                }
                c = Character.CodePointAt(s, src);
                cc = GetCC(GetNorm16(c));
            };
            buffer.Append(s, 0, src, firstCC, prevCC);
            buffer.Append(s, src, limit);
        }

        public void DecomposeAndAppend(StringBuilder s, bool doDecompose, ReorderingBuffer buffer)
        {
            int limit = s.Length;
            if (limit == 0)
            {
                return;
            }
            if (doDecompose)
            {
                Decompose(s, 0, limit, buffer);
                return;
            }
            // Just merge the strings at the boundary.
            int c = Character.CodePointAt(s, 0);
            int src = 0;
            int firstCC, prevCC, cc;
            firstCC = prevCC = cc = GetCC(GetNorm16(c));
            while (cc != 0)
            {
                prevCC = cc;
                src += Character.CharCount(c);
                if (src >= limit)
                {
                    break;
                }
                c = Character.CodePointAt(s, src);
                cc = GetCC(GetNorm16(c));
            };
            buffer.Append(s, 0, src, firstCC, prevCC);
            buffer.Append(s, src, limit);
        }

        public void DecomposeAndAppend(char[] s, bool doDecompose, ReorderingBuffer buffer)
        {
            int limit = s.Length;
            if (limit == 0)
            {
                return;
            }
            if (doDecompose)
            {
                Decompose(s, 0, limit, buffer);
                return;
            }
            // Just merge the strings at the boundary.
            int c = Character.CodePointAt(s, 0);
            int src = 0;
            int firstCC, prevCC, cc;
            firstCC = prevCC = cc = GetCC(GetNorm16(c));
            while (cc != 0)
            {
                prevCC = cc;
                src += Character.CharCount(c);
                if (src >= limit)
                {
                    break;
                }
                c = Character.CodePointAt(s, src);
                cc = GetCC(GetNorm16(c));
            };
            buffer.Append(s, 0, src, firstCC, prevCC);
            buffer.Append(s, src, limit);
        }

        internal void DecomposeAndAppend(ICharSequence s, bool doDecompose, ReorderingBuffer buffer)
        {
            int limit = s.Length;
            if (limit == 0)
            {
                return;
            }
            if (doDecompose)
            {
                Decompose(s, 0, limit, buffer);
                return;
            }
            // Just merge the strings at the boundary.
            int c = Character.CodePointAt(s, 0);
            int src = 0;
            int firstCC, prevCC, cc;
            firstCC = prevCC = cc = GetCC(GetNorm16(c));
            while (cc != 0)
            {
                prevCC = cc;
                src += Character.CharCount(c);
                if (src >= limit)
                {
                    break;
                }
                c = Character.CodePointAt(s, src);
                cc = GetCC(GetNorm16(c));
            };
            buffer.Append(s, 0, src, firstCC, prevCC);
            buffer.Append(s, src, limit);
        }

        // Very similar to ComposeQuickCheck(): Make the same changes in both places if relevant.
        // doCompose: normalize
        // !doCompose: isNormalized (buffer must be empty and initialized)
        public bool Compose(string s, int src, int limit,
                           bool onlyContiguous,
                           bool doCompose,
                           ReorderingBuffer buffer)
        {
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        if (prevBoundary != limit && doCompose)
                        {
                            buffer.Append(s, prevBoundary, limit);
                        }
                        return true;
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
                if (!IsMaybeOrNonZeroCC(norm16))
                {  // minNoNo <= norm16 < minMaybeYes
                    if (!doCompose)
                    {
                        return false;
                    }
                    // Fast path for mapping a character that is immediately surrounded by boundaries.
                    // In this case, we need not decompose around the current character.
                    if (IsDecompNoAlgorithmic(norm16))
                    {
                        // Maps to a single isCompYesAndZeroCC character
                        // which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            buffer.Append(MapAlgorithmic(c, norm16), 0);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 < minNoNoCompBoundaryBefore)
                    {
                        // The mapping is comp-normalized which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            int mapping = norm16 >> OFFSET_SHIFT;
                            int length = extraData[mapping++] & MAPPING_LENGTH_MASK;
                            buffer.Append(extraData, mapping, mapping + length);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 >= minNoNoEmpty)
                    {
                        // The current character maps to nothing.
                        // Simply omit it from the output if there is a boundary before _or_ after it.
                        // The character itself implies no boundaries.
                        if (HasCompBoundaryBefore(s, src, limit) ||
                                HasCompBoundaryAfter(s, prevBoundary, prevSrc, onlyContiguous))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            prevBoundary = src;
                            continue;
                        }
                    }
                    // Other "noNo" type, or need to examine more text around this character:
                    // Fall through to the slow path.
                }
                else if (IsJamoVT(norm16) && prevBoundary != prevSrc)
                {
                    char prev = s[prevSrc - 1];
                    if (c < Hangul.JAMO_T_BASE)
                    {
                        // The current character is a Jamo Vowel,
                        // compose with previous Jamo L and following Jamo T.
                        char l = (char)(prev - Hangul.JAMO_L_BASE);
                        if (l < Hangul.JAMO_L_COUNT)
                        {
                            if (!doCompose)
                            {
                                return false;
                            }
                            int t;
                            if (src != limit &&
                                    0 < (t = (s[src] - Hangul.JAMO_T_BASE)) &&
                                    t < Hangul.JAMO_T_COUNT)
                            {
                                // The next character is a Jamo T.
                                ++src;
                            }
                            else if (HasCompBoundaryBefore(s, src, limit))
                            {
                                // No Jamo T follows, not even via decomposition.
                                t = 0;
                            }
                            else
                            {
                                t = -1;
                            }
                            if (t >= 0)
                            {
                                int syllable = Hangul.HANGUL_BASE +
                                    (l * Hangul.JAMO_V_COUNT + (c - Hangul.JAMO_V_BASE)) *
                                    Hangul.JAMO_T_COUNT + t;
                                --prevSrc;  // Replace the Jamo L as well.
                                if (prevBoundary != prevSrc)
                                {
                                    buffer.Append(s, prevBoundary, prevSrc);
                                }
                                buffer.Append((char)syllable);
                                prevBoundary = src;
                                continue;
                            }
                            // If we see L+V+x where x!=T then we drop to the slow path,
                            // decompose and recompose.
                            // This is to deal with NFKC finding normal L and V but a
                            // compatibility variant of a T.
                            // We need to either fully compose that combination here
                            // (which would complicate the code and may not work with strange custom data)
                            // or use the slow path.
                        }
                    }
                    else if (Hangul.IsHangulLV(prev))
                    {
                        // The current character is a Jamo Trailing consonant,
                        // compose with previous Hangul LV that does not contain a Jamo T.
                        if (!doCompose)
                        {
                            return false;
                        }
                        int syllable = prev + c - Hangul.JAMO_T_BASE;
                        --prevSrc;  // Replace the Hangul LV as well.
                        if (prevBoundary != prevSrc)
                        {
                            buffer.Append(s, prevBoundary, prevSrc);
                        }
                        buffer.Append((char)syllable);
                        prevBoundary = src;
                        continue;
                    }
                    // No matching context, or may need to decompose surrounding text first:
                    // Fall through to the slow path.
                }
                else if (norm16 > JAMO_VT)
                {  // norm16 >= MIN_YES_YES_WITH_CC
                   // One or more combining marks that do not combine-back:
                   // Check for canonical order, copy unchanged if ok and
                   // if followed by a character with a boundary-before.
                    int cc = GetCCFromNormalYesOrMaybe(norm16);  // cc!=0
                    if (onlyContiguous /* FCC */ && GetPreviousTrailCC(s, prevBoundary, prevSrc) > cc)
                    {
                        // Fails FCD test, need to decompose and contiguously recompose.
                        if (!doCompose)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        int n16;
                        for (; ; )
                        {
                            if (src == limit)
                            {
                                if (doCompose)
                                {
                                    buffer.Append(s, prevBoundary, limit);
                                }
                                return true;
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            n16 = normTrie.Get(c);
                            if (n16 >= MIN_YES_YES_WITH_CC)
                            {
                                cc = GetCCFromNormalYesOrMaybe(n16);
                                if (prevCC > cc)
                                {
                                    if (!doCompose)
                                    {
                                        return false;
                                    }
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // p is after the last in-order combining mark.
                        // If there is a boundary here, then we continue with no change.
                        if (Norm16HasCompBoundaryBefore(n16))
                        {
                            if (IsCompYesAndZeroCC(n16))
                            {
                                src += Character.CharCount(c);
                            }
                            continue;
                        }
                        // Use the slow path. There is no boundary in [prevSrc, src[.
                    }
                }

                // Slow path: Find the nearest boundaries around the current character,
                // decompose and recompose.
                if (prevBoundary != prevSrc && !Norm16HasCompBoundaryBefore(norm16))
                {
                    c = Character.CodePointBefore(s, prevSrc);
                    norm16 = normTrie.Get(c);
                    if (!Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                    {
                        prevSrc -= Character.CharCount(c);
                    }
                }
                if (doCompose && prevBoundary != prevSrc)
                {
                    buffer.Append(s, prevBoundary, prevSrc);
                }
                int recomposeStartIndex = buffer.Length;
                // We know there is not a boundary here.
                DecomposeShort(s, prevSrc, src, false /* !stopAtCompBoundary */, onlyContiguous,
                               buffer);
                // Decompose until the next boundary.
                src = DecomposeShort(s, src, limit, true /* stopAtCompBoundary */, onlyContiguous,
                                     buffer);
                Recompose(buffer, recomposeStartIndex, onlyContiguous);
                if (!doCompose)
                {
                    if (!buffer.Equals(s, prevSrc, src))
                    {
                        return false;
                    }
                    buffer.Remove();
                }
                prevBoundary = src;
            }
        }

        // Very similar to ComposeQuickCheck(): Make the same changes in both places if relevant.
        // doCompose: normalize
        // !doCompose: isNormalized (buffer must be empty and initialized)
        public bool Compose(StringBuilder s, int src, int limit,
                           bool onlyContiguous,
                           bool doCompose,
                           ReorderingBuffer buffer)
        {
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        if (prevBoundary != limit && doCompose)
                        {
                            buffer.Append(s, prevBoundary, limit);
                        }
                        return true;
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
                if (!IsMaybeOrNonZeroCC(norm16))
                {  // minNoNo <= norm16 < minMaybeYes
                    if (!doCompose)
                    {
                        return false;
                    }
                    // Fast path for mapping a character that is immediately surrounded by boundaries.
                    // In this case, we need not decompose around the current character.
                    if (IsDecompNoAlgorithmic(norm16))
                    {
                        // Maps to a single isCompYesAndZeroCC character
                        // which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            buffer.Append(MapAlgorithmic(c, norm16), 0);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 < minNoNoCompBoundaryBefore)
                    {
                        // The mapping is comp-normalized which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            int mapping = norm16 >> OFFSET_SHIFT;
                            int length = extraData[mapping++] & MAPPING_LENGTH_MASK;
                            buffer.Append(extraData, mapping, mapping + length);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 >= minNoNoEmpty)
                    {
                        // The current character maps to nothing.
                        // Simply omit it from the output if there is a boundary before _or_ after it.
                        // The character itself implies no boundaries.
                        if (HasCompBoundaryBefore(s, src, limit) ||
                                HasCompBoundaryAfter(s, prevBoundary, prevSrc, onlyContiguous))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            prevBoundary = src;
                            continue;
                        }
                    }
                    // Other "noNo" type, or need to examine more text around this character:
                    // Fall through to the slow path.
                }
                else if (IsJamoVT(norm16) && prevBoundary != prevSrc)
                {
                    char prev = s[prevSrc - 1];
                    if (c < Hangul.JAMO_T_BASE)
                    {
                        // The current character is a Jamo Vowel,
                        // compose with previous Jamo L and following Jamo T.
                        char l = (char)(prev - Hangul.JAMO_L_BASE);
                        if (l < Hangul.JAMO_L_COUNT)
                        {
                            if (!doCompose)
                            {
                                return false;
                            }
                            int t;
                            if (src != limit &&
                                    0 < (t = (s[src] - Hangul.JAMO_T_BASE)) &&
                                    t < Hangul.JAMO_T_COUNT)
                            {
                                // The next character is a Jamo T.
                                ++src;
                            }
                            else if (HasCompBoundaryBefore(s, src, limit))
                            {
                                // No Jamo T follows, not even via decomposition.
                                t = 0;
                            }
                            else
                            {
                                t = -1;
                            }
                            if (t >= 0)
                            {
                                int syllable = Hangul.HANGUL_BASE +
                                    (l * Hangul.JAMO_V_COUNT + (c - Hangul.JAMO_V_BASE)) *
                                    Hangul.JAMO_T_COUNT + t;
                                --prevSrc;  // Replace the Jamo L as well.
                                if (prevBoundary != prevSrc)
                                {
                                    buffer.Append(s, prevBoundary, prevSrc);
                                }
                                buffer.Append((char)syllable);
                                prevBoundary = src;
                                continue;
                            }
                            // If we see L+V+x where x!=T then we drop to the slow path,
                            // decompose and recompose.
                            // This is to deal with NFKC finding normal L and V but a
                            // compatibility variant of a T.
                            // We need to either fully compose that combination here
                            // (which would complicate the code and may not work with strange custom data)
                            // or use the slow path.
                        }
                    }
                    else if (Hangul.IsHangulLV(prev))
                    {
                        // The current character is a Jamo Trailing consonant,
                        // compose with previous Hangul LV that does not contain a Jamo T.
                        if (!doCompose)
                        {
                            return false;
                        }
                        int syllable = prev + c - Hangul.JAMO_T_BASE;
                        --prevSrc;  // Replace the Hangul LV as well.
                        if (prevBoundary != prevSrc)
                        {
                            buffer.Append(s, prevBoundary, prevSrc);
                        }
                        buffer.Append((char)syllable);
                        prevBoundary = src;
                        continue;
                    }
                    // No matching context, or may need to decompose surrounding text first:
                    // Fall through to the slow path.
                }
                else if (norm16 > JAMO_VT)
                {  // norm16 >= MIN_YES_YES_WITH_CC
                   // One or more combining marks that do not combine-back:
                   // Check for canonical order, copy unchanged if ok and
                   // if followed by a character with a boundary-before.
                    int cc = GetCCFromNormalYesOrMaybe(norm16);  // cc!=0
                    if (onlyContiguous /* FCC */ && GetPreviousTrailCC(s, prevBoundary, prevSrc) > cc)
                    {
                        // Fails FCD test, need to decompose and contiguously recompose.
                        if (!doCompose)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        int n16;
                        for (; ; )
                        {
                            if (src == limit)
                            {
                                if (doCompose)
                                {
                                    buffer.Append(s, prevBoundary, limit);
                                }
                                return true;
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            n16 = normTrie.Get(c);
                            if (n16 >= MIN_YES_YES_WITH_CC)
                            {
                                cc = GetCCFromNormalYesOrMaybe(n16);
                                if (prevCC > cc)
                                {
                                    if (!doCompose)
                                    {
                                        return false;
                                    }
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // p is after the last in-order combining mark.
                        // If there is a boundary here, then we continue with no change.
                        if (Norm16HasCompBoundaryBefore(n16))
                        {
                            if (IsCompYesAndZeroCC(n16))
                            {
                                src += Character.CharCount(c);
                            }
                            continue;
                        }
                        // Use the slow path. There is no boundary in [prevSrc, src[.
                    }
                }

                // Slow path: Find the nearest boundaries around the current character,
                // decompose and recompose.
                if (prevBoundary != prevSrc && !Norm16HasCompBoundaryBefore(norm16))
                {
                    c = Character.CodePointBefore(s, prevSrc);
                    norm16 = normTrie.Get(c);
                    if (!Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                    {
                        prevSrc -= Character.CharCount(c);
                    }
                }
                if (doCompose && prevBoundary != prevSrc)
                {
                    buffer.Append(s, prevBoundary, prevSrc);
                }
                int recomposeStartIndex = buffer.Length;
                // We know there is not a boundary here.
                DecomposeShort(s, prevSrc, src, false /* !stopAtCompBoundary */, onlyContiguous,
                               buffer);
                // Decompose until the next boundary.
                src = DecomposeShort(s, src, limit, true /* stopAtCompBoundary */, onlyContiguous,
                                     buffer);
                Recompose(buffer, recomposeStartIndex, onlyContiguous);
                if (!doCompose)
                {
                    if (!buffer.Equals(s, prevSrc, src))
                    {
                        return false;
                    }
                    buffer.Remove();
                }
                prevBoundary = src;
            }
        }

        // Very similar to ComposeQuickCheck(): Make the same changes in both places if relevant.
        // doCompose: normalize
        // !doCompose: isNormalized (buffer must be empty and initialized)
        public bool Compose(char[] s, int src, int limit,
                           bool onlyContiguous,
                           bool doCompose,
                           ReorderingBuffer buffer)
        {
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        if (prevBoundary != limit && doCompose)
                        {
                            buffer.Append(s, prevBoundary, limit);
                        }
                        return true;
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
                if (!IsMaybeOrNonZeroCC(norm16))
                {  // minNoNo <= norm16 < minMaybeYes
                    if (!doCompose)
                    {
                        return false;
                    }
                    // Fast path for mapping a character that is immediately surrounded by boundaries.
                    // In this case, we need not decompose around the current character.
                    if (IsDecompNoAlgorithmic(norm16))
                    {
                        // Maps to a single isCompYesAndZeroCC character
                        // which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            buffer.Append(MapAlgorithmic(c, norm16), 0);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 < minNoNoCompBoundaryBefore)
                    {
                        // The mapping is comp-normalized which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            int mapping = norm16 >> OFFSET_SHIFT;
                            int length = extraData[mapping++] & MAPPING_LENGTH_MASK;
                            buffer.Append(extraData, mapping, mapping + length);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 >= minNoNoEmpty)
                    {
                        // The current character maps to nothing.
                        // Simply omit it from the output if there is a boundary before _or_ after it.
                        // The character itself implies no boundaries.
                        if (HasCompBoundaryBefore(s, src, limit) ||
                                HasCompBoundaryAfter(s, prevBoundary, prevSrc, onlyContiguous))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            prevBoundary = src;
                            continue;
                        }
                    }
                    // Other "noNo" type, or need to examine more text around this character:
                    // Fall through to the slow path.
                }
                else if (IsJamoVT(norm16) && prevBoundary != prevSrc)
                {
                    char prev = s[prevSrc - 1];
                    if (c < Hangul.JAMO_T_BASE)
                    {
                        // The current character is a Jamo Vowel,
                        // compose with previous Jamo L and following Jamo T.
                        char l = (char)(prev - Hangul.JAMO_L_BASE);
                        if (l < Hangul.JAMO_L_COUNT)
                        {
                            if (!doCompose)
                            {
                                return false;
                            }
                            int t;
                            if (src != limit &&
                                    0 < (t = (s[src] - Hangul.JAMO_T_BASE)) &&
                                    t < Hangul.JAMO_T_COUNT)
                            {
                                // The next character is a Jamo T.
                                ++src;
                            }
                            else if (HasCompBoundaryBefore(s, src, limit))
                            {
                                // No Jamo T follows, not even via decomposition.
                                t = 0;
                            }
                            else
                            {
                                t = -1;
                            }
                            if (t >= 0)
                            {
                                int syllable = Hangul.HANGUL_BASE +
                                    (l * Hangul.JAMO_V_COUNT + (c - Hangul.JAMO_V_BASE)) *
                                    Hangul.JAMO_T_COUNT + t;
                                --prevSrc;  // Replace the Jamo L as well.
                                if (prevBoundary != prevSrc)
                                {
                                    buffer.Append(s, prevBoundary, prevSrc);
                                }
                                buffer.Append((char)syllable);
                                prevBoundary = src;
                                continue;
                            }
                            // If we see L+V+x where x!=T then we drop to the slow path,
                            // decompose and recompose.
                            // This is to deal with NFKC finding normal L and V but a
                            // compatibility variant of a T.
                            // We need to either fully compose that combination here
                            // (which would complicate the code and may not work with strange custom data)
                            // or use the slow path.
                        }
                    }
                    else if (Hangul.IsHangulLV(prev))
                    {
                        // The current character is a Jamo Trailing consonant,
                        // compose with previous Hangul LV that does not contain a Jamo T.
                        if (!doCompose)
                        {
                            return false;
                        }
                        int syllable = prev + c - Hangul.JAMO_T_BASE;
                        --prevSrc;  // Replace the Hangul LV as well.
                        if (prevBoundary != prevSrc)
                        {
                            buffer.Append(s, prevBoundary, prevSrc);
                        }
                        buffer.Append((char)syllable);
                        prevBoundary = src;
                        continue;
                    }
                    // No matching context, or may need to decompose surrounding text first:
                    // Fall through to the slow path.
                }
                else if (norm16 > JAMO_VT)
                {  // norm16 >= MIN_YES_YES_WITH_CC
                   // One or more combining marks that do not combine-back:
                   // Check for canonical order, copy unchanged if ok and
                   // if followed by a character with a boundary-before.
                    int cc = GetCCFromNormalYesOrMaybe(norm16);  // cc!=0
                    if (onlyContiguous /* FCC */ && GetPreviousTrailCC(s, prevBoundary, prevSrc) > cc)
                    {
                        // Fails FCD test, need to decompose and contiguously recompose.
                        if (!doCompose)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        int n16;
                        for (; ; )
                        {
                            if (src == limit)
                            {
                                if (doCompose)
                                {
                                    buffer.Append(s, prevBoundary, limit);
                                }
                                return true;
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            n16 = normTrie.Get(c);
                            if (n16 >= MIN_YES_YES_WITH_CC)
                            {
                                cc = GetCCFromNormalYesOrMaybe(n16);
                                if (prevCC > cc)
                                {
                                    if (!doCompose)
                                    {
                                        return false;
                                    }
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // p is after the last in-order combining mark.
                        // If there is a boundary here, then we continue with no change.
                        if (Norm16HasCompBoundaryBefore(n16))
                        {
                            if (IsCompYesAndZeroCC(n16))
                            {
                                src += Character.CharCount(c);
                            }
                            continue;
                        }
                        // Use the slow path. There is no boundary in [prevSrc, src[.
                    }
                }

                // Slow path: Find the nearest boundaries around the current character,
                // decompose and recompose.
                if (prevBoundary != prevSrc && !Norm16HasCompBoundaryBefore(norm16))
                {
                    c = Character.CodePointBefore(s, prevSrc);
                    norm16 = normTrie.Get(c);
                    if (!Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                    {
                        prevSrc -= Character.CharCount(c);
                    }
                }
                if (doCompose && prevBoundary != prevSrc)
                {
                    buffer.Append(s, prevBoundary, prevSrc);
                }
                int recomposeStartIndex = buffer.Length;
                // We know there is not a boundary here.
                DecomposeShort(s, prevSrc, src, false /* !stopAtCompBoundary */, onlyContiguous,
                               buffer);
                // Decompose until the next boundary.
                src = DecomposeShort(s, src, limit, true /* stopAtCompBoundary */, onlyContiguous,
                                     buffer);
                Recompose(buffer, recomposeStartIndex, onlyContiguous);
                if (!doCompose)
                {
                    if (!buffer.Equals(s, prevSrc, src))
                    {
                        return false;
                    }
                    buffer.Remove();
                }
                prevBoundary = src;
            }
        }

        // Very similar to ComposeQuickCheck(): Make the same changes in both places if relevant.
        // doCompose: normalize
        // !doCompose: isNormalized (buffer must be empty and initialized)
        internal bool Compose(ICharSequence s, int src, int limit,
                           bool onlyContiguous,
                           bool doCompose,
                           ReorderingBuffer buffer)
        {
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        if (prevBoundary != limit && doCompose)
                        {
                            buffer.Append(s, prevBoundary, limit);
                        }
                        return true;
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                // Medium-fast path: Handle cases that do not require full decomposition and recomposition.
                if (!IsMaybeOrNonZeroCC(norm16))
                {  // minNoNo <= norm16 < minMaybeYes
                    if (!doCompose)
                    {
                        return false;
                    }
                    // Fast path for mapping a character that is immediately surrounded by boundaries.
                    // In this case, we need not decompose around the current character.
                    if (IsDecompNoAlgorithmic(norm16))
                    {
                        // Maps to a single isCompYesAndZeroCC character
                        // which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            buffer.Append(MapAlgorithmic(c, norm16), 0);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 < minNoNoCompBoundaryBefore)
                    {
                        // The mapping is comp-normalized which also implies hasCompBoundaryBefore.
                        if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous) ||
                                HasCompBoundaryBefore(s, src, limit))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            int mapping = norm16 >> OFFSET_SHIFT;
                            int length = extraData[mapping++] & MAPPING_LENGTH_MASK;
                            buffer.Append(extraData, mapping, mapping + length);
                            prevBoundary = src;
                            continue;
                        }
                    }
                    else if (norm16 >= minNoNoEmpty)
                    {
                        // The current character maps to nothing.
                        // Simply omit it from the output if there is a boundary before _or_ after it.
                        // The character itself implies no boundaries.
                        if (HasCompBoundaryBefore(s, src, limit) ||
                                HasCompBoundaryAfter(s, prevBoundary, prevSrc, onlyContiguous))
                        {
                            if (prevBoundary != prevSrc)
                            {
                                buffer.Append(s, prevBoundary, prevSrc);
                            }
                            prevBoundary = src;
                            continue;
                        }
                    }
                    // Other "noNo" type, or need to examine more text around this character:
                    // Fall through to the slow path.
                }
                else if (IsJamoVT(norm16) && prevBoundary != prevSrc)
                {
                    char prev = s[prevSrc - 1];
                    if (c < Hangul.JAMO_T_BASE)
                    {
                        // The current character is a Jamo Vowel,
                        // compose with previous Jamo L and following Jamo T.
                        char l = (char)(prev - Hangul.JAMO_L_BASE);
                        if (l < Hangul.JAMO_L_COUNT)
                        {
                            if (!doCompose)
                            {
                                return false;
                            }
                            int t;
                            if (src != limit &&
                                    0 < (t = (s[src] - Hangul.JAMO_T_BASE)) &&
                                    t < Hangul.JAMO_T_COUNT)
                            {
                                // The next character is a Jamo T.
                                ++src;
                            }
                            else if (HasCompBoundaryBefore(s, src, limit))
                            {
                                // No Jamo T follows, not even via decomposition.
                                t = 0;
                            }
                            else
                            {
                                t = -1;
                            }
                            if (t >= 0)
                            {
                                int syllable = Hangul.HANGUL_BASE +
                                    (l * Hangul.JAMO_V_COUNT + (c - Hangul.JAMO_V_BASE)) *
                                    Hangul.JAMO_T_COUNT + t;
                                --prevSrc;  // Replace the Jamo L as well.
                                if (prevBoundary != prevSrc)
                                {
                                    buffer.Append(s, prevBoundary, prevSrc);
                                }
                                buffer.Append((char)syllable);
                                prevBoundary = src;
                                continue;
                            }
                            // If we see L+V+x where x!=T then we drop to the slow path,
                            // decompose and recompose.
                            // This is to deal with NFKC finding normal L and V but a
                            // compatibility variant of a T.
                            // We need to either fully compose that combination here
                            // (which would complicate the code and may not work with strange custom data)
                            // or use the slow path.
                        }
                    }
                    else if (Hangul.IsHangulLV(prev))
                    {
                        // The current character is a Jamo Trailing consonant,
                        // compose with previous Hangul LV that does not contain a Jamo T.
                        if (!doCompose)
                        {
                            return false;
                        }
                        int syllable = prev + c - Hangul.JAMO_T_BASE;
                        --prevSrc;  // Replace the Hangul LV as well.
                        if (prevBoundary != prevSrc)
                        {
                            buffer.Append(s, prevBoundary, prevSrc);
                        }
                        buffer.Append((char)syllable);
                        prevBoundary = src;
                        continue;
                    }
                    // No matching context, or may need to decompose surrounding text first:
                    // Fall through to the slow path.
                }
                else if (norm16 > JAMO_VT)
                {  // norm16 >= MIN_YES_YES_WITH_CC
                   // One or more combining marks that do not combine-back:
                   // Check for canonical order, copy unchanged if ok and
                   // if followed by a character with a boundary-before.
                    int cc = GetCCFromNormalYesOrMaybe(norm16);  // cc!=0
                    if (onlyContiguous /* FCC */ && GetPreviousTrailCC(s, prevBoundary, prevSrc) > cc)
                    {
                        // Fails FCD test, need to decompose and contiguously recompose.
                        if (!doCompose)
                        {
                            return false;
                        }
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        int n16;
                        for (; ; )
                        {
                            if (src == limit)
                            {
                                if (doCompose)
                                {
                                    buffer.Append(s, prevBoundary, limit);
                                }
                                return true;
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            n16 = normTrie.Get(c);
                            if (n16 >= MIN_YES_YES_WITH_CC)
                            {
                                cc = GetCCFromNormalYesOrMaybe(n16);
                                if (prevCC > cc)
                                {
                                    if (!doCompose)
                                    {
                                        return false;
                                    }
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // p is after the last in-order combining mark.
                        // If there is a boundary here, then we continue with no change.
                        if (Norm16HasCompBoundaryBefore(n16))
                        {
                            if (IsCompYesAndZeroCC(n16))
                            {
                                src += Character.CharCount(c);
                            }
                            continue;
                        }
                        // Use the slow path. There is no boundary in [prevSrc, src[.
                    }
                }

                // Slow path: Find the nearest boundaries around the current character,
                // decompose and recompose.
                if (prevBoundary != prevSrc && !Norm16HasCompBoundaryBefore(norm16))
                {
                    c = Character.CodePointBefore(s, prevSrc);
                    norm16 = normTrie.Get(c);
                    if (!Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                    {
                        prevSrc -= Character.CharCount(c);
                    }
                }
                if (doCompose && prevBoundary != prevSrc)
                {
                    buffer.Append(s, prevBoundary, prevSrc);
                }
                int recomposeStartIndex = buffer.Length;
                // We know there is not a boundary here.
                DecomposeShort(s, prevSrc, src, false /* !stopAtCompBoundary */, onlyContiguous,
                               buffer);
                // Decompose until the next boundary.
                src = DecomposeShort(s, src, limit, true /* stopAtCompBoundary */, onlyContiguous,
                                     buffer);
                Recompose(buffer, recomposeStartIndex, onlyContiguous);
                if (!doCompose)
                {
                    if (!buffer.Equals(s, prevSrc, src))
                    {
                        return false;
                    }
                    buffer.Remove();
                }
                prevBoundary = src;
            }
        }

        /// <summary>
        /// Very similar to Compose(): Make the same changes in both places if relevant.
        /// doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
        /// !doSpan: QuickCheck
        /// </summary>
        /// <returns>
        /// bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
        /// bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
        /// then the quick check result is "no"
        /// </returns>
        public int ComposeQuickCheck(string s, int src, int limit,
            bool onlyContiguous, bool doSpan)
        {
            int qcResult = 0;
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        return (src << 1) | qcResult;  // "yes" or "maybe"
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                int prevNorm16 = INERT;
                if (prevBoundary != prevSrc)
                {
                    prevBoundary = prevSrc;
                    if (!Norm16HasCompBoundaryBefore(norm16))
                    {
                        c = Character.CodePointBefore(s, prevSrc);
                        int n16 = GetNorm16(c);
                        if (!Norm16HasCompBoundaryAfter(n16, onlyContiguous))
                        {
                            prevBoundary -= Character.CharCount(c);
                            prevNorm16 = n16;
                        }
                    }
                }

                if (IsMaybeOrNonZeroCC(norm16))
                {
                    int cc = GetCCFromYesOrMaybe(norm16);
                    if (onlyContiguous /* FCC */ && cc != 0 &&
                            GetTrailCCFromCompYesAndZeroCC(prevNorm16) > cc)
                    {
                        // The [prevBoundary..prevSrc[ character
                        // passed the quick check "yes && ccc==0" test
                        // but is out of canonical order with the current combining mark.
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        for (; ; )
                        {
                            if (norm16 < MIN_YES_YES_WITH_CC)
                            {
                                if (!doSpan)
                                {
                                    qcResult = 1;
                                }
                                else
                                {
                                    return prevBoundary << 1;  // spanYes does not care to know it's "maybe"
                                }
                            }
                            if (src == limit)
                            {
                                return (src << 1) | qcResult;  // "yes" or "maybe"
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            norm16 = GetNorm16(c);
                            if (IsMaybeOrNonZeroCC(norm16))
                            {
                                cc = GetCCFromYesOrMaybe(norm16);
                                if (!(prevCC <= cc || cc == 0))
                                {
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // src is after the last in-order combining mark.
                        if (IsCompYesAndZeroCC(norm16))
                        {
                            prevBoundary = src;
                            src += Character.CharCount(c);
                            continue;
                        }
                    }
                }
                return prevBoundary << 1;  // "no"
            }
        }

        /// <summary>
        /// Very similar to Compose(): Make the same changes in both places if relevant.
        /// doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
        /// !doSpan: QuickCheck
        /// </summary>
        /// <returns>
        /// bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
        /// bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
        /// then the quick check result is "no"
        /// </returns>
        public int ComposeQuickCheck(StringBuilder s, int src, int limit,
            bool onlyContiguous, bool doSpan)
        {
            int qcResult = 0;
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        return (src << 1) | qcResult;  // "yes" or "maybe"
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                int prevNorm16 = INERT;
                if (prevBoundary != prevSrc)
                {
                    prevBoundary = prevSrc;
                    if (!Norm16HasCompBoundaryBefore(norm16))
                    {
                        c = Character.CodePointBefore(s, prevSrc);
                        int n16 = GetNorm16(c);
                        if (!Norm16HasCompBoundaryAfter(n16, onlyContiguous))
                        {
                            prevBoundary -= Character.CharCount(c);
                            prevNorm16 = n16;
                        }
                    }
                }

                if (IsMaybeOrNonZeroCC(norm16))
                {
                    int cc = GetCCFromYesOrMaybe(norm16);
                    if (onlyContiguous /* FCC */ && cc != 0 &&
                            GetTrailCCFromCompYesAndZeroCC(prevNorm16) > cc)
                    {
                        // The [prevBoundary..prevSrc[ character
                        // passed the quick check "yes && ccc==0" test
                        // but is out of canonical order with the current combining mark.
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        for (; ; )
                        {
                            if (norm16 < MIN_YES_YES_WITH_CC)
                            {
                                if (!doSpan)
                                {
                                    qcResult = 1;
                                }
                                else
                                {
                                    return prevBoundary << 1;  // spanYes does not care to know it's "maybe"
                                }
                            }
                            if (src == limit)
                            {
                                return (src << 1) | qcResult;  // "yes" or "maybe"
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            norm16 = GetNorm16(c);
                            if (IsMaybeOrNonZeroCC(norm16))
                            {
                                cc = GetCCFromYesOrMaybe(norm16);
                                if (!(prevCC <= cc || cc == 0))
                                {
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // src is after the last in-order combining mark.
                        if (IsCompYesAndZeroCC(norm16))
                        {
                            prevBoundary = src;
                            src += Character.CharCount(c);
                            continue;
                        }
                    }
                }
                return prevBoundary << 1;  // "no"
            }
        }

        /// <summary>
        /// Very similar to Compose(): Make the same changes in both places if relevant.
        /// doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
        /// !doSpan: QuickCheck
        /// </summary>
        /// <returns>
        /// bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
        /// bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
        /// then the quick check result is "no"
        /// </returns>
        public int ComposeQuickCheck(char[] s, int src, int limit,
            bool onlyContiguous, bool doSpan)
        {
            int qcResult = 0;
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        return (src << 1) | qcResult;  // "yes" or "maybe"
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                int prevNorm16 = INERT;
                if (prevBoundary != prevSrc)
                {
                    prevBoundary = prevSrc;
                    if (!Norm16HasCompBoundaryBefore(norm16))
                    {
                        c = Character.CodePointBefore(s, prevSrc);
                        int n16 = GetNorm16(c);
                        if (!Norm16HasCompBoundaryAfter(n16, onlyContiguous))
                        {
                            prevBoundary -= Character.CharCount(c);
                            prevNorm16 = n16;
                        }
                    }
                }

                if (IsMaybeOrNonZeroCC(norm16))
                {
                    int cc = GetCCFromYesOrMaybe(norm16);
                    if (onlyContiguous /* FCC */ && cc != 0 &&
                            GetTrailCCFromCompYesAndZeroCC(prevNorm16) > cc)
                    {
                        // The [prevBoundary..prevSrc[ character
                        // passed the quick check "yes && ccc==0" test
                        // but is out of canonical order with the current combining mark.
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        for (; ; )
                        {
                            if (norm16 < MIN_YES_YES_WITH_CC)
                            {
                                if (!doSpan)
                                {
                                    qcResult = 1;
                                }
                                else
                                {
                                    return prevBoundary << 1;  // spanYes does not care to know it's "maybe"
                                }
                            }
                            if (src == limit)
                            {
                                return (src << 1) | qcResult;  // "yes" or "maybe"
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            norm16 = GetNorm16(c);
                            if (IsMaybeOrNonZeroCC(norm16))
                            {
                                cc = GetCCFromYesOrMaybe(norm16);
                                if (!(prevCC <= cc || cc == 0))
                                {
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // src is after the last in-order combining mark.
                        if (IsCompYesAndZeroCC(norm16))
                        {
                            prevBoundary = src;
                            src += Character.CharCount(c);
                            continue;
                        }
                    }
                }
                return prevBoundary << 1;  // "no"
            }
        }

        /// <summary>
        /// Very similar to Compose(): Make the same changes in both places if relevant.
        /// doSpan: SpanQuickCheckYes (ignore bit 0 of the return value)
        /// !doSpan: QuickCheck
        /// </summary>
        /// <returns>
        /// bits 31..1: SpanQuickCheckYes (==s.Length if "yes") and
        /// bit 0: set if "maybe"; otherwise, if the span length&lt;s.Length
        /// then the quick check result is "no"
        /// </returns>
        internal int ComposeQuickCheck(ICharSequence s, int src, int limit,
            bool onlyContiguous, bool doSpan)
        {
            int qcResult = 0;
            int prevBoundary = src;
            int minNoMaybeCP = minCompNoMaybeCP;

            for (; ; )
            {
                // Fast path: Scan over a sequence of characters below the minimum "no or maybe" code point,
                // or with (compYes && ccc==0) properties.
                int prevSrc;
                int c = 0;
                int norm16 = 0;
                for (; ; )
                {
                    if (src == limit)
                    {
                        return (src << 1) | qcResult;  // "yes" or "maybe"
                    }
                    if ((c = s[src]) < minNoMaybeCP ||
                        IsCompYesAndZeroCC(norm16 = normTrie.GetFromU16SingleLead((char)c))
                    )
                    {
                        ++src;
                    }
                    else
                    {
                        prevSrc = src++;
                        if (!UTF16.IsSurrogate((char)c))
                        {
                            break;
                        }
                        else
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if (src != limit && char.IsLowSurrogate(c2 = s[src]))
                                {
                                    ++src;
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevBoundary < prevSrc && char.IsHighSurrogate(c2 = s[prevSrc - 1]))
                                {
                                    --prevSrc;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                            if (!IsCompYesAndZeroCC(norm16 = GetNorm16(c)))
                            {
                                break;
                            }
                        }
                    }
                }
                // isCompYesAndZeroCC(norm16) is false, that is, norm16>=minNoNo.
                // The current character is either a "noNo" (has a mapping)
                // or a "maybeYes" (combines backward)
                // or a "yesYes" with ccc!=0.
                // It is not a Hangul syllable or Jamo L because those have "yes" properties.

                int prevNorm16 = INERT;
                if (prevBoundary != prevSrc)
                {
                    prevBoundary = prevSrc;
                    if (!Norm16HasCompBoundaryBefore(norm16))
                    {
                        c = Character.CodePointBefore(s, prevSrc);
                        int n16 = GetNorm16(c);
                        if (!Norm16HasCompBoundaryAfter(n16, onlyContiguous))
                        {
                            prevBoundary -= Character.CharCount(c);
                            prevNorm16 = n16;
                        }
                    }
                }

                if (IsMaybeOrNonZeroCC(norm16))
                {
                    int cc = GetCCFromYesOrMaybe(norm16);
                    if (onlyContiguous /* FCC */ && cc != 0 &&
                            GetTrailCCFromCompYesAndZeroCC(prevNorm16) > cc)
                    {
                        // The [prevBoundary..prevSrc[ character
                        // passed the quick check "yes && ccc==0" test
                        // but is out of canonical order with the current combining mark.
                    }
                    else
                    {
                        // If !onlyContiguous (not FCC), then we ignore the tccc of
                        // the previous character which passed the quick check "yes && ccc==0" test.
                        for (; ; )
                        {
                            if (norm16 < MIN_YES_YES_WITH_CC)
                            {
                                if (!doSpan)
                                {
                                    qcResult = 1;
                                }
                                else
                                {
                                    return prevBoundary << 1;  // spanYes does not care to know it's "maybe"
                                }
                            }
                            if (src == limit)
                            {
                                return (src << 1) | qcResult;  // "yes" or "maybe"
                            }
                            int prevCC = cc;
                            c = Character.CodePointAt(s, src);
                            norm16 = GetNorm16(c);
                            if (IsMaybeOrNonZeroCC(norm16))
                            {
                                cc = GetCCFromYesOrMaybe(norm16);
                                if (!(prevCC <= cc || cc == 0))
                                {
                                    break;
                                }
                            }
                            else
                            {
                                break;
                            }
                            src += Character.CharCount(c);
                        }
                        // src is after the last in-order combining mark.
                        if (IsCompYesAndZeroCC(norm16))
                        {
                            prevBoundary = src;
                            src += Character.CharCount(c);
                            continue;
                        }
                    }
                }
                return prevBoundary << 1;  // "no"
            }
        }

        public void ComposeAndAppend(string s,
            bool doCompose,
            bool onlyContiguous,
            ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstStarterInSrc = FindNextCompBoundary(s, 0, limit, onlyContiguous);
                if (0 != firstStarterInSrc)
                {
                    int lastStarterInDest = FindPreviousCompBoundary(buffer.StringBuilder,
                                                                   buffer.Length, onlyContiguous);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastStarterInDest) +
                                                           firstStarterInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastStarterInDest, buffer.Length - lastStarterInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastStarterInDest);
                    middle.Append(s, 0, firstStarterInSrc - 0);
                    Compose(middle, 0, middle.Length, onlyContiguous, true, buffer);
                    src = firstStarterInSrc;
                }
            }
            if (doCompose)
            {
                Compose(s, src, limit, onlyContiguous, true, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        public void ComposeAndAppend(StringBuilder s,
            bool doCompose,
            bool onlyContiguous,
            ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstStarterInSrc = FindNextCompBoundary(s, 0, limit, onlyContiguous);
                if (0 != firstStarterInSrc)
                {
                    int lastStarterInDest = FindPreviousCompBoundary(buffer.StringBuilder,
                                                                   buffer.Length, onlyContiguous);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastStarterInDest) +
                                                           firstStarterInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastStarterInDest, buffer.Length - lastStarterInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastStarterInDest);
                    middle.Append(s, 0, firstStarterInSrc - 0);
                    Compose(middle, 0, middle.Length, onlyContiguous, true, buffer);
                    src = firstStarterInSrc;
                }
            }
            if (doCompose)
            {
                Compose(s, src, limit, onlyContiguous, true, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        public void ComposeAndAppend(char[] s,
            bool doCompose,
            bool onlyContiguous,
            ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstStarterInSrc = FindNextCompBoundary(s, 0, limit, onlyContiguous);
                if (0 != firstStarterInSrc)
                {
                    int lastStarterInDest = FindPreviousCompBoundary(buffer.StringBuilder,
                                                                   buffer.Length, onlyContiguous);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastStarterInDest) +
                                                           firstStarterInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastStarterInDest, buffer.Length - lastStarterInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastStarterInDest);
                    middle.Append(s, 0, firstStarterInSrc - 0);
                    Compose(middle, 0, middle.Length, onlyContiguous, true, buffer);
                    src = firstStarterInSrc;
                }
            }
            if (doCompose)
            {
                Compose(s, src, limit, onlyContiguous, true, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        internal void ComposeAndAppend(ICharSequence s,
            bool doCompose,
            bool onlyContiguous,
            ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstStarterInSrc = FindNextCompBoundary(s, 0, limit, onlyContiguous);
                if (0 != firstStarterInSrc)
                {
                    int lastStarterInDest = FindPreviousCompBoundary(buffer.StringBuilder,
                                                                   buffer.Length, onlyContiguous);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastStarterInDest) +
                                                           firstStarterInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastStarterInDest, buffer.Length - lastStarterInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastStarterInDest);
                    middle.Append(s, 0, firstStarterInSrc - 0);
                    Compose(middle, 0, middle.Length, onlyContiguous, true, buffer);
                    src = firstStarterInSrc;
                }
            }
            if (doCompose)
            {
                Compose(s, src, limit, onlyContiguous, true, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        public int MakeFCD(string s, int src, int limit, ReorderingBuffer buffer)
        {
            // Note: In this function we use buffer->appendZeroCC() because we track
            // the lead and trail combining classes here, rather than leaving it to
            // the ReorderingBuffer.
            // The exception is the call to decomposeShort() which uses the buffer
            // in the normal way.

            // Tracks the last FCD-safe boundary, before lccc=0 or after properly-ordered tccc<=1.
            // Similar to the prevBoundary in the compose() implementation.
            int prevBoundary = src;
            int prevSrc;
            int c = 0;
            int prevFCD16 = 0;
            int fcd16 = 0;

            for (; ; )
            {
                // count code units with lccc==0
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minLcccCP)
                    {
                        prevFCD16 = ~c;
                        ++src;
                    }
                    else if (!SingleLeadMightHaveNonZeroFCD16(c))
                    {
                        prevFCD16 = 0;
                        ++src;
                    }
                    else
                    {
                        if (UTF16.IsSurrogate((char)c))
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                                {
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                                {
                                    --src;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                        }
                        if ((fcd16 = GetFCD16FromNormData(c)) <= 0xff)
                        {
                            prevFCD16 = fcd16;
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (src == limit)
                    {
                        if (buffer != null)
                        {
                            buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                        }
                        break;
                    }
                    prevBoundary = src;
                    // We know that the previous character's lccc==0.
                    if (prevFCD16 < 0)
                    {
                        // Fetching the fcd16 value was deferred for this below-minLcccCP code point.
                        int prev = ~prevFCD16;
                        if (prev < minDecompNoCP)
                        {
                            prevFCD16 = 0;
                        }
                        else
                        {
                            prevFCD16 = GetFCD16FromNormData(prev);
                            if (prevFCD16 > 1)
                            {
                                --prevBoundary;
                            }
                        }
                    }
                    else
                    {
                        int p = src - 1;
                        if (char.IsLowSurrogate(s[p]) && prevSrc < p &&
                            char.IsHighSurrogate(s[p - 1])
                        )
                        {
                            --p;
                            // Need to fetch the previous character's FCD value because
                            // prevFCD16 was just for the trail surrogate code point.
                            prevFCD16 = GetFCD16FromNormData(Character.ToCodePoint(s[p], s[p + 1]));
                            // Still known to have lccc==0 because its lead surrogate unit had lccc==0.
                        }
                        if (prevFCD16 > 1)
                        {
                            prevBoundary = p;
                        }
                    }
                    if (buffer != null)
                    {
                        // The last lccc==0 character is excluded from the
                        // flush-and-append call in case it needs to be modified.
                        buffer.FlushAndAppendZeroCC(s, prevSrc, prevBoundary);
                        buffer.Append(s, prevBoundary, src);
                    }
                    // The start of the current character (c).
                    prevSrc = src;
                }
                else if (src == limit)
                {
                    break;
                }

                src += Character.CharCount(c);
                // The current character (c) at [prevSrc..src[ has a non-zero lead combining class.
                // Check for proper order, and decompose locally if necessary.
                if ((prevFCD16 & 0xff) <= (fcd16 >> 8))
                {
                    // proper order: prev tccc <= current lccc
                    if ((fcd16 & 0xff) <= 1)
                    {
                        prevBoundary = src;
                    }
                    if (buffer != null)
                    {
                        buffer.AppendZeroCC(c);
                    }
                    prevFCD16 = fcd16;
                    continue;
                }
                else if (buffer == null)
                {
                    return prevBoundary;  // quick check "no"
                }
                else
                {
                    /*
                     * Back out the part of the source that we copied or appended
                     * already but is now going to be decomposed.
                     * prevSrc is set to after what was copied/appended.
                     */
                    buffer.RemoveSuffix(prevSrc - prevBoundary);
                    /*
                     * Find the part of the source that needs to be decomposed,
                     * up to the next safe boundary.
                     */
                    src = FindNextFCDBoundary(s, src, limit);
                    /*
                     * The source text does not fulfill the conditions for FCD.
                     * Decompose and reorder a limited piece of the text.
                     */
                    DecomposeShort(s, prevBoundary, src, false, false, buffer);
                    prevBoundary = src;
                    prevFCD16 = 0;
                }
            }
            return src;
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        public int MakeFCD(StringBuilder s, int src, int limit, ReorderingBuffer buffer)
        {
            // Note: In this function we use buffer->appendZeroCC() because we track
            // the lead and trail combining classes here, rather than leaving it to
            // the ReorderingBuffer.
            // The exception is the call to decomposeShort() which uses the buffer
            // in the normal way.

            // Tracks the last FCD-safe boundary, before lccc=0 or after properly-ordered tccc<=1.
            // Similar to the prevBoundary in the compose() implementation.
            int prevBoundary = src;
            int prevSrc;
            int c = 0;
            int prevFCD16 = 0;
            int fcd16 = 0;

            for (; ; )
            {
                // count code units with lccc==0
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minLcccCP)
                    {
                        prevFCD16 = ~c;
                        ++src;
                    }
                    else if (!SingleLeadMightHaveNonZeroFCD16(c))
                    {
                        prevFCD16 = 0;
                        ++src;
                    }
                    else
                    {
                        if (UTF16.IsSurrogate((char)c))
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                                {
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                                {
                                    --src;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                        }
                        if ((fcd16 = GetFCD16FromNormData(c)) <= 0xff)
                        {
                            prevFCD16 = fcd16;
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (src == limit)
                    {
                        if (buffer != null)
                        {
                            buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                        }
                        break;
                    }
                    prevBoundary = src;
                    // We know that the previous character's lccc==0.
                    if (prevFCD16 < 0)
                    {
                        // Fetching the fcd16 value was deferred for this below-minLcccCP code point.
                        int prev = ~prevFCD16;
                        if (prev < minDecompNoCP)
                        {
                            prevFCD16 = 0;
                        }
                        else
                        {
                            prevFCD16 = GetFCD16FromNormData(prev);
                            if (prevFCD16 > 1)
                            {
                                --prevBoundary;
                            }
                        }
                    }
                    else
                    {
                        int p = src - 1;
                        if (char.IsLowSurrogate(s[p]) && prevSrc < p &&
                            char.IsHighSurrogate(s[p - 1])
                        )
                        {
                            --p;
                            // Need to fetch the previous character's FCD value because
                            // prevFCD16 was just for the trail surrogate code point.
                            prevFCD16 = GetFCD16FromNormData(Character.ToCodePoint(s[p], s[p + 1]));
                            // Still known to have lccc==0 because its lead surrogate unit had lccc==0.
                        }
                        if (prevFCD16 > 1)
                        {
                            prevBoundary = p;
                        }
                    }
                    if (buffer != null)
                    {
                        // The last lccc==0 character is excluded from the
                        // flush-and-append call in case it needs to be modified.
                        buffer.FlushAndAppendZeroCC(s, prevSrc, prevBoundary);
                        buffer.Append(s, prevBoundary, src);
                    }
                    // The start of the current character (c).
                    prevSrc = src;
                }
                else if (src == limit)
                {
                    break;
                }

                src += Character.CharCount(c);
                // The current character (c) at [prevSrc..src[ has a non-zero lead combining class.
                // Check for proper order, and decompose locally if necessary.
                if ((prevFCD16 & 0xff) <= (fcd16 >> 8))
                {
                    // proper order: prev tccc <= current lccc
                    if ((fcd16 & 0xff) <= 1)
                    {
                        prevBoundary = src;
                    }
                    if (buffer != null)
                    {
                        buffer.AppendZeroCC(c);
                    }
                    prevFCD16 = fcd16;
                    continue;
                }
                else if (buffer == null)
                {
                    return prevBoundary;  // quick check "no"
                }
                else
                {
                    /*
                     * Back out the part of the source that we copied or appended
                     * already but is now going to be decomposed.
                     * prevSrc is set to after what was copied/appended.
                     */
                    buffer.RemoveSuffix(prevSrc - prevBoundary);
                    /*
                     * Find the part of the source that needs to be decomposed,
                     * up to the next safe boundary.
                     */
                    src = FindNextFCDBoundary(s, src, limit);
                    /*
                     * The source text does not fulfill the conditions for FCD.
                     * Decompose and reorder a limited piece of the text.
                     */
                    DecomposeShort(s, prevBoundary, src, false, false, buffer);
                    prevBoundary = src;
                    prevFCD16 = 0;
                }
            }
            return src;
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        public int MakeFCD(char[] s, int src, int limit, ReorderingBuffer buffer)
        {
            // Note: In this function we use buffer->appendZeroCC() because we track
            // the lead and trail combining classes here, rather than leaving it to
            // the ReorderingBuffer.
            // The exception is the call to decomposeShort() which uses the buffer
            // in the normal way.

            // Tracks the last FCD-safe boundary, before lccc=0 or after properly-ordered tccc<=1.
            // Similar to the prevBoundary in the compose() implementation.
            int prevBoundary = src;
            int prevSrc;
            int c = 0;
            int prevFCD16 = 0;
            int fcd16 = 0;

            for (; ; )
            {
                // count code units with lccc==0
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minLcccCP)
                    {
                        prevFCD16 = ~c;
                        ++src;
                    }
                    else if (!SingleLeadMightHaveNonZeroFCD16(c))
                    {
                        prevFCD16 = 0;
                        ++src;
                    }
                    else
                    {
                        if (UTF16.IsSurrogate((char)c))
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                                {
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                                {
                                    --src;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                        }
                        if ((fcd16 = GetFCD16FromNormData(c)) <= 0xff)
                        {
                            prevFCD16 = fcd16;
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (src == limit)
                    {
                        if (buffer != null)
                        {
                            buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                        }
                        break;
                    }
                    prevBoundary = src;
                    // We know that the previous character's lccc==0.
                    if (prevFCD16 < 0)
                    {
                        // Fetching the fcd16 value was deferred for this below-minLcccCP code point.
                        int prev = ~prevFCD16;
                        if (prev < minDecompNoCP)
                        {
                            prevFCD16 = 0;
                        }
                        else
                        {
                            prevFCD16 = GetFCD16FromNormData(prev);
                            if (prevFCD16 > 1)
                            {
                                --prevBoundary;
                            }
                        }
                    }
                    else
                    {
                        int p = src - 1;
                        if (char.IsLowSurrogate(s[p]) && prevSrc < p &&
                            char.IsHighSurrogate(s[p - 1])
                        )
                        {
                            --p;
                            // Need to fetch the previous character's FCD value because
                            // prevFCD16 was just for the trail surrogate code point.
                            prevFCD16 = GetFCD16FromNormData(Character.ToCodePoint(s[p], s[p + 1]));
                            // Still known to have lccc==0 because its lead surrogate unit had lccc==0.
                        }
                        if (prevFCD16 > 1)
                        {
                            prevBoundary = p;
                        }
                    }
                    if (buffer != null)
                    {
                        // The last lccc==0 character is excluded from the
                        // flush-and-append call in case it needs to be modified.
                        buffer.FlushAndAppendZeroCC(s, prevSrc, prevBoundary);
                        buffer.Append(s, prevBoundary, src);
                    }
                    // The start of the current character (c).
                    prevSrc = src;
                }
                else if (src == limit)
                {
                    break;
                }

                src += Character.CharCount(c);
                // The current character (c) at [prevSrc..src[ has a non-zero lead combining class.
                // Check for proper order, and decompose locally if necessary.
                if ((prevFCD16 & 0xff) <= (fcd16 >> 8))
                {
                    // proper order: prev tccc <= current lccc
                    if ((fcd16 & 0xff) <= 1)
                    {
                        prevBoundary = src;
                    }
                    if (buffer != null)
                    {
                        buffer.AppendZeroCC(c);
                    }
                    prevFCD16 = fcd16;
                    continue;
                }
                else if (buffer == null)
                {
                    return prevBoundary;  // quick check "no"
                }
                else
                {
                    /*
                     * Back out the part of the source that we copied or appended
                     * already but is now going to be decomposed.
                     * prevSrc is set to after what was copied/appended.
                     */
                    buffer.RemoveSuffix(prevSrc - prevBoundary);
                    /*
                     * Find the part of the source that needs to be decomposed,
                     * up to the next safe boundary.
                     */
                    src = FindNextFCDBoundary(s, src, limit);
                    /*
                     * The source text does not fulfill the conditions for FCD.
                     * Decompose and reorder a limited piece of the text.
                     */
                    DecomposeShort(s, prevBoundary, src, false, false, buffer);
                    prevBoundary = src;
                    prevFCD16 = 0;
                }
            }
            return src;
        }

        // Dual functionality:
        // buffer!=NULL: normalize
        // buffer==NULL: isNormalized/quickCheck/spanQuickCheckYes
        internal int MakeFCD(ICharSequence s, int src, int limit, ReorderingBuffer buffer)
        {
            // Note: In this function we use buffer->appendZeroCC() because we track
            // the lead and trail combining classes here, rather than leaving it to
            // the ReorderingBuffer.
            // The exception is the call to decomposeShort() which uses the buffer
            // in the normal way.

            // Tracks the last FCD-safe boundary, before lccc=0 or after properly-ordered tccc<=1.
            // Similar to the prevBoundary in the compose() implementation.
            int prevBoundary = src;
            int prevSrc;
            int c = 0;
            int prevFCD16 = 0;
            int fcd16 = 0;

            for (; ; )
            {
                // count code units with lccc==0
                for (prevSrc = src; src != limit;)
                {
                    if ((c = s[src]) < minLcccCP)
                    {
                        prevFCD16 = ~c;
                        ++src;
                    }
                    else if (!SingleLeadMightHaveNonZeroFCD16(c))
                    {
                        prevFCD16 = 0;
                        ++src;
                    }
                    else
                    {
                        if (UTF16.IsSurrogate((char)c))
                        {
                            char c2;
                            if (UTF16Plus.IsSurrogateLead(c))
                            {
                                if ((src + 1) != limit && char.IsLowSurrogate(c2 = s[src + 1]))
                                {
                                    c = Character.ToCodePoint((char)c, c2);
                                }
                            }
                            else /* trail surrogate */
                            {
                                if (prevSrc < src && char.IsHighSurrogate(c2 = s[src - 1]))
                                {
                                    --src;
                                    c = Character.ToCodePoint(c2, (char)c);
                                }
                            }
                        }
                        if ((fcd16 = GetFCD16FromNormData(c)) <= 0xff)
                        {
                            prevFCD16 = fcd16;
                            src += Character.CharCount(c);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
                // copy these code units all at once
                if (src != prevSrc)
                {
                    if (src == limit)
                    {
                        if (buffer != null)
                        {
                            buffer.FlushAndAppendZeroCC(s, prevSrc, src);
                        }
                        break;
                    }
                    prevBoundary = src;
                    // We know that the previous character's lccc==0.
                    if (prevFCD16 < 0)
                    {
                        // Fetching the fcd16 value was deferred for this below-minLcccCP code point.
                        int prev = ~prevFCD16;
                        if (prev < minDecompNoCP)
                        {
                            prevFCD16 = 0;
                        }
                        else
                        {
                            prevFCD16 = GetFCD16FromNormData(prev);
                            if (prevFCD16 > 1)
                            {
                                --prevBoundary;
                            }
                        }
                    }
                    else
                    {
                        int p = src - 1;
                        if (char.IsLowSurrogate(s[p]) && prevSrc < p &&
                            char.IsHighSurrogate(s[p - 1])
                        )
                        {
                            --p;
                            // Need to fetch the previous character's FCD value because
                            // prevFCD16 was just for the trail surrogate code point.
                            prevFCD16 = GetFCD16FromNormData(Character.ToCodePoint(s[p], s[p + 1]));
                            // Still known to have lccc==0 because its lead surrogate unit had lccc==0.
                        }
                        if (prevFCD16 > 1)
                        {
                            prevBoundary = p;
                        }
                    }
                    if (buffer != null)
                    {
                        // The last lccc==0 character is excluded from the
                        // flush-and-append call in case it needs to be modified.
                        buffer.FlushAndAppendZeroCC(s, prevSrc, prevBoundary);
                        buffer.Append(s, prevBoundary, src);
                    }
                    // The start of the current character (c).
                    prevSrc = src;
                }
                else if (src == limit)
                {
                    break;
                }

                src += Character.CharCount(c);
                // The current character (c) at [prevSrc..src[ has a non-zero lead combining class.
                // Check for proper order, and decompose locally if necessary.
                if ((prevFCD16 & 0xff) <= (fcd16 >> 8))
                {
                    // proper order: prev tccc <= current lccc
                    if ((fcd16 & 0xff) <= 1)
                    {
                        prevBoundary = src;
                    }
                    if (buffer != null)
                    {
                        buffer.AppendZeroCC(c);
                    }
                    prevFCD16 = fcd16;
                    continue;
                }
                else if (buffer == null)
                {
                    return prevBoundary;  // quick check "no"
                }
                else
                {
                    /*
                     * Back out the part of the source that we copied or appended
                     * already but is now going to be decomposed.
                     * prevSrc is set to after what was copied/appended.
                     */
                    buffer.RemoveSuffix(prevSrc - prevBoundary);
                    /*
                     * Find the part of the source that needs to be decomposed,
                     * up to the next safe boundary.
                     */
                    src = FindNextFCDBoundary(s, src, limit);
                    /*
                     * The source text does not fulfill the conditions for FCD.
                     * Decompose and reorder a limited piece of the text.
                     */
                    DecomposeShort(s, prevBoundary, src, false, false, buffer);
                    prevBoundary = src;
                    prevFCD16 = 0;
                }
            }
            return src;
        }

        public void MakeFCDAndAppend(string s, bool doMakeFCD, ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstBoundaryInSrc = FindNextFCDBoundary(s, 0, limit);
                if (0 != firstBoundaryInSrc)
                {
                    int lastBoundaryInDest = FindPreviousFCDBoundary(buffer.StringBuilder,
                                                                   buffer.Length);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastBoundaryInDest) +
                                                           firstBoundaryInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastBoundaryInDest, buffer.Length - lastBoundaryInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastBoundaryInDest);
                    middle.Append(s, 0, firstBoundaryInSrc - 0);
                    MakeFCD(middle, 0, middle.Length, buffer);
                    src = firstBoundaryInSrc;
                }
            }
            if (doMakeFCD)
            {
                MakeFCD(s, src, limit, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        public void MakeFCDAndAppend(StringBuilder s, bool doMakeFCD, ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstBoundaryInSrc = FindNextFCDBoundary(s, 0, limit);
                if (0 != firstBoundaryInSrc)
                {
                    int lastBoundaryInDest = FindPreviousFCDBoundary(buffer.StringBuilder,
                                                                   buffer.Length);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastBoundaryInDest) +
                                                           firstBoundaryInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastBoundaryInDest, buffer.Length - lastBoundaryInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastBoundaryInDest);
                    middle.Append(s, 0, firstBoundaryInSrc - 0);
                    MakeFCD(middle, 0, middle.Length, buffer);
                    src = firstBoundaryInSrc;
                }
            }
            if (doMakeFCD)
            {
                MakeFCD(s, src, limit, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        public void MakeFCDAndAppend(char[] s, bool doMakeFCD, ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstBoundaryInSrc = FindNextFCDBoundary(s, 0, limit);
                if (0 != firstBoundaryInSrc)
                {
                    int lastBoundaryInDest = FindPreviousFCDBoundary(buffer.StringBuilder,
                                                                   buffer.Length);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastBoundaryInDest) +
                                                           firstBoundaryInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastBoundaryInDest, buffer.Length - lastBoundaryInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastBoundaryInDest);
                    middle.Append(s, 0, firstBoundaryInSrc - 0);
                    MakeFCD(middle, 0, middle.Length, buffer);
                    src = firstBoundaryInSrc;
                }
            }
            if (doMakeFCD)
            {
                MakeFCD(s, src, limit, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }

        internal void MakeFCDAndAppend(ICharSequence s, bool doMakeFCD, ReorderingBuffer buffer)
        {
            int src = 0, limit = s.Length;
            if (!buffer.IsEmpty)
            {
                int firstBoundaryInSrc = FindNextFCDBoundary(s, 0, limit);
                if (0 != firstBoundaryInSrc)
                {
                    int lastBoundaryInDest = FindPreviousFCDBoundary(buffer.StringBuilder,
                                                                   buffer.Length);
                    StringBuilder middle = new StringBuilder((buffer.Length - lastBoundaryInDest) +
                                                           firstBoundaryInSrc + 16);
                    middle.Append(buffer.StringBuilder, lastBoundaryInDest, buffer.Length - lastBoundaryInDest); // ICU4N : Fixed 3rd parameter
                    buffer.RemoveSuffix(buffer.Length - lastBoundaryInDest);
                    middle.Append(s, 0, firstBoundaryInSrc - 0);
                    MakeFCD(middle, 0, middle.Length, buffer);
                    src = firstBoundaryInSrc;
                }
            }
            if (doMakeFCD)
            {
                MakeFCD(s, src, limit, buffer);
            }
            else
            {
                buffer.Append(s, src, limit);
            }
        }



        // Decompose a short piece of text which is likely to contain characters that
        // fail the quick check loop and/or where the quick check loop's overhead
        // is unlikely to be amortized.
        // Called by the Compose() and MakeFCD() implementations.
        // Public in .NET for collation implementation code.
        private int DecomposeShort(
                string s, int src, int limit,
                bool stopAtCompBoundary, bool onlyContiguous,
                ReorderingBuffer buffer)
        {
            while (src < limit)
            {
                int c = Character.CodePointAt(s, src);
                if (stopAtCompBoundary && c < minCompNoMaybeCP)
                {
                    return src;
                }
                int norm16 = GetNorm16(c);
                if (stopAtCompBoundary && Norm16HasCompBoundaryBefore(norm16))
                {
                    return src;
                }
                src += Character.CharCount(c);
                Decompose(c, norm16, buffer);
                if (stopAtCompBoundary && Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    return src;
                }
            }
            return src;
        }

        // Decompose a short piece of text which is likely to contain characters that
        // fail the quick check loop and/or where the quick check loop's overhead
        // is unlikely to be amortized.
        // Called by the Compose() and MakeFCD() implementations.
        // Public in .NET for collation implementation code.
        private int DecomposeShort(
                StringBuilder s, int src, int limit,
                bool stopAtCompBoundary, bool onlyContiguous,
                ReorderingBuffer buffer)
        {
            while (src < limit)
            {
                int c = Character.CodePointAt(s, src);
                if (stopAtCompBoundary && c < minCompNoMaybeCP)
                {
                    return src;
                }
                int norm16 = GetNorm16(c);
                if (stopAtCompBoundary && Norm16HasCompBoundaryBefore(norm16))
                {
                    return src;
                }
                src += Character.CharCount(c);
                Decompose(c, norm16, buffer);
                if (stopAtCompBoundary && Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    return src;
                }
            }
            return src;
        }

        // Decompose a short piece of text which is likely to contain characters that
        // fail the quick check loop and/or where the quick check loop's overhead
        // is unlikely to be amortized.
        // Called by the Compose() and MakeFCD() implementations.
        // Public in .NET for collation implementation code.
        private int DecomposeShort(
                char[] s, int src, int limit,
                bool stopAtCompBoundary, bool onlyContiguous,
                ReorderingBuffer buffer)
        {
            while (src < limit)
            {
                int c = Character.CodePointAt(s, src);
                if (stopAtCompBoundary && c < minCompNoMaybeCP)
                {
                    return src;
                }
                int norm16 = GetNorm16(c);
                if (stopAtCompBoundary && Norm16HasCompBoundaryBefore(norm16))
                {
                    return src;
                }
                src += Character.CharCount(c);
                Decompose(c, norm16, buffer);
                if (stopAtCompBoundary && Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    return src;
                }
            }
            return src;
        }

        // Decompose a short piece of text which is likely to contain characters that
        // fail the quick check loop and/or where the quick check loop's overhead
        // is unlikely to be amortized.
        // Called by the Compose() and MakeFCD() implementations.
        // Public in .NET for collation implementation code.
        private int DecomposeShort(
                ICharSequence s, int src, int limit,
                bool stopAtCompBoundary, bool onlyContiguous,
                ReorderingBuffer buffer)
        {
            while (src < limit)
            {
                int c = Character.CodePointAt(s, src);
                if (stopAtCompBoundary && c < minCompNoMaybeCP)
                {
                    return src;
                }
                int norm16 = GetNorm16(c);
                if (stopAtCompBoundary && Norm16HasCompBoundaryBefore(norm16))
                {
                    return src;
                }
                src += Character.CharCount(c);
                Decompose(c, norm16, buffer);
                if (stopAtCompBoundary && Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    return src;
                }
            }
            return src;
        }



        private bool HasCompBoundaryBefore(string s, int src, int limit)
        {
            return src == limit || HasCompBoundaryBefore(Character.CodePointAt(s, src));
        }

        private bool HasCompBoundaryBefore(StringBuilder s, int src, int limit)
        {
            return src == limit || HasCompBoundaryBefore(Character.CodePointAt(s, src));
        }

        private bool HasCompBoundaryBefore(char[] s, int src, int limit)
        {
            return src == limit || HasCompBoundaryBefore(Character.CodePointAt(s, src));
        }

        private bool HasCompBoundaryBefore(ICharSequence s, int src, int limit)
        {
            return src == limit || HasCompBoundaryBefore(Character.CodePointAt(s, src));
        }

        private bool HasCompBoundaryAfter(string s, int start, int p, bool onlyContiguous)
        {
            return start == p || HasCompBoundaryAfter(Character.CodePointBefore(s, p), onlyContiguous);
        }

        private bool HasCompBoundaryAfter(StringBuilder s, int start, int p, bool onlyContiguous)
        {
            return start == p || HasCompBoundaryAfter(Character.CodePointBefore(s, p), onlyContiguous);
        }

        private bool HasCompBoundaryAfter(char[] s, int start, int p, bool onlyContiguous)
        {
            return start == p || HasCompBoundaryAfter(Character.CodePointBefore(s, p), onlyContiguous);
        }

        private bool HasCompBoundaryAfter(ICharSequence s, int start, int p, bool onlyContiguous)
        {
            return start == p || HasCompBoundaryAfter(Character.CodePointBefore(s, p), onlyContiguous);
        }

        private int FindPreviousCompBoundary(string s, int p, bool onlyContiguous)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16 = GetNorm16(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousCompBoundary(StringBuilder s, int p, bool onlyContiguous)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16 = GetNorm16(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousCompBoundary(char[] s, int p, bool onlyContiguous)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16 = GetNorm16(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousCompBoundary(ICharSequence s, int p, bool onlyContiguous)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16 = GetNorm16(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextCompBoundary(string s, int p, int limit, bool onlyContiguous)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16 = normTrie.Get(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextCompBoundary(StringBuilder s, int p, int limit, bool onlyContiguous)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16 = normTrie.Get(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextCompBoundary(char[] s, int p, int limit, bool onlyContiguous)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16 = normTrie.Get(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextCompBoundary(ICharSequence s, int p, int limit, bool onlyContiguous)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16 = normTrie.Get(c);
                if (HasCompBoundaryBefore(c, norm16))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasCompBoundaryAfter(norm16, onlyContiguous))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousFCDBoundary(string s, int p)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16;
                if (c < minDecompNoCP || Norm16HasDecompBoundaryAfter(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (Norm16HasDecompBoundaryBefore(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousFCDBoundary(StringBuilder s, int p)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16;
                if (c < minDecompNoCP || Norm16HasDecompBoundaryAfter(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (Norm16HasDecompBoundaryBefore(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousFCDBoundary(char[] s, int p)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16;
                if (c < minDecompNoCP || Norm16HasDecompBoundaryAfter(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (Norm16HasDecompBoundaryBefore(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindPreviousFCDBoundary(ICharSequence s, int p)
        {
            while (p > 0)
            {
                int c = Character.CodePointBefore(s, p);
                int norm16;
                if (c < minDecompNoCP || Norm16HasDecompBoundaryAfter(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p -= Character.CharCount(c);
                if (Norm16HasDecompBoundaryBefore(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextFCDBoundary(string s, int p, int limit)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16;
                if (c < minLcccCP || Norm16HasDecompBoundaryBefore(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasDecompBoundaryAfter(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextFCDBoundary(StringBuilder s, int p, int limit)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16;
                if (c < minLcccCP || Norm16HasDecompBoundaryBefore(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasDecompBoundaryAfter(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextFCDBoundary(char[] s, int p, int limit)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16;
                if (c < minLcccCP || Norm16HasDecompBoundaryBefore(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasDecompBoundaryAfter(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int FindNextFCDBoundary(ICharSequence s, int p, int limit)
        {
            while (p < limit)
            {
                int c = Character.CodePointAt(s, p);
                int norm16;
                if (c < minLcccCP || Norm16HasDecompBoundaryBefore(norm16 = GetNorm16(c)))
                {
                    break;
                }
                p += Character.CharCount(c);
                if (Norm16HasDecompBoundaryAfter(norm16))
                {
                    break;
                }
            }
            return p;
        }

        private int GetPreviousTrailCC(string s, int start, int p)
        {
            if (start == p)
            {
                return 0;
            }
            return GetFCD16(Character.CodePointBefore(s, p));
        }

        private int GetPreviousTrailCC(StringBuilder s, int start, int p)
        {
            if (start == p)
            {
                return 0;
            }
            return GetFCD16(Character.CodePointBefore(s, p));
        }

        private int GetPreviousTrailCC(char[] s, int start, int p)
        {
            if (start == p)
            {
                return 0;
            }
            return GetFCD16(Character.CodePointBefore(s, p));
        }

        private int GetPreviousTrailCC(ICharSequence s, int start, int p)
        {
            if (start == p)
            {
                return 0;
            }
            return GetFCD16(Character.CodePointBefore(s, p));
        }
    }
}
