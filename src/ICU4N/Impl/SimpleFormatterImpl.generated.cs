//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Text;
using J2N.Text;
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Text;

namespace ICU4N.Impl
{
    public static partial class SimpleFormatterImpl
    {
        #region FormatCompiledPattern/TryFormatCompiledPattern

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <param name="value13">The fourteenth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <param name="value13">The fourteenth argument value.</param>
        /// <param name="value14">The fifteenth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <param name="value13">The fourteenth argument value.</param>
        /// <param name="value14">The fifteenth argument value.</param>
        /// <param name="value15">The sixteenth argument value.</param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static string FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }


        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value15">
        /// The sixteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        public static bool TryFormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, Span<char> destination, out int charsLength, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatCompiledPattern(compiledPattern, ref sb, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }


        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns, contains the formatted text.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value15">
        /// The sixteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatCompiledPattern(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder destination, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
            => FormatAndAppend(compiledPattern, ref destination, offsets: default, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);


        #endregion FormatCompiledPattern/TryFormatCompiledPattern

        #region FormatRawPattern/TryFormatRawPattern

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <param name="value13">The fourteenth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <param name="value13">The fourteenth argument value.</param>
        /// <param name="value14">The fifteenth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">The first argument value.</param>
        /// <param name="value1">The second argument value.</param>
        /// <param name="value2">The third argument value.</param>
        /// <param name="value3">The fourth argument value.</param>
        /// <param name="value4">The fifth argument value.</param>
        /// <param name="value5">The sixth argument value.</param>
        /// <param name="value6">The seventh argument value.</param>
        /// <param name="value7">The eighth argument value.</param>
        /// <param name="value8">The ninth argument value.</param>
        /// <param name="value9">The tenth argument value.</param>
        /// <param name="value10">The eleventh argument value.</param>
        /// <param name="value11">The twelveth argument value.</param>
        /// <param name="value12">The thirteenth argument value.</param>
        /// <param name="value13">The fourteenth argument value.</param>
        /// <param name="value14">The fifteenth argument value.</param>
        /// <param name="value15">The sixteenth argument value.</param>
        /// <returns>The formatted text.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static string FormatRawPattern(ReadOnlySpan<char> pattern, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
        {
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);
                return sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
        }


        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <param name="value15">
        /// The sixteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        public static bool TryFormatRawPattern(ReadOnlySpan<char> pattern, Span<char> destination, out int charsLength, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
        {
            ValueStringBuilder sb = new ValueStringBuilder(destination);
            try
            {
                FormatRawPattern(pattern, ref sb, min, max, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);
                return sb.FitsInitialBuffer(out charsLength);
            }
            finally
            {
                sb.Dispose();
            }
        }



        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }

        /// <summary>
        /// Formats the not-compiled pattern with the given values.
        /// Equivalent to <see cref="CompileToStringMinMaxArguments(ReadOnlySpan{Char}, int, int)"/> 
        /// followed by <see cref="FormatCompiledPattern(ReadOnlySpan{Char}, string[])"/>.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">Not-compiled form of a pattern string.</param>
        /// <param name="appendTo">The builder to append the formatted text to.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value15">
        /// The sixteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <exception cref="ArgumentException">for bad argument syntax and too few or too many arguments.</exception>
        internal static void FormatRawPattern(ReadOnlySpan<char> pattern, ref ValueStringBuilder appendTo, int min, int max, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
        {
            ValueStringBuilder compiledPattern = new ValueStringBuilder(stackalloc char[CharStackBufferSize]);
            try
            {
                CompileToStringMinMaxArguments(pattern, ref compiledPattern, min, max);
                FormatAndAppend(compiledPattern.AsSpan(), ref appendTo, offsets: null, value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15);
            }
            finally
            {
                compiledPattern.Dispose();
            }
        }


        #endregion FormatRawPattern/TryFormatRawPattern

        #region FormatAndAppend

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14));

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <param name="value15">
        /// The sixteenth argument value.
        /// An argument value must not be the same memory location as <paramref name="appendTo"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndAppend(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder appendTo, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
            => FormatAndAppend(compiledPattern, ref appendTo, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15));


        #endregion FormatAndAppend

        #region FormatAndReplace


        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14));

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="compiledPattern">Compiled form of a pattern string.</param>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// <c>offsets[i]</c> receives the offset of where
        /// <c>value</c><i><b>i</b></i> replaced pattern argument <c>{i}</c>.
        /// Can be <c>null</c>, or can be shorter or longer than values.
        /// If there is no <c>{i}</c> in the pattern, then <c>offsets[i]</c> is set to <c>-1</c>.
        /// </param>
        /// <param name="value0">
        /// The first argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value1">
        /// The second argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value2">
        /// The third argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value3">
        /// The fourth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value4">
        /// The fifth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value5">
        /// The sixth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value6">
        /// The seventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value7">
        /// The eighth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value8">
        /// The ninth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value9">
        /// The tenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value10">
        /// The eleventh argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value11">
        /// The twelveth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value12">
        /// The thirteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value13">
        /// The fourteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value14">
        /// The fifteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <param name="value15">
        /// The sixteenth argument value.
        /// An argument value may be the same memory location as <paramref name="result"/>.
        /// </param>
        /// <remarks>
        /// The number of values passed must be at least <see cref="GetArgumentLimit(ReadOnlySpan{Char})"/>
        /// with <paramref name="compiledPattern"/> as the argument.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void FormatAndReplace(scoped ReadOnlySpan<char> compiledPattern, ref ValueStringBuilder result, Span<int> offsets, ReadOnlySpan<char> value0, ReadOnlySpan<char> value1, ReadOnlySpan<char> value2, ReadOnlySpan<char> value3, ReadOnlySpan<char> value4, ReadOnlySpan<char> value5, ReadOnlySpan<char> value6, ReadOnlySpan<char> value7, ReadOnlySpan<char> value8, ReadOnlySpan<char> value9, ReadOnlySpan<char> value10, ReadOnlySpan<char> value11, ReadOnlySpan<char> value12, ReadOnlySpan<char> value13, ReadOnlySpan<char> value14, ReadOnlySpan<char> value15)
            => FormatAndReplace(compiledPattern, ref result, offsets, new ReadOnlySpanArray<char>(value0, value1, value2, value3, value4, value5, value6, value7, value8, value9, value10, value11, value12, value13, value14, value15));


        #endregion FormatAndReplace
    }
}
