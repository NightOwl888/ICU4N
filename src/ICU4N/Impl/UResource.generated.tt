<#@ output extension=".cs" #>
<#@ include file="../../../codegen/FilterDeclarations.tt" #>
<#
AppendableFilter = (a) => a.Name != "ValueStringBuilder";
string codeGenerationRelativePath = @"../../../codegen";
#><#@ include file="../../../codegen/DataLoader.tt" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class ResourceKey
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        private bool RegionMatches(int start, <#=charSequence#> cs, int n)
        {
<# if (charSequence.Name == "StringBuilder") { #>
            // ICU4N: Indexing StringBuilder is really slow,
            // so we convert to a substring and cascade the call.
            return RegionMatches(0, cs.ToString(start, n), n);
<# } else { #>
<# if (charSequence.Name == "ICharSequence") { #>
            if (cs is StringBuilderCharSequence stringBuilder)
            {
                if (!stringBuilder.HasValue) return false;
                // ICU4N: Indexing StringBuilder is really slow,
                // so we cascade the call.
                return RegionMatches(start, stringBuilder.Value, n);
            }
<# } #>
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        public bool ContentEquals(<#=charSequence#> cs)
        {
            if (cs == null)
            {
                return false;
            }
<# if (charSequence.Name == "ICharSequence") { #>
            if (this == cs)
            {
                return true;
            }
<# } #>
            return (cs.Length == length && RegionMatches(0, cs, length));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        public bool StartsWith(<#=charSequence#> cs)
        {
<# if (charSequence.IsNullable) { #>
            // ICU4N: Added guard clause
            if (cs is null)
                throw new ArgumentNullException(nameof(cs));

<# } #>
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        public bool EndsWith(<#=charSequence#> cs)
        {
<# if (charSequence.IsNullable) { #>
            // ICU4N: Added guard clause
            if (cs is null)
                throw new ArgumentNullException(nameof(cs));

<# } #>
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, <#=charSequence#> cs)
        {
<# if (charSequence.IsNullable) { #>
            // ICU4N: Added guard clause
            if (cs is null)
                throw new ArgumentNullException(nameof(cs));

<# } #>
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        public int CompareTo(<#=charSequence#> cs)
        {
<# if (charSequence.IsNullable) { #>
            if (cs is null) return 1; // ICU4N: Using 1 if other is null as specified here: https://stackoverflow.com/a/4852537
<# } #>
<# if (charSequence.Name == "StringBuilder") { #>
            // ICU4N: Indexing StringBuilder is really slow,
            // so we cascade the call.
            return CompareTo(cs.ToString());
<# } else { #>
<# if (charSequence.Name == "ICharSequence") { #>
            if (!cs.HasValue) return 1;
            if (cs is StringBuilderCharSequence stringBuilder)
            {
                return CompareTo(stringBuilder.Value);
            }
<# } #>

            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>

    }
}
<#@ include file="../../../codegen/SharedObjects.tt" #>