<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    XElement[] charSequenceElements = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Where(x => x.Value != "ValueStringBuilder").Select(x => x.Value).ToArray();

    string[] charSequences = new string[charSequenceElements.Length];
    string[] charSequenceForDocs = new string[charSequenceElements.Length];
    string[] charSequenceFeatures = new string[charSequenceElements.Length];

    for (int i = 0; i < charSequenceElements.Length; i++) {
        XElement charSequenceElement = charSequenceElements[i];
        charSequences[i] = charSequenceElement.Value;
        charSequenceForDocs[i] = charSequenceElement.Value.Replace("<", "{").Replace(">", "}");

        XAttribute[] featureAttributes = charSequenceElement.Attributes("feature").ToArray();
        charSequenceFeatures[i] = featureAttributes == null ? "" : (featureAttributes.Length > 0 ? featureAttributes[0].Value : "");
    }
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Impl
{
    public sealed partial class ResourceKey
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        private bool RegionMatches(int start, <#=charSequence#> cs, int n)
        {
<# if (charSequence == "StringBuilder") { #>
            // ICU4N: Indexing StringBuilder is really slow,
            // so we convert to a substring and cascade the call.
            return RegionMatches(0, cs.ToString(start, n), n);
<# } else { #>
<# if (charSequence == "ICharSequence") { #>
            //if (cs is StringBuilderCharSequence stringBuilder)
            //{
            //    if (!stringBuilder.HasValue) return false;
            //    // ICU4N: Indexing StringBuilder is really slow,
            //    // so we cascade the call.
            //    return RegionMatches(start, stringBuilder.Value, n);
            //}
<# } #>
            for (int i = 0; i < n; ++i)
            {
                if (bytes[offset + start + i] != cs[i])
                {
                    return false;
                }
            }
            return true;
<# } #>
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        public bool ContentEquals(<#=charSequence#> cs)
        {
            if (cs == null)
            {
                return false;
            }
<# if (charSequence == "ICharSequence") { #>
            if (this == cs)
            {
                return true;
            }
<# } #>
            return (cs.Length == length && RegionMatches(0, cs, length));
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        public bool StartsWith(<#=charSequence#> cs)
        {
<# if (charSequence != "ReadOnlySpan<char>") { #>
            // ICU4N: Added guard clause
            if (cs is null)
                throw new ArgumentNullException(nameof(cs));

<# } #>
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(0, cs, csLength);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        public bool EndsWith(<#=charSequence#> cs)
        {
<# if (charSequence != "ReadOnlySpan<char>") { #>
            // ICU4N: Added guard clause
            if (cs is null)
                throw new ArgumentNullException(nameof(cs));

<# } #>
            int csLength = cs.Length;
            return csLength <= length && RegionMatches(length - csLength, cs, csLength);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        /// <returns>true if the substring of this key starting from the offset
        /// contains the same characters as the other sequence.</returns>
        public bool RegionMatches(int start, <#=charSequence#> cs)
        {
<# if (charSequence != "ReadOnlySpan<char>") { #>
            // ICU4N: Added guard clause
            if (cs is null)
                throw new ArgumentNullException(nameof(cs));

<# } #>
            int csLength = cs.Length;
            return csLength == (length - start) && RegionMatches(start, cs, csLength);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        public int CompareTo(<#=charSequence#> cs)
        {
<# if (charSequence != "ReadOnlySpan<char>") { #>
            if (cs is null) return 1; // ICU4N: Using 1 if other is null as specified here: https://stackoverflow.com/a/4852537
<# } #>
<# if (charSequence == "StringBuilder") { #>
            // ICU4N: Indexing StringBuilder is really slow,
            // so we cascade the call.
            return CompareTo(cs.ToString());
<# } else { #>
<# if (charSequence == "ICharSequence") { #>
            if (!cs.HasValue) return 1;
            //if (cs is StringBuilderCharSequence stringBuilder)
            //{
            //    return CompareTo(stringBuilder.Value);
            //}
<# } #>

            int csLength = cs.Length;
            int minLength = length <= csLength ? length : csLength;
            for (int i = 0; i < minLength; ++i)
            {
                int diff = this[i] - cs[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return length - csLength;
<# } #>
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>

    }
}