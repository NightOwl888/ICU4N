<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    XElement[] charSequenceElements = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
    string appendableAccessibility = document.XPathSelectElement(@"//codeGen/appendableAccessibility").Value;

    string[] charSequences = new string[charSequenceElements.Length];
    string[] charSequenceForDocs = new string[charSequenceElements.Length];
    string[] charSequenceFeatures = new string[charSequenceElements.Length];

    for (int i = 0; i < charSequenceElements.Length; i++) {
        XElement charSequenceElement = charSequenceElements[i];
        charSequences[i] = charSequenceElement.Value;
        charSequenceForDocs[i] = charSequenceElement.Value.Replace("<", "{").Replace(">", "}");

        XAttribute[] featureAttributes = charSequenceElement.Attributes("feature").ToArray();
        charSequenceFeatures[i] = featureAttributes == null ? "" : (featureAttributes.Length > 0 ? featureAttributes[0].Value : "");
    }
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Support.Text;
using ICU4N.Text;
using ICU4N.Util;
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    // Normalizer2 implementation for the old UNORM_NONE.
    public sealed partial class NoopNormalizer2
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Normalize(<#=charSequence#> src, StringBuilder dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest == src)
<# } else if (charSequence=="ICharSequence") { #>
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            dest.Length = 0;
            return dest.Append(src);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : appendableAccessibility #> override IAppendable Normalize(<#=charSequence#> src, IAppendable dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
<# } else if (charSequence=="ICharSequence") { #>
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
            return first.Append(second.ToString());
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Append(StringBuilder first, <#=charSequence#> second)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
            return first.Append(second);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override bool IsNormalized(<#=charSequence#> s) { return true; }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override QuickCheckResult QuickCheck(<#=charSequence#> s) { return QuickCheckResult.Yes; }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s) { return s.Length; }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>

    }

    public abstract partial class Normalizer2WithImpl
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Normalize(<#=charSequence#> src, StringBuilder dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest == src)
<# } else if (charSequence=="ICharSequence") { #>
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            dest.Length = 0;
<# if (charSequence == "ReadOnlySpan<char>") { #>
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Length = 0;
                dest.Append(buffer.AsSpan());
            }
            finally
            {
                buffer.Dispose();
            }
<# } else { #>
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
<# } #>
            return dest;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : appendableAccessibility #> override IAppendable Normalize(<#=charSequence#> src, IAppendable dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
<# } else if (charSequence=="ICharSequence") { #>
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
<# if (charSequence == "ReadOnlySpan<char>") { #>
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Append(buffer.AsSpan());
                buffer.Flush();
            }
            finally
            {
                buffer.Dispose();
            }
<# } else { #>
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
<# } #>
            return dest;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> abstract void Normalize(<#=charSequence#> src, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer);
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Append(StringBuilder first, <#=charSequence#> second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second, bool doNormalize)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
<# if (charSequence == "ReadOnlySpan<char>") { #>
            int length = first.Length + second.Length;
            var sb = length <= CharStackBufferSize
                ? new ValueStringBuilder(stackalloc char[CharStackBufferSize])
                : new ValueStringBuilder(length);
            try
            {
                sb.Append(first);
                var buffer = new ValueReorderingBuffer(Impl, ref sb, length);
                NormalizeAndAppend(second, doNormalize, ref buffer);
                first.Length = 0;
                first.Append(buffer.AsSpan());
            }
            finally
            {
                sb.Dispose();
            }
<# } else { #>
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
<# } #>
            return first;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> abstract void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer);
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override bool IsNormalized(<#=charSequence#> s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override QuickCheckResult QuickCheck(<#=charSequence#> s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
    }

    public sealed partial class DecomposeNormalizer2
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void Normalize(<#=charSequence#> src, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
<# if(charSequence == "ReadOnlySpan<char>") { #>
            Impl.Decompose(src, ref buffer);
<# } else { #>
            Impl.Decompose(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void NormalizeAndAppend(<#=charSequence#> src, bool doNormalize, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, <#=charSequence == "ReadOnlySpan<char>" ? "ref " : ""#>buffer);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.DecomposeQuickCheck(s<#=charSequence != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
    }

    public sealed partial class ComposeNormalizer2
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void Normalize(<#=charSequence#> src, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
<# if (charSequence == "ReadOnlySpan<char>") { #>
            Impl.Compose(src, onlyContiguous, true, ref buffer);
<# } else { #>
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, <#=charSequence == "ReadOnlySpan<char>" ? "ref " : ""#>buffer);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override bool IsNormalized(<#=charSequence#> s)
        {
            // 5: small destCapacity for substring normalization
<# if (charSequence == "ReadOnlySpan<char>") { #>
            var buffer = new ValueReorderingBuffer(Impl, stackalloc char[5]);
            try
            {
                return Impl.Compose(s, onlyContiguous, false, ref buffer);
            }
            finally
            {
                buffer.Dispose();
            }
<# } else { #>
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5)); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override QuickCheckResult QuickCheck(<#=charSequence#> s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s<#=charSequence != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.ComposeQuickCheck(s<#=charSequence != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>

    }

    public sealed partial class FCDNormalizer2
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void Normalize(<#=charSequence#> src, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
<# if (charSequence == "ReadOnlySpan<char>") { #>
            Impl.MakeFCD(src, ref buffer);
<# } else { #>
            Impl.MakeFCD(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, <#=charSequence == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, <#=charSequence == "ReadOnlySpan<char>" ? "ref " : ""#>buffer);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.MakeFCDQuickCheck(s<#=charSequence != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>); // ICU4N: Checked 3rd parameter
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>

    }
}