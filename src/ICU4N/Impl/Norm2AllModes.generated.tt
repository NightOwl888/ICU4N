<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Where(x => x.Value != "ReadOnlySpan<char>").Select(x => x.Value).ToArray(); // ICU4N TODO: API - ReadOnlySpan<char>
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
    string appendableAccessibility = document.XPathSelectElement(@"//codeGen/appendableAccessibility").Value;
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Text;
using ICU4N.Util;
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    // Normalizer2 implementation for the old UNORM_NONE.
    public sealed partial class NoopNormalizer2
    {
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Normalize(<#=charSequence#> src, StringBuilder dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest == src)
<# } else if (charSequence=="ICharSequence") { #>
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            dest.Length = 0;
            return dest.Append(src);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : appendableAccessibility #> override IAppendable Normalize(<#=charSequence#> src, IAppendable dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
<# } else if (charSequence=="ICharSequence") { #>
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
            return first.Append(second.ToString());
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Append(StringBuilder first, <#=charSequence#> second)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
            return first.Append(second);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override bool IsNormalized(<#=charSequence#> s) { return true; }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override QuickCheckResult QuickCheck(<#=charSequence#> s) { return QuickCheckResult.Yes; }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s) { return s.Length; }
<# } #>

    }

    public abstract partial class Normalizer2WithImpl
    {
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Normalize(<#=charSequence#> src, StringBuilder dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest == src)
<# } else if (charSequence=="ICharSequence") { #>
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            dest.Length = 0;
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
            return dest;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : appendableAccessibility #> override IAppendable Normalize(<#=charSequence#> src, IAppendable dest)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
<# } else if (charSequence=="ICharSequence") { #>
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
            return dest;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> abstract void Normalize(<#=charSequence#> src, ReorderingBuffer buffer);
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override StringBuilder Append(StringBuilder first, <#=charSequence#> second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second, bool doNormalize)
        {
<# if (charSequence=="ICharSequence" || charSequence=="StringBuilder") { #>
<# if (charSequence=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
            return first;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> abstract void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, ReorderingBuffer buffer);
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override bool IsNormalized(<#=charSequence#> s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override QuickCheckResult QuickCheck(<#=charSequence#> s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }
<# } #>
    }

    public sealed partial class DecomposeNormalizer2
    {
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void Normalize(<#=charSequence#> src, ReorderingBuffer buffer)
        {
            Impl.Decompose(src, 0, src.Length, buffer);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void NormalizeAndAppend(<#=charSequence#> src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, buffer);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.DecomposeQuickCheck(s, 0, s.Length); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }
<# } #>
    }

    public sealed partial class ComposeNormalizer2
    {
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void Normalize(<#=charSequence#> src, ReorderingBuffer buffer)
        {
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, buffer);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override bool IsNormalized(<#=charSequence#> s)
        {
            // 5: small destCapacity for substring normalization
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override QuickCheckResult QuickCheck(<#=charSequence#> s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.ComposeQuickCheck(s, 0, s.Length, onlyContiguous, true).TripleShift(1);
        }
<# } #>

    }

    public sealed partial class FCDNormalizer2
    {
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void Normalize(<#=charSequence#> src, ReorderingBuffer buffer)
        {
            Impl.MakeFCD(src, 0, src.Length, buffer);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "protected"#> override void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, buffer);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        <#= charSequence == "ICharSequence" ? charSequenceAccessibility : "public"#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.MakeFCDSpanQuickCheckYes(s, 0, s.Length);
        }
<# } #>

    }
}