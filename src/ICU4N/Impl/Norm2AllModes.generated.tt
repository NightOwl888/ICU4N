<#@ output extension=".cs" #>
<#@ include file="../../../codegen/FilterDeclarations.tt" #>
<#
AppendableFilter = (a) => a.Name != "ValueStringBuilder";
string codeGenerationRelativePath = @"../../../codegen";
#><#@ include file="../../../codegen/DataLoader.tt" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Support.Text;
using ICU4N.Text;
using ICU4N.Util;
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.IO;
using System.Text;

namespace ICU4N.Impl
{
    // Normalizer2 implementation for the old UNORM_NONE.
    public sealed partial class NoopNormalizer2
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override StringBuilder Normalize(<#=charSequence#> src, StringBuilder dest)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (dest == src)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            dest.Length = 0;
            return dest.Append(src);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#= GetAccessibility(charSequence.Accessibility, appendableAccessibility) #> override IAppendable Normalize(<#=charSequence#> src, IAppendable dest)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            // ICU4N: Removed unnecessary try/catch for IOException
            return dest.Append(src);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(charSequence: second);
<# } else { #>
            return first.Append(second);
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override StringBuilder Append(StringBuilder first, <#=charSequence#> second)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
            return first.Append(charSequence: second);
<# } else { #>
            return first.Append(second);
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override bool IsNormalized(<#=charSequence#> s) { return true; }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override QuickCheckResult QuickCheck(<#=charSequence#> s) { return QuickCheckResult.Yes; }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override int SpanQuickCheckYes(<#=charSequence#> s) { return s.Length; }
<#= GetEndFeature(charSequence) #>
<# } #>

    }

    public abstract partial class Normalizer2WithImpl
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override StringBuilder Normalize(<#=charSequence#> src, StringBuilder dest)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (dest == src)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if (src is StringBuilderCharSequence && ((StringBuilderCharSequence)src).Value == dest)
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
            dest.Length = 0;
<# if (charSequence.Name == "ReadOnlySpan<char>") { #>
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Length = 0;
                dest.Append(buffer.AsSpan());
            }
            finally
            {
                buffer.Dispose();
            }
<# } else { #>
            Normalize(src, new ReorderingBuffer(Impl, dest, src.Length));
<# } #>
            return dest;
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#= GetAccessibility(charSequence.Accessibility, appendableAccessibility) #> override IAppendable Normalize(<#=charSequence#> src, IAppendable dest)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (dest is StringBuilderCharSequence && ((StringBuilderCharSequence)dest).Value == src)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if ((dest == src) || (src is StringBuilderCharSequence && dest is StringBuilderCharSequence 
                && ((StringBuilderCharSequence)src).Value == ((StringBuilderCharSequence)dest).Value))
<# } #>
            {
                throw new ArgumentException($"'{nameof(src)}' cannot be the same instance as '{nameof(dest)}'");
            }
<# } #>
<# if (charSequence.Name == "ReadOnlySpan<char>") { #>
            int length = src.Length;
            var buffer = length <= CharStackBufferSize
                ? new ValueReorderingBuffer(Impl, stackalloc char[CharStackBufferSize])
                : new ValueReorderingBuffer(Impl, ReadOnlySpan<char>.Empty, length);
            try
            {
                Normalize(src, ref buffer);
                dest.Append(buffer.AsSpan());
                buffer.Flush();
            }
            finally
            {
                buffer.Dispose();
            }
<# } else { #>
            ReorderingBuffer buffer = new ReorderingBuffer(Impl, dest, src.Length);
            Normalize(src, buffer);
            buffer.Flush();
<# } #>
            return dest;
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> abstract void Normalize(<#=charSequence#> src, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer);
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second)
        {
            return NormalizeSecondAndAppend(first, second, true);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override StringBuilder Append(StringBuilder first, <#=charSequence#> second)
        {
            return NormalizeSecondAndAppend(first, second, false);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> virtual StringBuilder NormalizeSecondAndAppend(StringBuilder first, <#=charSequence#> second, bool doNormalize)
        {
<# if (charSequence.Name=="ICharSequence" || charSequence.Name=="StringBuilder") { #>
<# if (charSequence.Name=="StringBuilder") { #>
            if (first == second)
<# } else if (charSequence.Name=="ICharSequence") { #>
            if (second is StringBuilderCharSequence && ((StringBuilderCharSequence)second).Value == first)
<# } #>
            {
                throw new ArgumentException($"'{nameof(first)}' cannot be the same instance as '{nameof(second)}'");
            }
<# } #>
<# if (charSequence.Name == "ReadOnlySpan<char>") { #>
            int length = first.Length + second.Length;
            var sb = length <= CharStackBufferSize
                ? new ValueStringBuilder(stackalloc char[CharStackBufferSize])
                : new ValueStringBuilder(length);
            try
            {
                sb.Append(first);
                var buffer = new ValueReorderingBuffer(Impl, ref sb, length);
                NormalizeAndAppend(second, doNormalize, ref buffer);
                first.Length = 0;
                first.Append(buffer.AsSpan());
            }
            finally
            {
                sb.Dispose();
            }
<# } else { #>
            NormalizeAndAppend(
                second, doNormalize,
                new ReorderingBuffer(Impl, first, first.Length + second.Length));
<# } #>
            return first;
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> abstract void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer);
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override bool IsNormalized(<#=charSequence#> s)
        {
            return s.Length == SpanQuickCheckYes(s);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override QuickCheckResult QuickCheck(<#=charSequence#> s)
        {
            return IsNormalized(s) ? QuickCheckResult.Yes : QuickCheckResult.No;
        }
<#= GetEndFeature(charSequence) #>
<# } #>
    }

    public sealed partial class DecomposeNormalizer2
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> override void Normalize(<#=charSequence#> src, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
<# if(charSequence.Name == "ReadOnlySpan<char>") { #>
            Impl.Decompose(src, ref buffer);
<# } else { #>
            Impl.Decompose(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> override void NormalizeAndAppend(<#=charSequence#> src, bool doNormalize, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
            Impl.DecomposeAndAppend(src, doNormalize, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref " : ""#>buffer);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.DecomposeQuickCheck(s<#=charSequence.Name != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>); // ICU4N: Changed to a separate method so we can use a ref struct for a buffer
        }
<#= GetEndFeature(charSequence) #>
<# } #>
    }

    public sealed partial class ComposeNormalizer2
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> override void Normalize(<#=charSequence#> src, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
<# if (charSequence.Name == "ReadOnlySpan<char>") { #>
            Impl.Compose(src, onlyContiguous, true, ref buffer);
<# } else { #>
            Impl.Compose(src, 0, src.Length, onlyContiguous, true, buffer); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequenceAccessibility, "protected")#> override void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
            Impl.ComposeAndAppend(src, doNormalize, onlyContiguous, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref " : ""#>buffer);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override bool IsNormalized(<#=charSequence#> s)
        {
            // 5: small destCapacity for substring normalization
<# if (charSequence.Name == "ReadOnlySpan<char>") { #>
            var buffer = new ValueReorderingBuffer(Impl, stackalloc char[5]);
            try
            {
                return Impl.Compose(s, onlyContiguous, false, ref buffer);
            }
            finally
            {
                buffer.Dispose();
            }
<# } else { #>
            return Impl.Compose(s, 0, s.Length,
                                onlyContiguous, false,
                                new ReorderingBuffer(Impl, new StringBuilder(), 5)); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override QuickCheckResult QuickCheck(<#=charSequence#> s)
        {
            int spanLengthAndMaybe = Impl.ComposeQuickCheck(s<#=charSequence.Name != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>, onlyContiguous, false);
            if ((spanLengthAndMaybe & 1) != 0)
            {
                return QuickCheckResult.Maybe;
            }
            else if ((spanLengthAndMaybe.TripleShift(1)) == s.Length)
            {
                return QuickCheckResult.Yes;
            }
            else
            {
                return QuickCheckResult.No;
            }
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.ComposeQuickCheck(s<#=charSequence.Name != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>, onlyContiguous, true).TripleShift(1); // ICU4N: Checked 3rd parameter
        }
<#= GetEndFeature(charSequence) #>
<# } #>

    }

    public sealed partial class FCDNormalizer2
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> override void Normalize(<#=charSequence#> src, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
<# if (charSequence.Name == "ReadOnlySpan<char>") { #>
            Impl.MakeFCD(src, ref buffer);
<# } else { #>
            Impl.MakeFCD(src, 0, src.Length, buffer); // ICU4N: Checked 3rd parameter
<# } #>
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence.Accessibility, "protected")#> override void NormalizeAndAppend(
            <#=charSequence#> src, bool doNormalize, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref Value" : ""#>ReorderingBuffer buffer)
        {
            Impl.MakeFCDAndAppend(src, doNormalize, <#=charSequence.Name == "ReadOnlySpan<char>" ? "ref " : ""#>buffer);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        <#=GetAccessibility(charSequence)#> override int SpanQuickCheckYes(<#=charSequence#> s)
        {
            return Impl.MakeFCDQuickCheck(s<#=charSequence.Name != "ReadOnlySpan<char>" ? ", 0, s.Length" : ""#>); // ICU4N: Checked 3rd parameter
        }
<#= GetEndFeature(charSequence) #>
<# } #>

    }
}
<#@ include file="../../../codegen/SharedObjects.tt" #>