using ICU4N.Globalization;
using ICU4N.Impl;
using ICU4N.Support.Collections;
using J2N;
using J2N.Collections;
using System;
using System.Collections.Generic;

namespace ICU4N.Text
{
    //
    //  class RBBITableBuilder is part of the RBBI rule compiler.
    //                         It builds the state transition table used by the RBBI runtime
    //                         from the expression syntax tree generated by the rule scanner.
    //
    //                         This class is part of the RBBI implementation only.
    //                         There is no user-visible public API here.
    //
    internal class RBBITableBuilder
    {


        //
        //  RBBIStateDescriptor - The DFA is initially constructed as a set of these descriptors,
        //                        one for each state.
        internal class RBBIStateDescriptor
        {
            internal bool fMarked;
            internal int fAccepting;
            internal int fLookAhead;
            internal SortedSet<int> fTagVals;
            internal int fTagsIdx;
            internal ISet<RBBINode> fPositions;                 // Set of parse tree positions associated
                                                                //   with this state.  Unordered (it's a set).
                                                                //   UVector contents are RBBINode *

            internal int[] fDtran;                      // Transitions out of this state.
                                                        //   indexed by input character
                                                        //   contents is int index of dest state
                                                        //   in RBBITableBuilder.fDStates

            internal RBBIStateDescriptor(int maxInputSymbol)
            {
                fTagVals = new SortedSet<int>();
                fPositions = new HashSet<RBBINode>();
                fDtran = new int[maxInputSymbol + 1];    // fDtran needs to be pre-sized.
                                                         //   It is indexed by input symbols, and will
                                                         //   hold  the next state number for each
                                                         //   symbol.
            }
        }


        private RBBIRuleBuilder fRB;
        private int fRootIx;             // The array index into RBBIRuleBuilder.fTreeRoots
                                         //   for the parse tree to operate on.
                                         //   Too bad Java can't do indirection more easily!

        private IList<RBBIStateDescriptor> fDStates;    //  D states (Aho's terminology)
                                                        //  Index is state number
                                                        //  Contents are RBBIStateDescriptor pointers.

        //-----------------------------------------------------------------------------
        //
        //  Constructor    for RBBITableBuilder.
        //
        //                 rootNode is an index into the array of root nodes that is held by
        //                          the overall RBBIRuleBuilder.
        //-----------------------------------------------------------------------------
        internal RBBITableBuilder(RBBIRuleBuilder rb, int rootNodeIx)
        {
            fRootIx = rootNodeIx;
            fRB = rb;
            fDStates = new List<RBBIStateDescriptor>();
        }




        //-----------------------------------------------------------------------------
        //
        //   RBBITableBuilder::build  -  This is the main function for building the DFA state transtion
        //                               table from the RBBI rules parse tree.
        //
        //-----------------------------------------------------------------------------
        internal virtual void Build()
        {
            // If there were no rules, just return.  This situation can easily arise
            //   for the reverse rules.
            if (fRB.fTreeRoots[fRootIx] == null)
            {
                return;
            }

            //
            // Walk through the tree, replacing any references to $variables with a copy of the
            //   parse tree for the substition expression.
            //
            fRB.fTreeRoots[fRootIx] = fRB.fTreeRoots[fRootIx].FlattenVariables();
            if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("ftree", StringComparison.Ordinal) >= 0)
            {
                Console.Out.WriteLine("Parse tree after flattening variable references.");
                fRB.fTreeRoots[fRootIx].PrintTree(true);
            }

            //
            // If the rules contained any references to {bof}
            //   add a {bof} <cat> <former root of tree> to the
            //   tree.  Means that all matches must start out with the
            //   {bof} fake character.
            //
            if (fRB.fSetBuilder.SawBOF)
            {
                RBBINode bofTop = new RBBINode(RBBINode.opCat);
                RBBINode bofLeaf = new RBBINode(RBBINode.leafChar);
                bofTop.fLeftChild = bofLeaf;
                bofTop.fRightChild = fRB.fTreeRoots[fRootIx];
                bofLeaf.fParent = bofTop;
                bofLeaf.fVal = 2;      // Reserved value for {bof}.
                fRB.fTreeRoots[fRootIx] = bofTop;
            }

            //
            // Add a unique right-end marker to the expression.
            //   Appears as a cat-node, left child being the original tree,
            //   right child being the end marker.
            //
            RBBINode cn = new RBBINode(RBBINode.opCat);
            cn.fLeftChild = fRB.fTreeRoots[fRootIx];
            fRB.fTreeRoots[fRootIx].fParent = cn;
            cn.fRightChild = new RBBINode(RBBINode.endMark);
            cn.fRightChild.fParent = cn;
            fRB.fTreeRoots[fRootIx] = cn;

            //
            //  Replace all references to UnicodeSets with the tree for the equivalent
            //      expression.
            //
            fRB.fTreeRoots[fRootIx].FlattenSets();
            if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("stree", StringComparison.Ordinal) >= 0)
            {
                Console.Out.WriteLine("Parse tree after flattening Unicode Set references.");
                fRB.fTreeRoots[fRootIx].PrintTree(true);
            }


            //
            // calculate the functions nullable, firstpos, lastpos and followpos on
            // nodes in the parse tree.
            //    See the alogrithm description in Aho.
            //    Understanding how this works by looking at the code alone will be
            //       nearly impossible.
            //
            CalcNullable(fRB.fTreeRoots[fRootIx]);
            CalcFirstPos(fRB.fTreeRoots[fRootIx]);
            CalcLastPos(fRB.fTreeRoots[fRootIx]);
            CalcFollowPos(fRB.fTreeRoots[fRootIx]);
            if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("pos", StringComparison.Ordinal) >= 0)
            {
                Console.Out.Write("\n");
                PrintPosSets(fRB.fTreeRoots[fRootIx]);
            }

            //
            //  For "chained" rules, modify the followPos sets
            //
            if (fRB.fChainRules)
            {
                CalcChainedFollowPos(fRB.fTreeRoots[fRootIx]);
            }

            //
            //  BOF (start of input) test fixup.
            //
            if (fRB.fSetBuilder.SawBOF)
            {
                BofFixup();
            }

            //
            // Build the DFA state transition tables.
            //
            BuildStateTable();
            FlagAcceptingStates();
            FlagLookAheadStates();
            FlagTaggedStates();

            //
            // Update the global table of rule status {tag} values
            // The rule builder has a global vector of status values that are common
            //    for all tables.  Merge the ones from this table into the global set.
            //
            MergeRuleStatusVals();

            if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("states", StringComparison.Ordinal) >= 0) { PrintStates(); }
        }



        //-----------------------------------------------------------------------------
        //
        //   calcNullable.    Impossible to explain succinctly.  See Aho, section 3.9
        //
        //-----------------------------------------------------------------------------
        internal virtual void CalcNullable(RBBINode n)
        {
            if (n == null)
            {
                return;
            }
            if (n.fType == RBBINode.setRef ||
                n.fType == RBBINode.endMark)
            {
                // These are non-empty leaf node types.
                n.fNullable = false;
                return;
            }

            if (n.fType == RBBINode.lookAhead || n.fType == RBBINode.tag)
            {
                // Lookahead marker node.  It's a leaf, so no recursion on children.
                // It's nullable because it does not match any literal text from the input stream.
                n.fNullable = true;
                return;
            }


            // The node is not a leaf.
            //  Calculate nullable on its children.
            CalcNullable(n.fLeftChild);
            CalcNullable(n.fRightChild);

            // Apply functions from table 3.40 in Aho
            if (n.fType == RBBINode.opOr)
            {
                n.fNullable = n.fLeftChild.fNullable || n.fRightChild.fNullable;
            }
            else if (n.fType == RBBINode.opCat)
            {
                n.fNullable = n.fLeftChild.fNullable && n.fRightChild.fNullable;
            }
            else if (n.fType == RBBINode.opStar || n.fType == RBBINode.opQuestion)
            {
                n.fNullable = true;
            }
            else
            {
                n.fNullable = false;
            }
        }




        //-----------------------------------------------------------------------------
        //
        //   calcFirstPos.    Impossible to explain succinctly.  See Aho, section 3.9
        //
        //-----------------------------------------------------------------------------
        internal virtual void CalcFirstPos(RBBINode n)
        {
            if (n == null)
            {
                return;
            }
            if (n.fType == RBBINode.leafChar ||
                n.fType == RBBINode.endMark ||
                n.fType == RBBINode.lookAhead ||
                n.fType == RBBINode.tag)
            {
                // These are non-empty leaf node types.
                n.fFirstPosSet.Add(n);
                return;
            }

            // The node is not a leaf.
            //  Calculate firstPos on its children.
            CalcFirstPos(n.fLeftChild);
            CalcFirstPos(n.fRightChild);

            // Apply functions from table 3.40 in Aho
            if (n.fType == RBBINode.opOr)
            {
                n.fFirstPosSet.UnionWith(n.fLeftChild.fFirstPosSet);
                n.fFirstPosSet.UnionWith(n.fRightChild.fFirstPosSet);
            }
            else if (n.fType == RBBINode.opCat)
            {
                n.fFirstPosSet.UnionWith(n.fLeftChild.fFirstPosSet);
                if (n.fLeftChild.fNullable)
                {
                    n.fFirstPosSet.UnionWith(n.fRightChild.fFirstPosSet);
                }
            }
            else if (n.fType == RBBINode.opStar ||
                     n.fType == RBBINode.opQuestion ||
                     n.fType == RBBINode.opPlus)
            {
                n.fFirstPosSet.UnionWith(n.fLeftChild.fFirstPosSet);
            }
        }



        //-----------------------------------------------------------------------------
        //
        //   calcLastPos.    Impossible to explain succinctly.  See Aho, section 3.9
        //
        //-----------------------------------------------------------------------------
        internal virtual void CalcLastPos(RBBINode n)
        {
            if (n == null)
            {
                return;
            }
            if (n.fType == RBBINode.leafChar ||
                n.fType == RBBINode.endMark ||
                n.fType == RBBINode.lookAhead ||
                n.fType == RBBINode.tag)
            {
                // These are non-empty leaf node types.
                n.fLastPosSet.Add(n);
                return;
            }

            // The node is not a leaf.
            //  Calculate lastPos on its children.
            CalcLastPos(n.fLeftChild);
            CalcLastPos(n.fRightChild);

            // Apply functions from table 3.40 in Aho
            if (n.fType == RBBINode.opOr)
            {
                n.fLastPosSet.UnionWith(n.fLeftChild.fLastPosSet);
                n.fLastPosSet.UnionWith(n.fRightChild.fLastPosSet);
            }
            else if (n.fType == RBBINode.opCat)
            {
                n.fLastPosSet.UnionWith(n.fRightChild.fLastPosSet);
                if (n.fRightChild.fNullable)
                {
                    n.fLastPosSet.UnionWith(n.fLeftChild.fLastPosSet);
                }
            }
            else if (n.fType == RBBINode.opStar ||
                     n.fType == RBBINode.opQuestion ||
                     n.fType == RBBINode.opPlus)
            {
                n.fLastPosSet.UnionWith(n.fLeftChild.fLastPosSet);
            }
        }



        //-----------------------------------------------------------------------------
        //
        //   calcFollowPos.    Impossible to explain succinctly.  See Aho, section 3.9
        //
        //-----------------------------------------------------------------------------
        internal virtual void CalcFollowPos(RBBINode n)
        {
            if (n == null ||
                n.fType == RBBINode.leafChar ||
                n.fType == RBBINode.endMark)
            {
                return;
            }

            CalcFollowPos(n.fLeftChild);
            CalcFollowPos(n.fRightChild);

            // Aho rule #1
            if (n.fType == RBBINode.opCat)
            {
                foreach (RBBINode i /* is 'i' in Aho's description */ in n.fLeftChild.fLastPosSet)
                {
                    i.fFollowPos.UnionWith(n.fRightChild.fFirstPosSet);
                }
            }

            // Aho rule #2
            if (n.fType == RBBINode.opStar ||
                n.fType == RBBINode.opPlus)
            {
                foreach (RBBINode i /* again, n and i are the names from Aho's description */ in n.fLastPosSet)
                {
                    i.fFollowPos.UnionWith(n.fFirstPosSet);
                }
            }
        }

        //-----------------------------------------------------------------------------
        //
        //           addRuleRootNodes    Recursively walk a parse tree, adding all nodes flagged
        //                               as roots of a rule to a destination vector.
        //
        //-----------------------------------------------------------------------------
        internal virtual void AddRuleRootNodes(List<RBBINode> dest, RBBINode node)
        {
            if (node == null)
            {
                return;
            }
            if (node.fRuleRoot)
            {
                dest.Add(node);
                // Note: rules cannot nest. If we found a rule start node,
                //       no child node can also be a start node.
                return;
            }
            AddRuleRootNodes(dest, node.fLeftChild);
            AddRuleRootNodes(dest, node.fRightChild);
        }

        //-----------------------------------------------------------------------------
        //
        //   calcChainedFollowPos.    Modify the previously calculated followPos sets
        //                            to implement rule chaining.  NOT described by Aho
        //
        //-----------------------------------------------------------------------------
        internal virtual void CalcChainedFollowPos(RBBINode tree)
        {

            List<RBBINode> endMarkerNodes = new List<RBBINode>();
            List<RBBINode> leafNodes = new List<RBBINode>();

            // get a list of all endmarker nodes.
            tree.FindNodes(endMarkerNodes, RBBINode.endMark);

            // get a list all leaf nodes
            tree.FindNodes(leafNodes, RBBINode.leafChar);

            // Collect all leaf nodes that can start matches for rules
            // with inbound chaining enabled, which is the union of the
            // firstPosition sets from each of the rule root nodes.

            List<RBBINode> ruleRootNodes = new List<RBBINode>();
            AddRuleRootNodes(ruleRootNodes, tree);

            ISet<RBBINode> matchStartNodes = new HashSet<RBBINode>();
            foreach (RBBINode node in ruleRootNodes)
            {
                if (node.fChainIn)
                {
                    matchStartNodes.UnionWith(node.fFirstPosSet);
                }
            }

            // Iterate over all leaf nodes,
            //
            foreach (RBBINode tNode in leafNodes)
            {
                RBBINode endNode = null;

                // Identify leaf nodes that correspond to overall rule match positions.
                //   These include an endMarkerNode in their followPos sets.
                foreach (RBBINode endMarkerNode in endMarkerNodes)
                {
                    if (tNode.fFollowPos.Contains(endMarkerNode))
                    {
                        endNode = tNode;
                        break;
                    }
                }
                if (endNode == null)
                {
                    // node wasn't an end node.  Try again with the next.
                    continue;
                }

                // We've got a node that can end a match.

                // Line Break Specific hack:  If this node's val correspond to the $CM char class,
                //                            don't chain from it.
                // TODO:  Add rule syntax for this behavior, get specifics out of here and
                //        into the rule file.
                if (fRB.fLBCMNoChain)
                {
                    int c = this.fRB.fSetBuilder.GetFirstChar(endNode.fVal);
                    if (c != -1)
                    {
                        // c == -1 occurs with sets containing only the {eof} marker string.
                        int cLBProp = UChar.GetIntPropertyValue(c, UProperty.Line_Break);
                        if (cLBProp == LineBreak.CombiningMark)
                        {
                            continue;
                        }
                    }
                }


                // Now iterate over the nodes that can start a match, looking for ones
                //   with the same char class as our ending node.
                foreach (RBBINode startNode in matchStartNodes)
                {
                    if (startNode.fType != RBBINode.leafChar)
                    {
                        continue;
                    }

                    if (endNode.fVal == startNode.fVal)
                    {
                        // The end val (character class) of one possible match is the
                        //   same as the start of another.

                        // Add all nodes from the followPos of the start node to the
                        //  followPos set of the end node, which will have the effect of
                        //  letting matches transition from a match state at endNode
                        //  to the second char of a match starting with startNode.
                        endNode.fFollowPos.UnionWith(startNode.fFollowPos);
                    }
                }
            }
        }


        //-----------------------------------------------------------------------------
        //
        //   bofFixup.    Fixup for state tables that include {bof} beginning of input testing.
        //                Do an swizzle similar to chaining, modifying the followPos set of
        //                the bofNode to include the followPos nodes from other {bot} nodes
        //                scattered through the tree.
        //
        //                This function has much in common with calcChainedFollowPos().
        //
        //-----------------------------------------------------------------------------
        internal virtual void BofFixup()
        {
            //
            //   The parse tree looks like this ...
            //         fTree root  --.       <cat>
            //                               /     \
            //                            <cat>   <#end node>
            //                           /     \
            //                     <bofNode>   rest
            //                               of tree
            //
            //    We will be adding things to the followPos set of the <bofNode>
            //
            RBBINode bofNode = fRB.fTreeRoots[fRootIx].fLeftChild.fLeftChild;
            Assert.Assrt(bofNode.fType == RBBINode.leafChar);
            Assert.Assrt(bofNode.fVal == 2);

            // Get all nodes that can be the start a match of the user-written rules
            //  (excluding the fake bofNode)
            //  We want the nodes that can start a match in the
            //     part labeled "rest of tree"
            //
            ISet<RBBINode> matchStartNodes = fRB.fTreeRoots[fRootIx].fLeftChild.fRightChild.fFirstPosSet;
            foreach (RBBINode startNode in matchStartNodes)
            {
                if (startNode.fType != RBBINode.leafChar)
                {
                    continue;
                }

                if (startNode.fVal == bofNode.fVal)
                {
                    //  We found a leaf node corresponding to a {bof} that was
                    //    explicitly written into a rule.
                    //  Add everything from the followPos set of this node to the
                    //    followPos set of the fake bofNode at the start of the tree.
                    //
                    bofNode.fFollowPos.UnionWith(startNode.fFollowPos);
                }
            }
        }

        //-----------------------------------------------------------------------------
        //
        //   buildStateTable()    Determine the set of runtime DFA states and the
        //                        transition tables for these states, by the algorithm
        //                        of fig. 3.44 in Aho.
        //
        //                        Most of the comments are quotes of Aho's psuedo-code.
        //
        //-----------------------------------------------------------------------------
        internal virtual void BuildStateTable()
        {
            //
            // Add a dummy state 0 - the stop state.  Not from Aho.
            int lastInputSymbol = fRB.fSetBuilder.NumCharCategories - 1;
            RBBIStateDescriptor failState = new RBBIStateDescriptor(lastInputSymbol);
            fDStates.Add(failState);

            // initially, the only unmarked state in Dstates is firstpos(root),
            //       where toot is the root of the syntax tree for (r)#;
            RBBIStateDescriptor initialState = new RBBIStateDescriptor(lastInputSymbol);
            initialState.fPositions.UnionWith(fRB.fTreeRoots[fRootIx].fFirstPosSet);
            fDStates.Add(initialState);

            // while there is an unmarked state T in Dstates do begin
            for (; ; )
            {
                RBBIStateDescriptor T = null;
                int tx;
                for (tx = 1; tx < fDStates.Count; tx++)
                {
                    RBBIStateDescriptor temp = fDStates[tx];
                    if (temp.fMarked == false)
                    {
                        T = temp;
                        break;
                    }
                }
                if (T == null)
                {
                    break;
                }

                // mark T;
                T.fMarked = true;

                // for each input symbol a do begin
                int a;
                for (a = 1; a <= lastInputSymbol; a++)
                {
                    // let U be the set of positions that are in followpos(p)
                    //    for some position p in T
                    //    such that the symbol at position p is a;
                    ISet<RBBINode> U = null;
                    foreach (RBBINode p in T.fPositions)
                    {
                        if ((p.fType == RBBINode.leafChar) && (p.fVal == a))
                        {
                            if (U == null)
                            {
                                U = new HashSet<RBBINode>();
                            }
                            U.UnionWith(p.fFollowPos);
                        }
                    }

                    // if U is not empty and not in DStates then
                    int ux = 0;
                    bool UinDstates = false;
                    if (U != null)
                    {
                        Assert.Assrt(U.Count > 0);
                        int ix;
                        for (ix = 0; ix < fDStates.Count; ix++)
                        {
                            RBBIStateDescriptor temp2;
                            temp2 = fDStates[ix];
                            if (CollectionUtil.Equals(U, temp2.fPositions))
                            {
                                U = temp2.fPositions;
                                ux = ix;
                                UinDstates = true;
                                break;
                            }
                        }

                        // Add U as an unmarked state to Dstates
                        if (!UinDstates)
                        {
                            RBBIStateDescriptor newState = new RBBIStateDescriptor(lastInputSymbol);
                            newState.fPositions = U;
                            fDStates.Add(newState);
                            ux = fDStates.Count - 1;
                        }

                        // Dtran[T, a] := U;
                        T.fDtran[a] = ux;
                    }
                }
            }
        }



        //-----------------------------------------------------------------------------
        //
        //   flagAcceptingStates    Identify accepting states.
        //                          First get a list of all of the end marker nodes.
        //                          Then, for each state s,
        //                              if s contains one of the end marker nodes in its list of tree positions then
        //                                  s is an accepting state.
        //
        //-----------------------------------------------------------------------------
        internal virtual void FlagAcceptingStates()
        {
            List<RBBINode> endMarkerNodes = new List<RBBINode>();
            RBBINode endMarker;
            int i;
            int n;

            fRB.fTreeRoots[fRootIx].FindNodes(endMarkerNodes, RBBINode.endMark);

            for (i = 0; i < endMarkerNodes.Count; i++)
            {
                endMarker = endMarkerNodes[i];
                for (n = 0; n < fDStates.Count; n++)
                {
                    RBBIStateDescriptor sd = fDStates[n];
                    //if (sd.fPositions.indexOf(endMarker) >= 0) {
                    if (sd.fPositions.Contains(endMarker))
                    {
                        // Any non-zero value for fAccepting means this is an accepting node.
                        // The value is what will be returned to the user as the break status.
                        // If no other value was specified, force it to -1.

                        if (sd.fAccepting == 0)
                        {
                            // State hasn't been marked as accepting yet.  Do it now.
                            sd.fAccepting = endMarker.fVal;
                            if (sd.fAccepting == 0)
                            {
                                sd.fAccepting = -1;
                            }
                        }
                        if (sd.fAccepting == -1 && endMarker.fVal != 0)
                        {
                            // Both lookahead and non-lookahead accepting for this state.
                            // Favor the look-ahead.  Expedient for line break.
                            // TODO:  need a more elegant resolution for conflicting rules.
                            sd.fAccepting = endMarker.fVal;
                        }
                        // implicit else:
                        // if sd.fAccepting already had a value other than 0 or -1, leave it be.

                        // If the end marker node is from a look-ahead rule, set
                        //   the fLookAhead field or this state also.
                        if (endMarker.fLookAheadEnd)
                        {
                            // TODO:  don't change value if already set?
                            // TODO:  allow for more than one active look-ahead rule in engine.
                            //        Make value here an index to a side array in engine?
                            sd.fLookAhead = sd.fAccepting;
                        }
                    }
                }
            }
        }


        //-----------------------------------------------------------------------------
        //
        //    flagLookAheadStates   Very similar to flagAcceptingStates, above.
        //
        //-----------------------------------------------------------------------------
        internal virtual void FlagLookAheadStates()
        {
            List<RBBINode> lookAheadNodes = new List<RBBINode>();
            RBBINode lookAheadNode;
            int i;
            int n;

            fRB.fTreeRoots[fRootIx].FindNodes(lookAheadNodes, RBBINode.lookAhead);
            for (i = 0; i < lookAheadNodes.Count; i++)
            {
                lookAheadNode = lookAheadNodes[i];

                for (n = 0; n < fDStates.Count; n++)
                {
                    RBBIStateDescriptor sd = fDStates[n];
                    if (sd.fPositions.Contains(lookAheadNode))
                    {
                        sd.fLookAhead = lookAheadNode.fVal;
                    }
                }
            }
        }




        //-----------------------------------------------------------------------------
        //
        //    flagTaggedStates
        //
        //-----------------------------------------------------------------------------
        internal virtual void FlagTaggedStates()
        {
            List<RBBINode> tagNodes = new List<RBBINode>();
            RBBINode tagNode;
            int i;
            int n;

            fRB.fTreeRoots[fRootIx].FindNodes(tagNodes, RBBINode.tag);
            for (i = 0; i < tagNodes.Count; i++)
            {                   // For each tag node t (all of 'em)
                tagNode = tagNodes[i];

                for (n = 0; n < fDStates.Count; n++)
                {              //    For each state  s (row in the state table)
                    RBBIStateDescriptor sd = fDStates[n];
                    if (sd.fPositions.Contains(tagNode))
                    {       //       if  s include the tag node t
                        sd.fTagVals.Add(tagNode.fVal);
                    }
                }
            }
        }



        //-----------------------------------------------------------------------------
        //
        //  mergeRuleStatusVals
        //
        //      Allocate positions in the  global array of rule status {tag} values
        //
        //      The RBBI runtime uses an array of {sets of status values} that can
        //      be returned for boundaries.  Each accepting state that has non-zero
        //      status includes an index into this array.  The format of the array
        //      is
        //           Num of status values in group 1
        //              status val
        //              status val
        //              ...
        //           Num of status vals in group 2
        //              status val
        //              status val
        //              ...
        //           etc.
        //
        //
        //-----------------------------------------------------------------------------

        internal virtual void MergeRuleStatusVals()
        {
            //
            //  The basic outline of what happens here is this...
            //
            //    for each state in this state table
            //       if the status tag list for this state is in the global statuses list
            //           record where and
            //           continue with the next state
            //       else
            //           add the tag list for this state to the global list.
            //
            int n;

            // Pre-load a single tag of {0} into the table.
            //   We will need this as a default, for rule sets with no explicit tagging,
            //   or with explicit tagging of {0}.
            if (fRB.fRuleStatusVals.Count == 0)
            {
                fRB.fRuleStatusVals.Add(1);    // Num of statuses in group
                fRB.fRuleStatusVals.Add(0);    //   and our single status of zero

                SortedSet<int> s0 = new SortedSet<int>();
                int izero = 0;
                fRB.fStatusSets[s0] = izero;
                SortedSet<int> s1 = new SortedSet<int>();
                s1.Add(izero);
                fRB.fStatusSets[s0] = izero;
            }

            //    For each state, check whether the state's status tag values are
            //       already entered into the status values array, and add them if not.
            for (n = 0; n < fDStates.Count; n++)
            {
                RBBIStateDescriptor sd = fDStates[n];
                SortedSet<int> statusVals = sd.fTagVals;
                int? arrayIndexI = fRB.fStatusSets.Get(statusVals);
                if (arrayIndexI == null)
                {
                    // This is the first encounter of this set of status values.
                    //   Add them to the statusSets map, This map associates
                    //   the set of status values with an index in the runtime status
                    //   values array.
                    arrayIndexI = fRB.fRuleStatusVals.Count;
                    fRB.fStatusSets[statusVals] = arrayIndexI;

                    // Add the new set of status values to the vector of values that
                    //   will eventually become the array used by the runtime engine.
                    fRB.fRuleStatusVals.Add(statusVals.Count);
                    fRB.fRuleStatusVals.AddRange(statusVals);
                }

                // Save the runtime array index back into the state descriptor.
                sd.fTagsIdx = arrayIndexI.Value; // ICU4N NOTE: At this pint the value cannot be null
            }
        }







        //-----------------------------------------------------------------------------
        //
        //  printPosSets   Debug function.  Dump Nullable, firstpos, lastpos and followpos
        //                 for each node in the tree.
        //
        //-----------------------------------------------------------------------------

        internal virtual void PrintPosSets(RBBINode n)
        {
            if (n == null)
            {
                return;
            }
            RBBINode.PrintNode(n);
            Console.Out.Write("         Nullable:  " + n.fNullable);

            Console.Out.Write("         firstpos:  ");
            PrintSet(n.fFirstPosSet);

            Console.Out.Write("         lastpos:   ");
            PrintSet(n.fLastPosSet);

            Console.Out.Write("         followpos: ");
            PrintSet(n.fFollowPos);

            PrintPosSets(n.fLeftChild);
            PrintPosSets(n.fRightChild);
        }




        //-----------------------------------------------------------------------------
        //
        //   getTableSize()    Calculate the size in bytes of the runtime form of this
        //                     state transition table.
        //
        //          Note:  Refer to common/rbbidata.h from ICU4C for the declarations
        //                 of the structures being matched by this calculation.
        //
        //-----------------------------------------------------------------------------
        internal virtual int GetTableSize()
        {
            int size = 0;
            int numRows;
            int numCols;
            int rowSize;

            if (fRB.fTreeRoots[fRootIx] == null)
            {
                return 0;
            }

            size = /*sizeof(RBBIStateTable) - 4 */ 16;    // The header, with no rows to the table.

            numRows = fDStates.Count;
            numCols = fRB.fSetBuilder.NumCharCategories;

            //  Note  The declaration of RBBIStateTableRow is for a table of two columns.
            //        Therefore we subtract two from numCols when determining
            //        how much storage to add to a row for the total columns.
            // rowSize = sizeof(RBBIStateTableRow) + sizeof(uint16_t)*(numCols-2);
            rowSize = 8 + 2 * numCols;
            size += numRows * rowSize;
            while (size % 8 > 0)
            {    // Size must be multiple of 8 bytes in size.
                size++;
            }

            return size;
        }



        //-----------------------------------------------------------------------------
        //
        //   exportTable()    export the state transition table in the ICU4C format.
        //
        //                    Most of the table is 16 bit shorts.  This function exports
        //                    the whole thing as an array of shorts.
        //
        //                    The size of the array must be rounded up to a multiple of
        //                    8 bytes.
        //
        //                    See struct RBBIStateTable in ICU4C, common/rbbidata.h
        //
        //-----------------------------------------------------------------------------

        internal virtual short[] ExportTable()
        {
            int state;
            int col;

            if (fRB.fTreeRoots[fRootIx] == null)
            {
                return new short[0];
            }

            Assert.Assrt(fRB.fSetBuilder.NumCharCategories < 0x7fff &&
                fDStates.Count < 0x7fff);

            int numStates = fDStates.Count;

            // Size of table size in shorts.
            //  the "4" is the size of struct RBBIStateTableRow, the row header part only.
            int rowLen = 4 + fRB.fSetBuilder.NumCharCategories;
            int tableSize = GetTableSize() / 2;


            short[] table = new short[tableSize];

            //
            // Fill in the header fields.
            //      Annoying because they really want to be ints, not shorts.
            //
            // RBBIStateTable.fNumStates
            table[RBBIDataWrapper.NUMSTATES] = (short)(numStates.TripleShift(16));
            table[RBBIDataWrapper.NUMSTATES + 1] = (short)(numStates & 0x0000ffff);

            // RBBIStateTable.fRowLen
            table[RBBIDataWrapper.ROWLEN] = (short)(rowLen.TripleShift(16));
            table[RBBIDataWrapper.ROWLEN + 1] = (short)(rowLen & 0x0000ffff);

            // RBBIStateTable.fFlags
            int flags = 0;
            if (fRB.fLookAheadHardBreak)
            {
                flags |= RBBIDataWrapper.RBBI_LOOKAHEAD_HARD_BREAK;
            }
            if (fRB.fSetBuilder.SawBOF)
            {
                flags |= RBBIDataWrapper.RBBI_BOF_REQUIRED;
            }
            table[RBBIDataWrapper.FLAGS] = (short)(flags.TripleShift(16));
            table[RBBIDataWrapper.FLAGS + 1] = (short)(flags & 0x0000ffff);

            int numCharCategories = fRB.fSetBuilder.NumCharCategories;
            for (state = 0; state < numStates; state++)
            {
                RBBIStateDescriptor sd = fDStates[state];
                int row = 8 + state * rowLen;
                Assert.Assrt(-32768 < sd.fAccepting && sd.fAccepting <= 32767);
                Assert.Assrt(-32768 < sd.fLookAhead && sd.fLookAhead <= 32767);
                table[row + RBBIDataWrapper.ACCEPTING] = (short)sd.fAccepting;
                table[row + RBBIDataWrapper.LOOKAHEAD] = (short)sd.fLookAhead;
                table[row + RBBIDataWrapper.TAGIDX] = (short)sd.fTagsIdx;
                for (col = 0; col < numCharCategories; col++)
                {
                    table[row + RBBIDataWrapper.NEXTSTATES + col] = (short)sd.fDtran[col];
                }
            }
            return table;
        }



        //-----------------------------------------------------------------------------
        //
        //   printSet    Debug function.   Print the contents of a set of Nodes
        //
        //-----------------------------------------------------------------------------

        internal virtual void PrintSet(ICollection<RBBINode> s)
        {
            foreach (RBBINode n in s)
            {
                RBBINode.PrintInt32(n.fSerialNum, 8);
            }
            Console.Out.WriteLine();
        }



        //-----------------------------------------------------------------------------
        //
        //   printStates    Debug Function.  Dump the fully constructed state transition table.
        //
        //-----------------------------------------------------------------------------

        internal virtual void PrintStates()
        {
            int c;    // input "character"
            int n;    // state number

            Console.Out.Write("state |           i n p u t     s y m b o l s \n");
            Console.Out.Write("      | Acc  LA    Tag");
            for (c = 0; c < fRB.fSetBuilder.NumCharCategories; c++)
            {
                RBBINode.PrintInt32(c, 3);
            }
            Console.Out.Write("\n");
            Console.Out.Write("      |---------------");
            for (c = 0; c < fRB.fSetBuilder.NumCharCategories; c++)
            {
                Console.Out.Write("---");
            }
            Console.Out.Write("\n");

            for (n = 0; n < fDStates.Count; n++)
            {
                RBBIStateDescriptor sd = fDStates[n];
                RBBINode.PrintInt32(n, 5);
                Console.Out.Write(" | ");

                RBBINode.PrintInt32(sd.fAccepting, 3);
                RBBINode.PrintInt32(sd.fLookAhead, 4);
                RBBINode.PrintInt32(sd.fTagsIdx, 6);
                Console.Out.Write(" ");
                for (c = 0; c < fRB.fSetBuilder.NumCharCategories; c++)
                {
                    RBBINode.PrintInt32(sd.fDtran[c], 3);
                }
                Console.Out.Write("\n");
            }
            Console.Out.Write("\n\n");
        }




        //-----------------------------------------------------------------------------
        //
        //   printRuleStatusTable    Debug Function.  Dump the common rule status table
        //
        //-----------------------------------------------------------------------------

        internal virtual void PrintRuleStatusTable()
        {
            int thisRecord = 0;
            int nextRecord = 0;
            int i;
            List<int> tbl = fRB.fRuleStatusVals;

            Console.Out.Write("index |  tags \n");
            Console.Out.Write("-------------------\n");

            while (nextRecord < tbl.Count)
            {
                thisRecord = nextRecord;
                nextRecord = thisRecord + tbl[thisRecord] + 1;
                RBBINode.PrintInt32(thisRecord, 7);
                for (i = thisRecord + 1; i < nextRecord; i++)
                {
                    int val = tbl[i];
                    RBBINode.PrintInt32(val, 7);
                }
                Console.Out.Write("\n");
            }
            Console.Out.Write("\n\n");
        }


    }
}
