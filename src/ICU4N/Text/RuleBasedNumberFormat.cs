using ICU4N.Globalization;
using ICU4N.Impl;
using ICU4N.Numerics;
using ICU4N.Support.Text;
using ICU4N.Util;
using J2N;
using J2N.Collections.Generic.Extensions;
using J2N.Globalization;
using J2N.Numerics;
using J2N.Text;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Numerics;
using System.Resources;
using System.Text;
using Double = J2N.Numerics.Double;
using StringBuffer = System.Text.StringBuilder;

namespace ICU4N.Text
{
    internal enum NumberPresentation
    {
        SpellOut = 1,
        Ordinal = 2,
        Duration = 3,
        NumberingSystem = 4,
    }

    internal class RuleBasedNumberFormat : NumberFormat
    {
        //-----------------------------------------------------------------------
        // constants
        //-----------------------------------------------------------------------

        // Generated by serialver from JDK 1.4.1_01
        //static final long serialVersionUID = -7664252765575395068L;

        ///**
        // * Selector code that tells the constructor to create a spellout formatter
        // * @stable ICU 2.0
        // */
        //public const int SPELLOUT = 1;

        ///**
        // * Selector code that tells the constructor to create an ordinal formatter
        // * @stable ICU 2.0
        // */
        //public const int ORDINAL = 2;

        ///**
        // * Selector code that tells the constructor to create a duration formatter
        // * @stable ICU 2.0
        // */
        //public const int DURATION = 3;

        ///**
        // * Selector code that tells the constructor to create a numbering system formatter
        // * @stable ICU 4.2
        // */
        //public const int NUMBERING_SYSTEM = 4;

        //-----------------------------------------------------------------------
        // data members
        //-----------------------------------------------------------------------

        /**
         * The formatter's rule sets.
         */
        [NonSerialized]
        private NFRuleSet[] ruleSets = null;

        /**
         * The formatter's rule names mapped to rule sets.
         */
        [NonSerialized]
        private IDictionary<string, NFRuleSet> ruleSetsMap = null;

        /**
         * A pointer to the formatter's default rule set.  This is always included
         * in ruleSets.
         */
        [NonSerialized]
        private NFRuleSet defaultRuleSet = null;

        /**
         * The formatter's locale.  This is used to create DecimalFormatSymbols and
         * Collator objects.
         * @serial
         */
        private UCultureInfo locale = null;

        /**
         * The formatter's rounding mode.
         * @serial
         */
        private Numerics.BigMath.RoundingMode roundingMode = Numerics.BigMath.RoundingMode.Unnecessary;

        /**
         * Collator to be used in lenient parsing.  This variable is lazy-evaluated:
         * the collator is actually created the first time the client does a parse
         * with lenient-parse mode turned on.
         */
        [NonSerialized]
        private IRbnfLenientScannerProvider scannerProvider = null;

        // flag to mark whether we've previously looked for a scanner and failed
        [NonSerialized]
        private bool lookedForScanner;

        /**
         * The DecimalFormatSymbols object that any DecimalFormat objects this
         * formatter uses should use.  This variable is lazy-evaluated: it isn't
         * filled in if the rule set never uses a DecimalFormat pattern.
         */
        [NonSerialized]
        private DecimalFormatSymbols decimalFormatSymbols = null;

        /**
         * The NumberFormat used when lenient parsing numbers.  This needs to reflect
         * the locale.  This is lazy-evaluated, like decimalFormatSymbols.  It is
         * here so it can be shared by different NFSubstitutions.
         */
        [NonSerialized]
        private DecimalFormat decimalFormat = null;

        /**
         * The rule used when dealing with infinity. This is lazy-evaluated, and derived from decimalFormat.
         * It is here so it can be shared by different NFRuleSets.
         */
        [NonSerialized]
        private NFRule defaultInfinityRule = null;

        /**
         * The rule used when dealing with IEEE 754 NaN. This is lazy-evaluated, and derived from decimalFormat.
         * It is here so it can be shared by different NFRuleSets.
         */
        [NonSerialized]
        private NFRule defaultNaNRule = null;

        /**
         * Flag specifying whether lenient parse mode is on or off.  Off by default.
         * @serial
         */
        private bool lenientParse = false;

        /**
         * If the description specifies lenient-parse rules, they're stored here until
         * the collator is created.
         */
        [NonSerialized]
        private string lenientParseRules;

        /**
         * If the description specifies post-process rules, they're stored here until
         * post-processing is required.
         */
        [NonSerialized]
        private string postProcessRules;

        /**
         * Post processor lazily constructed from the postProcessRules.
         */
        [NonSerialized]
        private IRbnfPostProcessor postProcessor;

        /**
         * Localizations for rule set names.
         * @serial
         */
        private IDictionary<string, string[]> ruleSetDisplayNames;

        /**
         * The public rule set names;
         * @serial
         */
        private string[] publicRuleSetNames;

        /**
         * Data for handling context-based capitalization
         */
        private bool capitalizationInfoIsSet = false;
        private bool capitalizationForListOrMenu = false;
        private bool capitalizationForStandAlone = false;
        [NonSerialized]
        private BreakIterator capitalizationBrkIter = null;


        private static readonly bool DEBUG = ICUDebug.Enabled("rbnf");

        //-----------------------------------------------------------------------
        // constructors
        //-----------------------------------------------------------------------

        /**
         * Creates a RuleBasedNumberFormat that behaves according to the description
         * passed in.  The formatter uses the default <code>FORMAT</code> locale.
         * @param description A description of the formatter's desired behavior.
         * See the class documentation for a complete explanation of the description
         * syntax.
         * @see Category#FORMAT
         * @stable ICU 2.0
         */
        public RuleBasedNumberFormat(string description)
        {
            locale = UCultureInfo.CurrentCulture; // ICU4N TODO: In .NET, the default is to use invariant culture
            Init(description, null);
        }

        /**
         * Creates a RuleBasedNumberFormat that behaves according to the description
         * passed in.  The formatter uses the default <code>FORMAT</code> locale.
         * <p>
         * The localizations data provides information about the public
         * rule sets and their localized display names for different
         * locales. The first element in the list is an array of the names
         * of the public rule sets.  The first element in this array is
         * the initial default ruleset.  The remaining elements in the
         * list are arrays of localizations of the names of the public
         * rule sets.  Each of these is one longer than the initial array,
         * with the first String being the ULocale ID, and the remaining
         * Strings being the localizations of the rule set names, in the
         * same order as the initial array.
         * @param description A description of the formatter's desired behavior.
         * See the class documentation for a complete explanation of the description
         * syntax.
         * @param localizations a list of localizations for the rule set
         * names in the description.
         * @see Category#FORMAT
         * @stable ICU 3.2
         */
        public RuleBasedNumberFormat(string description, string[][] localizations)
        {
            locale = UCultureInfo.CurrentCulture; // ICU4N TODO: In .NET, the default is to use invariant culture
            Init(description, localizations);
        }

        /**
         * Creates a RuleBasedNumberFormat that behaves according to the description
         * passed in.  The formatter uses the specified locale to determine the
         * characters to use when formatting in numerals, and to define equivalences
         * for lenient parsing.
         * @param description A description of the formatter's desired behavior.
         * See the class documentation for a complete explanation of the description
         * syntax.
         * @param locale A locale, which governs which characters are used for
         * formatting values in numerals, and which characters are equivalent in
         * lenient parsing.
         * @stable ICU 2.0
         */
        public RuleBasedNumberFormat(string description, CultureInfo locale)
            : this(description, locale.ToUCultureInfo())
        {
        }

        /**
         * Creates a RuleBasedNumberFormat that behaves according to the description
         * passed in.  The formatter uses the specified locale to determine the
         * characters to use when formatting in numerals, and to define equivalences
         * for lenient parsing.
         * @param description A description of the formatter's desired behavior.
         * See the class documentation for a complete explanation of the description
         * syntax.
         * @param locale A locale, which governs which characters are used for
         * formatting values in numerals, and which characters are equivalent in
         * lenient parsing.
         * @stable ICU 3.2
         */
        public RuleBasedNumberFormat(string description, UCultureInfo locale)
        {
            this.locale = locale;
            Init(description, null);
        }

        /**
         * Creates a RuleBasedNumberFormat that behaves according to the description
         * passed in.  The formatter uses the specified locale to determine the
         * characters to use when formatting in numerals, and to define equivalences
         * for lenient parsing.
         * <p>
         * The localizations data provides information about the public
         * rule sets and their localized display names for different
         * locales. The first element in the list is an array of the names
         * of the public rule sets.  The first element in this array is
         * the initial default ruleset.  The remaining elements in the
         * list are arrays of localizations of the names of the public
         * rule sets.  Each of these is one longer than the initial array,
         * with the first String being the ULocale ID, and the remaining
         * Strings being the localizations of the rule set names, in the
         * same order as the initial array.
         * @param description A description of the formatter's desired behavior.
         * See the class documentation for a complete explanation of the description
         * syntax.
         * @param localizations a list of localizations for the rule set names in the description.
         * @param locale A ULocale that governs which characters are used for
         * formatting values in numerals, and determines which characters are equivalent in
         * lenient parsing.
         * @stable ICU 3.2
         */
        public RuleBasedNumberFormat(string description, string[][] localizations, UCultureInfo locale)
        {
            this.locale = locale;
            Init(description, localizations);
        }

        /**
         * Creates a RuleBasedNumberFormat from a predefined description.  The selector
         * code chooses among three possible predefined formats: spellout, ordinal,
         * and duration.
         * @param locale The locale for the formatter.
         * @param format A selector code specifying which kind of formatter to create for that
         * locale.  There are three legal values: SPELLOUT, which creates a formatter that
         * spells out a value in words in the desired language, ORDINAL, which attaches
         * an ordinal suffix from the desired language to the end of a number (e.g. "123rd"),
         * and DURATION, which formats a duration in seconds as hours, minutes, and seconds.
         * @stable ICU 2.0
         */
        public RuleBasedNumberFormat(CultureInfo locale, NumberPresentation format)
            : this(locale.ToUCultureInfo(), format)
        {
        }

        /**
         * Creates a RuleBasedNumberFormat from a predefined description.  The selector
         * code chooses among three possible predefined formats: spellout, ordinal,
         * and duration.
         * @param locale The locale for the formatter.
         * @param format A selector code specifying which kind of formatter to create for that
         * locale.  There are four legal values: SPELLOUT, which creates a formatter that
         * spells out a value in words in the desired language, ORDINAL, which attaches
         * an ordinal suffix from the desired language to the end of a number (e.g. "123rd"),
         * DURATION, which formats a duration in seconds as hours, minutes, and seconds, and
         * NUMBERING_SYSTEM, which is used to invoke rules for alternate numbering
         * systems such as the Hebrew numbering system, or for Roman numerals, etc..
         * @stable ICU 3.2
         */
        public RuleBasedNumberFormat(UCultureInfo locale, NumberPresentation format)
        {
            this.locale = locale;

            ICUResourceBundle bundle = (ICUResourceBundle)UResourceBundle.
                GetBundleInstance(ICUData.IcuRuleBasedNumberFormatBaseName, locale);

            // TODO: determine correct actual/valid locale.  Note ambiguity
            // here -- do actual/valid refer to pattern, DecimalFormatSymbols,
            // or Collator?
            UCultureInfo uloc = bundle.UCulture;
            SetCulture(uloc, uloc);

            StringBuilder description = new StringBuilder();
            String[][] localizations = null;

            try
            {
                ICUResourceBundle rules = bundle.GetWithFallback("RBNFRules/" + rulenames[(int)format - 1]);
                UResourceBundleEnumerator it = rules.GetEnumerator();
                while (it.MoveNext())
                {
                    description.Append(it.Current.GetString());
                }
            }
            catch (MissingManifestResourceException e1)
            {
            }

            // We use findTopLevel() instead of get() because
            // it's faster when we know that it's usually going to fail.
            UResourceBundle locNamesBundle = bundle.FindTopLevel(locnames[(int)format - 1]);
            if (locNamesBundle != null)
            {
                localizations = new string[locNamesBundle.Length][];
                for (int i = 0; i < localizations.Length; ++i)
                {
                    localizations[i] = locNamesBundle.Get(i).GetStringArray();
                }
            }
            // else there are no localized names. It's not that important.

            Init(description.ToString(), localizations);
        }

        private static readonly string[] rulenames = {
            "SpelloutRules", "OrdinalRules", "DurationRules", "NumberingSystemRules",
        };
        private static readonly string[] locnames = {
            "SpelloutLocalizations", "OrdinalLocalizations", "DurationLocalizations", "NumberingSystemLocalizations",
        };

        /**
         * Creates a RuleBasedNumberFormat from a predefined description.  Uses the
         * default <code>FORMAT</code> locale.
         * @param format A selector code specifying which kind of formatter to create.
         * There are three legal values: SPELLOUT, which creates a formatter that spells
         * out a value in words in the default locale's language, ORDINAL, which attaches
         * an ordinal suffix from the default locale's language to a numeral, and
         * DURATION, which formats a duration in seconds as hours, minutes, and seconds always rounding down.
         * or NUMBERING_SYSTEM, which is used for alternate numbering systems such as Hebrew.
         * @see Category#FORMAT
         * @stable ICU 2.0
         */
        public RuleBasedNumberFormat(NumberPresentation format)
            : this(UCultureInfo.CurrentCulture, format)
        {
        }

        //-----------------------------------------------------------------------
        // boilerplate
        //-----------------------------------------------------------------------

        /**
         * Duplicates this formatter.
         * @return A RuleBasedNumberFormat that is equal to this one.
         * @stable ICU 2.0
         */
        public override object Clone()
        {
            return base.Clone();
        }

        /**
         * Tests two RuleBasedNumberFormats for equality.
         * @param that The formatter to compare against this one.
         * @return true if the two formatters have identical behavior.
         * @stable ICU 2.0
         */
        public override bool Equals(object that)
        {
            // if the other object isn't a RuleBasedNumberFormat, that's
            // all we need to know
            // Test for capitalization info equality is adequately handled
            // by the NumberFormat test for capitalizationSetting equality;
            // the info here is just derived from that.

            // cast the other object's pointer to a pointer to a
            // RuleBasedNumberFormat
            if (!(that is RuleBasedNumberFormat that2))
            {
                return false;
            }
            else
            {
                // compare their locales and lenient-parse modes
                if (!locale.Equals(that2.locale) || lenientParse != that2.lenientParse)
                {
                    return false;
                }

                // if that succeeds, then compare their rule set lists
                if (ruleSets.Length != that2.ruleSets.Length)
                {
                    return false;
                }
                for (int i = 0; i < ruleSets.Length; i++)
                {
                    if (!ruleSets[i].Equals(that2.ruleSets[i]))
                    {
                        return false;
                    }
                }

                return true;
            }
        }

        /**
         * Mock implementation of GetHashCode(). This implementation always returns a constant
         * value. When Java assertion is enabled, this method triggers an assertion failure.
         * @internal
         * @deprecated This API is ICU internal only.
         */
        //@Deprecated
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        /**
         * Generates a textual description of this formatter.
         * @return a String containing a rule set that will produce a RuleBasedNumberFormat
         * with identical behavior to this one.  This won't necessarily be identical
         * to the rule set description that was originally passed in, but will produce
         * the same result.
         * @stable ICU 2.0
         */
        public override string ToString()
        {

            // accumulate the descriptions of all the rule sets in a
            // StringBuffer, then cast it to a String and return it
            StringBuilder result = new StringBuilder();
            foreach (NFRuleSet ruleSet in ruleSets)
            {
                result.Append(ruleSet.ToString());
            }
            return result.ToString();
        }

        // ICU4N TODO: Serialization
        /////**
        //// * Writes this object to a stream.
        //// * @param out The stream to write to.
        //// */
        //private void writeObject(java.io.ObjectOutputStream out)
        //{
        //// we just write the textual description to the stream, so we
        //// have an implementation-independent streaming format
        //out.writeUTF(this.toString());
        //out.writeObject(this.locale);
        //out.writeInt(this.roundingMode);
        //}

        ///**
        // * Reads this object in from a stream.
        // * @param in The stream to read from.
        // */
        //private void readObject(java.io.ObjectInputStream in)
        //{

        //    // read the description in from the stream
        //    String description = in.readUTF();
        //    ULocale loc;

        //    try {
        //        loc = (ULocale) in.readObject();
        //    } catch (Exception e) {
        //        loc = ULocale.getDefault(Category.FORMAT);
        //    }
        //    try
        //    {
        //        roundingMode = in.readInt();
        //    }
        //    catch (Exception ignored)
        //    {
        //    }

        //    // build a brand-new RuleBasedNumberFormat from the description,
        //    // then steal its substructure.  This object's substructure and
        //    // the temporary RuleBasedNumberFormat drop on the floor and
        //    // get swept up by the garbage collector
        //    RuleBasedNumberFormat temp = new RuleBasedNumberFormat(description, loc);
        //    ruleSets = temp.ruleSets;
        //    ruleSetsMap = temp.ruleSetsMap;
        //    defaultRuleSet = temp.defaultRuleSet;
        //    publicRuleSetNames = temp.publicRuleSetNames;
        //    decimalFormatSymbols = temp.decimalFormatSymbols;
        //    decimalFormat = temp.decimalFormat;
        //    locale = temp.locale;
        //    defaultInfinityRule = temp.defaultInfinityRule;
        //    defaultNaNRule = temp.defaultNaNRule;
        //}


        //-----------------------------------------------------------------------
        // public API functions
        //-----------------------------------------------------------------------

        /**
         * Returns a list of the names of all of this formatter's public rule sets.
         * @return A list of the names of all of this formatter's public rule sets.
         * @stable ICU 2.0
         */
        public virtual string[] GetRuleSetNames()
        {
            return (string[])publicRuleSetNames.Clone();
        }

        /**
         * Return a list of locales for which there are locale-specific display names
         * for the rule sets in this formatter.  If there are no localized display names, return null.
         * @return an array of the ULocales for which there is rule set display name information
         * @stable ICU 3.2
         */
        public virtual UCultureInfo[] GetRuleSetDisplayNameLocales()
        {
            if (ruleSetDisplayNames != null)
            {
                ICollection<string> s = ruleSetDisplayNames.Keys;
                string[] locales = s.ToArray();
                Array.Sort(locales, CaseInsensitiveComparer.Default  /*StringComparer.OrdinalIgnoreCase*/);
                UCultureInfo[] result = new UCultureInfo[locales.Length];
                for (int i = 0; i < locales.Length; ++i)
                {
                    result[i] = new UCultureInfo(locales[i]);
                }
                return result;
            }
            return null;
        }

        private string[] GetNameListForLocale(UCultureInfo loc)
        {
            if (loc != null && ruleSetDisplayNames != null)
            {
                //String[] localeNames = { loc.getBaseName(), ULocale.getDefault(Category.DISPLAY).getBaseName() };
                string[] localeNames = { loc.Name, UCultureInfo.CurrentUICulture.Name };
                foreach (string lname in localeNames)
                {
                    string lname2 = lname;
                    while (lname2.Length > 0)
                    {
                        //String[] names = ruleSetDisplayNames.get(lname);
                        if (ruleSetDisplayNames.TryGetValue(lname2, out string[] names) || names != null)
                        {
                            return names;
                        }
                        //lname = UCultureInfo.getFallback(lname);
                        lname2 = UCultureInfo.GetParent(lname2);
                    }
                }
            }
            return null;
        }

        /**
         * Return the rule set display names for the provided locale.  These are in the same order
         * as those returned by getRuleSetNames.  The locale is matched against the locales for
         * which there is display name data, using normal fallback rules.  If no locale matches,
         * the default display names are returned.  (These are the internal rule set names minus
         * the leading '%'.)
         * @return an array of the locales that have display name information
         * @see #getRuleSetNames
         * @stable ICU 3.2
         */
        public virtual string[] GetRuleSetDisplayNames(UCultureInfo loc)
        {
            string[] names = GetNameListForLocale(loc);
            if (names != null)
            {
                return (string[])names.Clone();
            }
            names = GetRuleSetNames();
            for (int i = 0; i < names.Length; ++i)
            {
                names[i] = names[i].Substring(1);
            }
            return names;
        }

        /**
         * Return the rule set display names for the current default <code>DISPLAY</code> locale.
         * @return an array of the display names
         * @see #getRuleSetDisplayNames(ULocale)
         * @see Category#DISPLAY
         * @stable ICU 3.2
         */
        public virtual string[] GetRuleSetDisplayNames()
        {
            return GetRuleSetDisplayNames(UCultureInfo.CurrentUICulture);
        }

        /**
         * Return the rule set display name for the provided rule set and locale.
         * The locale is matched against the locales for which there is display name data, using
         * normal fallback rules.  If no locale matches, the default display name is returned.
         * @return the display name for the rule set
         * @see #getRuleSetDisplayNames
         * @throws IllegalArgumentException if ruleSetName is not a valid rule set name for this format
         * @stable ICU 3.2
         */
        public virtual string GetRuleSetDisplayName(string ruleSetName, UCultureInfo loc)
        {
            string[] rsnames = publicRuleSetNames;
            for (int ix = 0; ix < rsnames.Length; ++ix)
            {
                if (rsnames[ix].Equals(ruleSetName, StringComparison.Ordinal))
                {
                    string[] names = GetNameListForLocale(loc);
                    if (names != null)
                    {
                        return names[ix];
                    }
                    return rsnames[ix].Substring(1);
                }
            }
            throw new ArgumentException("unrecognized rule set name: " + ruleSetName);
        }

        /**
         * Return the rule set display name for the provided rule set in the current default <code>DISPLAY</code> locale.
         * @return the display name for the rule set
         * @see #getRuleSetDisplayName(String,ULocale)
         * @see Category#DISPLAY
         * @stable ICU 3.2
         */
        public virtual string GetRuleSetDisplayName(string ruleSetName)
        {
            return GetRuleSetDisplayName(ruleSetName, UCultureInfo.CurrentUICulture);
        }

        /**
         * Formats the specified number according to the specified rule set.
         * @param number The number to format.
         * @param ruleSet The name of the rule set to format the number with.
         * This must be the name of a valid public rule set for this formatter.
         * @return A textual representation of the number.
         * @stable ICU 2.0
         */
        public virtual string Format(double number, string ruleSet)
        {
            if (ruleSet.StartsWith("%%", StringComparison.Ordinal))
            {
                throw new ArgumentException("Can't use internal rule set");
            }
            return AdjustForContext(Format(number, FindRuleSet(ruleSet)));
        }

        /**
         * Formats the specified number according to the specified rule set.
         * (If the specified rule set specifies a master ["x.0"] rule, this function
         * ignores it.  Convert the number to a double first if you ned it.)  This
         * function preserves all the precision in the long-- it doesn't convert it
         * to a double.
         * @param number The number to format.
         * @param ruleSet The name of the rule set to format the number with.
         * This must be the name of a valid public rule set for this formatter.
         * @return A textual representation of the number.
         * @stable ICU 2.0
         */
        public virtual string Format(long number, string ruleSet)
        {
            if (ruleSet.StartsWith("%%", StringComparison.Ordinal))
            {
                throw new ArgumentException("Can't use internal rule set");
            }
            return AdjustForContext(Format(number, FindRuleSet(ruleSet)));
        }

        /**
         * Formats the specified number using the formatter's default rule set.
         * (The default rule set is the last public rule set defined in the description.)
         * @param number The number to format.
         * @param toAppendTo A StringBuffer that the result should be appended to.
         * @param ignore This function doesn't examine or update the field position.
         * @return toAppendTo
         * @stable ICU 2.0
         */
        public override StringBuffer Format(double number,
                                   StringBuffer toAppendTo,
                                   FieldPosition ignore)
        {
            // this is one of the inherited format() methods.  Since it doesn't
            // have a way to select the rule set to use, it just uses the
            // default one
            // Note, the BigInteger/BigDecimal methods below currently go through this.
            if (toAppendTo.Length == 0)
            {
                toAppendTo.Append(AdjustForContext(Format(number, defaultRuleSet)));
            }
            else
            {
                // appending to other text, don't capitalize
                toAppendTo.Append(Format(number, defaultRuleSet));
            }
            return toAppendTo;
        }

        /**
         * Formats the specified number using the formatter's default rule set.
         * (The default rule set is the last public rule set defined in the description.)
         * (If the specified rule set specifies a master ["x.0"] rule, this function
         * ignores it.  Convert the number to a double first if you ned it.)  This
         * function preserves all the precision in the long-- it doesn't convert it
         * to a double.
         * @param number The number to format.
         * @param toAppendTo A StringBuffer that the result should be appended to.
         * @param ignore This function doesn't examine or update the field position.
         * @return toAppendTo
         * @stable ICU 2.0
         */
        public override StringBuffer Format(long number,
                                   StringBuffer toAppendTo,
                                   FieldPosition ignore)
        {
            // this is one of the inherited format() methods.  Since it doesn't
            // have a way to select the rule set to use, it just uses the
            // default one
            if (toAppendTo.Length == 0)
            {
                toAppendTo.Append(AdjustForContext(Format(number, defaultRuleSet)));
            }
            else
            {
                // appending to other text, don't capitalize
                toAppendTo.Append(Format(number, defaultRuleSet));
            }
            return toAppendTo;
        }

        // ICU4N TODO: System.Numerics.BigInteger overload
        ///**
        // * <strong style="font-family: helvetica; color: red;">NEW</strong>
        // * Implement com.ibm.icu.text.NumberFormat:
        // * Format a BigInteger.
        // * @stable ICU 2.0
        // */
        //public override StringBuffer Format(BigInteger number,
        //                           StringBuffer toAppendTo,
        //                           FieldPosition pos)
        //{
        //    return Format(new BigDecimal(number), toAppendTo, pos);
        //}

        /**
         * <strong style="font-family: helvetica; color: red;">NEW</strong>
         * Implement com.ibm.icu.text.NumberFormat:
         * Format a BigInteger.
         * @stable ICU 2.0
         */
        public override StringBuffer Format(Numerics.BigMath.BigInteger number,
                                   StringBuffer toAppendTo,
                                   FieldPosition pos)
        {
            return Format(new Numerics.BigDecimal(number), toAppendTo, pos);
        }

        /**
         * <strong style="font-family: helvetica; color: red;">NEW</strong>
         * Implement com.ibm.icu.text.NumberFormat:
         * Format a BigDecimal.
         * @stable ICU 2.0
         */
        public override StringBuffer Format(Numerics.BigMath.BigDecimal number,
                                        StringBuffer toAppendTo,
                                        FieldPosition pos)
        {
            return Format(new Numerics.BigDecimal(number), toAppendTo, pos);
        }

        private static readonly Numerics.BigDecimal MAX_VALUE = Numerics.BigDecimal.GetInstance(long.MaxValue);
        private static readonly Numerics.BigDecimal MIN_VALUE = Numerics.BigDecimal.GetInstance(long.MinValue);

        /**
         * <strong style="font-family: helvetica; color: red;">NEW</strong>
         * Implement com.ibm.icu.text.NumberFormat:
         * Format a BigDecimal.
         * @stable ICU 2.0
         */
        public override StringBuffer Format(Numerics.BigDecimal number,
                                   StringBuffer toAppendTo,
                                   FieldPosition pos)
        {
            if (MIN_VALUE.CompareTo(number) > 0 || MAX_VALUE.CompareTo(number) < 0)
            {
                // We're outside of our normal range that this framework can handle.
                // The DecimalFormat will provide more accurate results.
                return DecimalFormat.Format(number, toAppendTo, pos);
            }
            if (number.Scale == 0)
            {
                return Format(number.ToInt64(), toAppendTo, pos);
            }
            return Format(number.ToDouble(), toAppendTo, pos);
        }

        /**
         * Parses the specified string, beginning at the specified position, according
         * to this formatter's rules.  This will match the string against all of the
         * formatter's public rule sets and return the value corresponding to the longest
         * parseable substring.  This function's behavior is affected by the lenient
         * parse mode.
         * @param text The string to parse
         * @param parsePosition On entry, contains the position of the first character
         * in "text" to examine.  On exit, has been updated to contain the position
         * of the first character in "text" that wasn't consumed by the parse.
         * @return The number that corresponds to the parsed text.  This will be an
         * instance of either Long or Double, depending on whether the result has a
         * fractional part.
         * @see #setLenientParseMode
         * @stable ICU 2.0
         */
        public override Number Parse(string text, ParsePosition parsePosition)
        {

            // parsePosition tells us where to start parsing.  We copy the
            // text in the string from here to the end inro a new string,
            // and create a new ParsePosition and result variable to use
            // for the duration of the parse operation
            string workingText = text.Substring(parsePosition.Index);
            ParsePosition workingPos = new ParsePosition(0);
            Number tempResult = null;

            // keep track of the largest number of characters consumed in
            // the various trials, and the result that corresponds to it
            Number result = NFRule.ZERO;
            ParsePosition highWaterMark = new ParsePosition(workingPos.Index);

            // iterate over the public rule sets (beginning with the default one)
            // and try parsing the text with each of them.  Keep track of which
            // one consumes the most characters: that's the one that determines
            // the result we return
            for (int i = ruleSets.Length - 1; i >= 0; i--)
            {
                // skip private or unparseable rule sets
                if (!ruleSets[i].IsPublic || !ruleSets[i].IsParseable)
                {
                    continue;
                }

                // try parsing the string with the rule set.  If it gets past the
                // high-water mark, update the high-water mark and the result
                tempResult = ruleSets[i].Parse(workingText, workingPos, double.MaxValue);
                if (workingPos.Index > highWaterMark.Index)
                {
                    result = tempResult;
                    highWaterMark.Index = workingPos.Index;
                }
                // commented out because this API on ParsePosition doesn't exist in 1.1.x
                //            if (workingPos.ErrorIndex > highWaterMark.ErrorIndex) {
                //                highWaterMark.ErrorIndex = workingPos.ErrorIndex;
                //            }

                // if we manage to use up all the characters in the string,
                // we don't have to try any more rule sets
                if (highWaterMark.Index == workingText.Length)
                {
                    break;
                }

                // otherwise, reset our internal parse position to the
                // beginning and try again with the next rule set
                workingPos.Index = 0;
            }

            // add the high water mark to our original parse position and
            // return the result
            parsePosition.Index = parsePosition.Index + highWaterMark.Index;
            // commented out because this API on ParsePosition doesn't exist in 1.1.x
            //        if (highWaterMark.Index == 0) {
            //            parsePosition.ErrorIndex = parsePosition.Index + highWaterMark.ErrorIndex;
            //        }
            return result;
        }

        ///**
        // * Turns lenient parse mode on and off.
        // *
        // * When in lenient parse mode, the formatter uses an RbnfLenientScanner
        // * for parsing the text.  Lenient parsing is only in effect if a scanner
        // * is set.  If a provider is not set, and this is used for parsing,
        // * a default scanner <code>RbnfLenientScannerProviderImpl</code> will be set if
        // * it is available on the classpath.  Otherwise this will have no effect.
        // *
        // * @param enabled If true, turns lenient-parse mode on; if false, turns it off.
        // * @see RbnfLenientScanner
        // * @see RbnfLenientScannerProvider
        // * @stable ICU 2.0
        // */
        //public void SetLenientParseMode(bool enabled)
        //{
        //    lenientParse = enabled;
        //}

        /**
         * Returns true if lenient-parse mode is turned on.  Lenient parsing is off
         * by default.
         * @return true if lenient-parse mode is turned on.
         * @see #setLenientParseMode
         * @stable ICU 2.0
         */
        public virtual bool LenientParseEnabled
        {
            get => lenientParse;
            set => lenientParse = value;
        }

        ///**
        // * Sets the provider for the lenient scanner.  If this has not been set,
        // * {@link #setLenientParseMode}
        // * has no effect.  This is necessary to decouple collation from format code.
        // * @param scannerProvider the provider
        // * @see #setLenientParseMode
        // * @see #getLenientScannerProvider
        // * @stable ICU 4.4
        // */
        //public void setLenientScannerProvider(RbnfLenientScannerProvider scannerProvider)
        //{
        //    this.scannerProvider = scannerProvider;
        //}

        /**
         * Returns the lenient scanner provider.  If none was set, and lenient parse is
         * enabled, this will attempt to instantiate a default scanner, setting it if
         * it was successful.  Otherwise this returns false.
         *
         * @see #setLenientScannerProvider
         * @stable ICU 4.4
         */
        public virtual IRbnfLenientScannerProvider LenientScannerProvider
        {
            get
            {
                // there's a potential race condition if two threads try to set/get the scanner at
                // the same time, but you get what you get, and you shouldn't be using this from
                // multiple threads anyway.
                if (scannerProvider == null && lenientParse && !lookedForScanner)
                {
                    try
                    {
                        lookedForScanner = true;
                        // ICU4N TODO: Why use Reflection here?
                        //Class <?> cls = Class.forName("com.ibm.icu.impl.text.RbnfScannerProviderImpl");
                        //RbnfLenientScannerProvider provider = (RbnfLenientScannerProvider)cls.newInstance();
                        //setLenientScannerProvider(provider);

                    }
                    catch (Exception e)
                    {
                        // any failure, we just ignore and return null
                    }
                }

                return scannerProvider;
            }
            set => scannerProvider = value;
        }

        /**
         * Override the default rule set to use.  If ruleSetName is null, reset
         * to the initial default rule set.
         * @param ruleSetName the name of the rule set, or null to reset the initial default.
         * @throws IllegalArgumentException if ruleSetName is not the name of a public ruleset.
         * @stable ICU 2.0
         */
        public virtual void SetDefaultRuleSet(string ruleSetName)
        {
            if (ruleSetName == null)
            {
                if (publicRuleSetNames.Length > 0)
                {
                    defaultRuleSet = FindRuleSet(publicRuleSetNames[0]);
                }
                else
                {
                    defaultRuleSet = null;
                    int n = ruleSets.Length;
                    while (--n >= 0)
                    {
                        string currentName = ruleSets[n].Name;
                        if (currentName.Equals("%spellout-numbering", StringComparison.Ordinal) ||
                            currentName.Equals("%digits-ordinal", StringComparison.Ordinal) ||
                            currentName.Equals("%duration", StringComparison.Ordinal))
                        {

                            defaultRuleSet = ruleSets[n];
                            return;
                        }
                    }

                    n = ruleSets.Length;
                    while (--n >= 0)
                    {
                        if (ruleSets[n].IsPublic)
                        {
                            defaultRuleSet = ruleSets[n];
                            break;
                        }
                    }
                }
            }
            else if (ruleSetName.StartsWith("%%", StringComparison.Ordinal))
            {
                throw new ArgumentException("cannot use private rule set: " + ruleSetName);
            }
            else
            {
                defaultRuleSet = FindRuleSet(ruleSetName);
            }
        }

        /**
         * Return the name of the current default rule set.
         * @return the name of the current default rule set, if it is public, else the empty string.
         * @stable ICU 3.0
         */
        public virtual string DefaultRuleSetName
        {
            get
            {
                if (defaultRuleSet != null && defaultRuleSet.IsPublic)
                {
                    return defaultRuleSet.Name;
                }
                return "";
            }
            //set => SetDefaultRuleSet(value);
        }

        /**
         * Sets the decimal format symbols used by this formatter. The formatter uses a copy of the
         * provided symbols.
         *
         * @param newSymbols desired DecimalFormatSymbols
         * @see DecimalFormatSymbols
         * @stable ICU 49
         */
        public virtual void SetDecimalFormatSymbols(DecimalFormatSymbols newSymbols)
        {
            if (newSymbols != null)
            {
                decimalFormatSymbols = (DecimalFormatSymbols)newSymbols.Clone();
                if (decimalFormat != null)
                {
                    decimalFormat.SetDecimalFormatSymbols(decimalFormatSymbols);
                }
                if (defaultInfinityRule != null)
                {
                    defaultInfinityRule = null;
                    var _ = DefaultInfinityRule; // Reset with the new DecimalFormatSymbols
                }
                if (defaultNaNRule != null)
                {
                    defaultNaNRule = null;
                    var _ = DefaultNaNRule; // Reset with the new DecimalFormatSymbols
                }

                // Apply the new decimalFormatSymbols by reparsing the rulesets
                foreach (NFRuleSet ruleSet in ruleSets)
                {
                    ruleSet.SetDecimalFormatSymbols(decimalFormatSymbols);
                }
            }
        }

        /**
         * {@icu} Set a particular DisplayContext value in the formatter,
         * such as CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
         * NumberFormat.
         *
         * @param context The DisplayContext value to set.
         * @stable ICU 53
         */
        // Here we override the NumberFormat implementation in order to
        // lazily initialize relevant items
        public override void SetContext(DisplayContext context)
        {
            base.SetContext(context);
            if (!capitalizationInfoIsSet &&
                  (context == DisplayContext.CapitalizationForUIListOrMenu || context == DisplayContext.CapitalizationForStandalone))
            {
                InitCapitalizationContextInfo(locale);
                capitalizationInfoIsSet = true;
            }
            if (capitalizationBrkIter == null && (context == DisplayContext.CapitalizationForBeginningOfSentence ||
                  (context == DisplayContext.CapitalizationForUIListOrMenu && capitalizationForListOrMenu) ||
                  (context == DisplayContext.CapitalizationForStandalone && capitalizationForStandAlone)))
            {
                capitalizationBrkIter = BreakIterator.GetSentenceInstance(locale);
            }
        }

        /**
         * Returns the rounding mode.
         *
         * @return A rounding mode, between <code>BigDecimal.ROUND_UP</code> and
         * <code>BigDecimal.ROUND_UNNECESSARY</code>.
         * @see #setRoundingMode
         * @see java.math.BigDecimal
         * @stable ICU 56
         */

        public override Numerics.BigMath.RoundingMode RoundingMode
        {
            get => roundingMode;
            set
            {
                // ICU4N TODO: In Java, this is supposed to be the ICU BigDecimal RoundingMode (it was an int), but
                // the DecimalFormat class uses java.math.RoundingMode instead. Need to fix this so either both
                // can fit here or we have a way to make a conversion.
                if (value < Numerics.BigMath.RoundingMode.Up || value > Numerics.BigMath.RoundingMode.Unnecessary)
                {
                    throw new ArgumentException("Invalid rounding mode: " + value);
                }

                this.roundingMode = value;
            }
        }

        ///**
        // * Sets the rounding mode. This has no effect unless the rounding increment is greater
        // * than zero.
        // *
        // * @param roundingMode A rounding mode, between <code>BigDecimal.ROUND_UP</code> and
        // * <code>BigDecimal.ROUND_UNNECESSARY</code>.
        // * @exception IllegalArgumentException if <code>roundingMode</code> is unrecognized.
        // * @see #getRoundingMode
        // * @see java.math.BigDecimal
        // * @stable ICU 56
        // */
        //@Override
        //    public void setRoundingMode(int roundingMode)
        //{
        //    if (roundingMode < BigDecimal.ROUND_UP || roundingMode > BigDecimal.ROUND_UNNECESSARY)
        //    {
        //        throw new IllegalArgumentException("Invalid rounding mode: " + roundingMode);
        //    }

        //    this.roundingMode = roundingMode;
        //}


        //-----------------------------------------------------------------------
        // package-internal API
        //-----------------------------------------------------------------------

        /**
         * Returns a reference to the formatter's default rule set.  The default
         * rule set is the last public rule set in the description, or the one
         * most recently set by setDefaultRuleSet.
         * @return The formatter's default rule set.
         */
        internal NFRuleSet DefaultRuleSet => defaultRuleSet;

        /**
         * Returns the scanner to use for lenient parsing.  The scanner is
         * provided by the provider.
         * @return The collator to use for lenient parsing, or null if lenient parsing
         * is turned off.
         */
        internal IRbnfLenientScanner LenientScanner
        {
            get
            {
                if (lenientParse)
                {
                    IRbnfLenientScannerProvider provider = LenientScannerProvider;
                    if (provider != null)
                    {
                        return provider.Get(locale, lenientParseRules);
                    }
                }
                return null;
            }
        }

        /**
         * Returns the DecimalFormatSymbols object that should be used by all DecimalFormat
         * instances owned by this formatter.  This object is lazily created: this function
         * creates it the first time it's called.
         * @return The DecimalFormatSymbols object that should be used by all DecimalFormat
         * instances owned by this formatter.
         */
        internal DecimalFormatSymbols DecimalFormatSymbols
        {
            get
            {
                // lazy-evaluate the DecimalFormatSymbols object.  This object
                // is shared by all DecimalFormat instances belonging to this
                // formatter
                if (decimalFormatSymbols == null)
                {
                    decimalFormatSymbols = new DecimalFormatSymbols(locale);
                }
                return decimalFormatSymbols;
            }
        }

        internal DecimalFormat DecimalFormat
        {
            get
            {
                if (decimalFormat == null)
                {
                    // Don't use NumberFormat.getInstance, which can cause a recursive call
                    string pattern = GetPattern(locale, NumberFormatStyle.NumberStyle);
                    decimalFormat = new DecimalFormat(pattern, DecimalFormatSymbols);
                }
                return decimalFormat;
            }
        }

        internal PluralFormat CreatePluralFormat(PluralType pluralType, string pattern)
        {
            return new PluralFormat(locale, pluralType, pattern, DecimalFormat);
        }

        /**
         * Returns the default rule for infinity. This object is lazily created: this function
         * creates it the first time it's called.
         */
        internal NFRule DefaultInfinityRule
        {
            get
            {
                if (defaultInfinityRule == null)
                {
                    defaultInfinityRule = new NFRule(this, "Inf: " + DecimalFormatSymbols.Infinity);
                }
                return defaultInfinityRule;
            }
        }

        /**
         * Returns the default rule for NaN. This object is lazily created: this function
         * creates it the first time it's called.
         */
        internal NFRule DefaultNaNRule
        {
            get
            {
                if (defaultNaNRule == null)
                {
                    defaultNaNRule = new NFRule(this, "NaN: " + DecimalFormatSymbols.NaN);
                }
                return defaultNaNRule;
            }
        }

        //-----------------------------------------------------------------------
        // construction implementation
        //-----------------------------------------------------------------------

        /**
         * This extracts the special information from the rule sets before the
         * main parsing starts.  Extra whitespace must have already been removed
         * from the description.  If found, the special information is removed from the
         * description and returned, otherwise the description is unchanged and null
         * is returned.  Note: the trailing semicolon at the end of the special
         * rules is stripped.
         * @param description the rbnf description with extra whitespace removed
         * @param specialName the name of the special rule text to extract
         * @return the special rule text, or null if the rule was not found
         */
        private string ExtractSpecial(StringBuilder description, string specialName)
        {
            string result = null;
            int lp = description.IndexOf(specialName, StringComparison.Ordinal);
            if (lp != -1)
            {
                // we've got to make sure we're not in the middle of a rule
                // (where specialName would actually get treated as
                // rule text)
                if (lp == 0 || description[lp - 1] == ';')
                {
                    // locate the beginning and end of the actual special
                    // rules (there may be whitespace between the name and
                    // the first token in the description)
                    int lpEnd = description.IndexOf(";%", lp, StringComparison.Ordinal);

                    if (lpEnd == -1)
                    {
                        lpEnd = description.Length - 1; // later we add 1 back to get the '%'
                    }
                    int lpStart = lp + specialName.Length;
                    while (lpStart < lpEnd &&
                           PatternProps.IsWhiteSpace(description[lpStart]))
                    {
                        ++lpStart;
                    }

                    // copy out the special rules
                    result = description.ToString(lpStart, lpEnd - lpStart); // ICU4N: Corrected 2nd parameter

                    // remove the special rule from the description
                    description.Delete(lp, (lpEnd + 1) - lp); // delete the semicolon but not the '%' // ICU4N: Corrected 2nd parameter
                }
            }
            return result;
        }

        /**
         * This function parses the description and uses it to build all of
         * internal data structures that the formatter uses to do formatting
         * @param description The description of the formatter's desired behavior.
         * This is either passed in by the caller or loaded out of a resource
         * by one of the constructors, and is in the description format specified
         * in the class docs.
         */
        private void Init(string description, string[][] localizations)
        {
            InitLocalizations(localizations);

            // start by stripping the trailing whitespace from all the rules
            // (this is all the whitespace follwing each semicolon in the
            // description).  This allows us to look for rule-set boundaries
            // by searching for ";%" without having to worry about whitespace
            // between the ; and the %
            StringBuilder descBuf = StripWhitespace(description);

            // check to see if there's a set of lenient-parse rules.  If there
            // is, pull them out into our temporary holding place for them,
            // and delete them from the description before the real description-
            // parsing code sees them

            lenientParseRules = ExtractSpecial(descBuf, "%%lenient-parse:");
            postProcessRules = ExtractSpecial(descBuf, "%%post-process:");

            // pre-flight parsing the description and count the number of
            // rule sets (";%" marks the end of one rule set and the beginning
            // of the next)
            int numRuleSets = 1;
            int p = 0;
            while ((p = descBuf.IndexOf(";%", p, StringComparison.Ordinal)) != -1)
            {
                ++numRuleSets;
                p += 2; // Skip the length of ";%"
            }

            // our rule list is an array of the appropriate size
            ruleSets = new NFRuleSet[numRuleSets];
            ruleSetsMap = new Dictionary<string, NFRuleSet>(numRuleSets * 2 + 1);
            defaultRuleSet = null;

            // Used to count the number of public rule sets
            // Public rule sets have names that begin with % instead of %%.
            int publicRuleSetCount = 0;

            // divide up the descriptions into individual rule-set descriptions
            // and store them in a temporary array.  At each step, we also
            // new up a rule set, but all this does is initialize its name
            // and remove it from its description.  We can't actually parse
            // the rest of the descriptions and finish initializing everything
            // because we have to know the names and locations of all the rule
            // sets before we can actually set everything up
            string[] ruleSetDescriptions = new string[numRuleSets];

            int curRuleSet = 0;
            int start = 0;

            while (curRuleSet < ruleSets.Length)
            {
                p = descBuf.IndexOf(";%", start, StringComparison.Ordinal);
                if (p < 0)
                {
                    p = descBuf.Length - 1;
                }
                ruleSetDescriptions[curRuleSet] = descBuf.ToString(start, (p + 1) - start); // ICU4N: Corrected 2nd parameter
                NFRuleSet ruleSet = new NFRuleSet(this, ruleSetDescriptions, curRuleSet);
                ruleSets[curRuleSet] = ruleSet;
                string currentName = ruleSet.Name;
                ruleSetsMap[currentName] = ruleSet;
                if (!currentName.StartsWith("%%", StringComparison.Ordinal))
                {
                    ++publicRuleSetCount;
                    if (defaultRuleSet == null
                            && currentName.Equals("%spellout-numbering", StringComparison.Ordinal)
                            || currentName.Equals("%digits-ordinal", StringComparison.Ordinal)
                            || currentName.Equals("%duration", StringComparison.Ordinal))
                    {
                        defaultRuleSet = ruleSet;
                    }
                }
                ++curRuleSet;
                start = p + 1;
            }

            // now we can take note of the formatter's default rule set, which
            // is the last public rule set in the description (it's the last
            // rather than the first so that a user can create a new formatter
            // from an existing formatter and change its default behavior just
            // by appending more rule sets to the end)

            // {dlf} Initialization of a fraction rule set requires the default rule
            // set to be known.  For purposes of initialization, this is always the
            // last public rule set, no matter what the localization data says.

            // Set the default ruleset to the last public ruleset, unless one of the predefined
            // ruleset names %spellout-numbering, %digits-ordinal, or %duration is found

            if (defaultRuleSet == null)
            {
                for (int i = ruleSets.Length - 1; i >= 0; --i)
                {
                    if (!ruleSets[i].Name.StartsWith("%%", StringComparison.Ordinal))
                    {
                        defaultRuleSet = ruleSets[i];
                        break;
                    }
                }
            }
            if (defaultRuleSet == null)
            {
                defaultRuleSet = ruleSets[ruleSets.Length - 1];
            }

            // finally, we can go back through the temporary descriptions
            // list and finish setting up the substructure
            for (int i = 0; i < ruleSets.Length; i++)
            {
                ruleSets[i].ParseRules(ruleSetDescriptions[i]);
            }

            // Now that the rules are initialized, the 'real' default rule
            // set can be adjusted by the localization data.

            // prepare an array of the proper size and copy the names into it
            string[] publicRuleSetTemp = new string[publicRuleSetCount];
            publicRuleSetCount = 0;
            for (int i = ruleSets.Length - 1; i >= 0; i--)
            {
                if (!ruleSets[i].Name.StartsWith("%%", StringComparison.Ordinal))
                {
                    publicRuleSetTemp[publicRuleSetCount++] = ruleSets[i].Name;
                }
            }

            if (publicRuleSetNames != null)
            {
                // confirm the names, if any aren't in the rules, that's an error
                // it is ok if the rules contain public rule sets that are not in this list
                //loop:
                for (int i = 0; i < publicRuleSetNames.Length; ++i)
                {
                    string name = publicRuleSetNames[i];
                    for (int j = 0; j < publicRuleSetTemp.Length; ++j)
                    {
                        if (name.Equals(publicRuleSetTemp[j], StringComparison.Ordinal))
                        {
                            //continue loop;
                            goto loop_continue;
                        }
                    }
                    throw new ArgumentException("did not find public rule set: " + name);

                loop_continue: { /* intentionally blank */ }
                }

                defaultRuleSet = FindRuleSet(publicRuleSetNames[0]); // might be different
            }
            else
            {
                publicRuleSetNames = publicRuleSetTemp;
            }
        }

        /**
         * Take the localizations array and create a Map from the locale strings to
         * the localization arrays.
         */
        private void InitLocalizations(string[][] localizations)
        {
            if (localizations != null)
            {
                publicRuleSetNames = (string[])localizations[0].Clone();

                IDictionary<string, string[]> m = new Dictionary<string, string[]>();
                for (int i = 1; i < localizations.Length; ++i)
                {
                    string[] data = localizations[i];
                    string loc = data[0];
                    string[] names = new string[data.Length - 1];
                    if (names.Length != publicRuleSetNames.Length)
                    {
                        throw new ArgumentException("public name length: " + publicRuleSetNames.Length +
                                                           " != localized names[" + i + "] length: " + names.Length);
                    }
                    Array.Copy(data, 1, names, 0, names.Length);
                    m[loc] = names;
                }

                if (m.Count != 0)
                {
                    ruleSetDisplayNames = m;
                }
            }
        }

        /**
         * Set capitalizationForListOrMenu, capitalizationForStandAlone
         */
        private void InitCapitalizationContextInfo(UCultureInfo theLocale)
        {
            ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.GetBundleInstance(ICUData.IcuBaseName, theLocale);
            try
            {
                ICUResourceBundle rdb = rb.GetWithFallback("contextTransforms/number-spellout");
                int[] intVector = rdb.GetInt32Vector();
                if (intVector.Length >= 2)
                {
                    capitalizationForListOrMenu = (intVector[0] != 0);
                    capitalizationForStandAlone = (intVector[1] != 0);
                }
            }
            catch (MissingManifestResourceException e)
            {
                // use default
            }
        }

        /**
         * This function is used by init() to strip whitespace between rules (i.e.,
         * after semicolons).
         * @param description The formatter description
         * @return The description with all the whitespace that follows semicolons
         * taken out.
         */
        private StringBuilder StripWhitespace(string description)
        {
            // since we don't have a method that deletes characters (why?!!)
            // create a new StringBuffer to copy the text into
            StringBuilder result = new StringBuilder();
            int descriptionLength = description.Length;

            // iterate through the characters...
            int start = 0;
            while (start < descriptionLength)
            {
                // seek to the first non-whitespace character...
                while (start < descriptionLength
                       && PatternProps.IsWhiteSpace(description[start]))
                {
                    ++start;
                }

                //if the first non-whitespace character is semicolon, skip it and continue
                if (start < descriptionLength && description[start] == ';')
                {
                    start += 1;
                    continue;
                }

                // locate the next semicolon in the text and copy the text from
                // our current position up to that semicolon into the result
                int p = description.IndexOf(';', start);
                if (p == -1)
                {
                    // or if we don't find a semicolon, just copy the rest of
                    // the string into the result
                    result.Append(description.Substring(start));
                    break;
                }
                else if (p < descriptionLength)
                {
                    result.Append(description.Substring(start, (p + 1) - start)); // ICU4N: Corrected 2nd parameter
                    start = p + 1;
                }
                else
                {
                    // when we get here, we've seeked off the end of the string, and
                    // we terminate the loop (we continue until *start* is -1 rather
                    // than until *p* is -1, because otherwise we'd miss the last
                    // rule in the description)
                    break;
                }
            }
            return result;
        }

        //-----------------------------------------------------------------------
        // formatting implementation
        //-----------------------------------------------------------------------

        /**
         * Bottleneck through which all the public format() methods
         * that take a double pass. By the time we get here, we know
         * which rule set we're using to do the formatting.
         * @param number The number to format
         * @param ruleSet The rule set to use to format the number
         * @return The text that resulted from formatting the number
         */
        private string Format(double number, NFRuleSet ruleSet)
        {
            // all API format() routines that take a double vector through
            // here.  Create an empty string buffer where the result will
            // be built, and pass it to the rule set (along with an insertion
            // position of 0 and the number being formatted) to the rule set
            // for formatting
            StringBuilder result = new StringBuilder();

            if (RoundingMode != Numerics.BigMath.RoundingMode.Unnecessary && !double.IsNaN(number) && !double.IsInfinity(number))
            {
                // We convert to a string because BigDecimal insists on excessive precision.
                number = Numerics.BigDecimal.Parse(Double.ToString(number, CultureInfo.InvariantCulture), CultureInfo.InvariantCulture).SetScale(MaximumFractionDigits, roundingMode.ToICURoundingMode()).ToDouble();
            //RoundingModeExtensions
            }
            ruleSet.Format(number, result, 0, 0);
            PostProcess(result, ruleSet);
            return result.ToString();
        }

        /**
         * Bottleneck through which all the public format() methods
         * that take a long pass. By the time we get here, we know
         * which rule set we're using to do the formatting.
         * @param number The number to format
         * @param ruleSet The rule set to use to format the number
         * @return The text that resulted from formatting the number
         */
        private string Format(long number, NFRuleSet ruleSet)
        {
            // all API format() routines that take a double vector through
            // here.  We have these two identical functions-- one taking a
            // double and one taking a long-- the couple digits of precision
            // that long has but double doesn't (both types are 8 bytes long,
            // but double has to borrow some of the mantissa bits to hold
            // the exponent).
            // Create an empty string buffer where the result will
            // be built, and pass it to the rule set (along with an insertion
            // position of 0 and the number being formatted) to the rule set
            // for formatting
            StringBuilder result = new StringBuilder();
            if (number == long.MinValue)
            {
                // We can't handle this value right now. Provide an accurate default value.
                result.Append(DecimalFormat.Format(long.MinValue));
            }
            else
            {
                ruleSet.Format(number, result, 0, 0);
            }
            PostProcess(result, ruleSet);
            return result.ToString();
        }

        /**
         * Post-process the rules if we have a post-processor.
         */
        private void PostProcess(StringBuilder result, NFRuleSet ruleSet)
        {
            if (postProcessRules != null)
            {
                if (postProcessor == null)
                {
                    int ix = postProcessRules.IndexOf(";", StringComparison.Ordinal);
                    if (ix == -1)
                    {
                        ix = postProcessRules.Length;
                    }
                    string ppClassName = postProcessRules.Substring(0, ix).Trim(); // ICU4N: Checked 2nd parameter

                    // ICU4N: Hack to replace the namespace for the RBNFChinesePostProcessor if it is specified this way.
                    if (ppClassName.Equals("com.ibm.icu.text.RBNFChinesePostProcessor", StringComparison.Ordinal))
                        ppClassName = "ICU4N.Text.RbnfChinesePostProcessor";
                    try
                    {
                        //Class <?> cls = Class.forName(ppClassName);
                        //postProcessor = (RBNFPostProcessor)cls.newInstance();

                        Type cls = Type.GetType(ppClassName); // ICU4N TODO: Create abstract factory to create instance of the class, which is set at app startup
                        postProcessor = (IRbnfPostProcessor)Activator.CreateInstance(cls);
                        postProcessor.Init(this, postProcessRules);
                    }
                    catch (Exception e)
                    {
                        // if debug, print it out
                        if (DEBUG) Console.Out.WriteLine("could not locate " + ppClassName + ", error " +
                                           e.GetType().Name + ", " + e.Message);
                        postProcessor = null;
                        postProcessRules = null; // don't try again
                        return;
                    }
                }

                postProcessor.Process(result, ruleSet);
            }
        }

        /**
         * Adjust capitalization of formatted result for display context
         */
        private string AdjustForContext(string result)
        {
            DisplayContext capitalization = GetContext(DisplayContextType.Capitalization);
            if (capitalization != DisplayContext.CapitalizationNone && result != null && result.Length > 0
                && UChar.IsLower(result.CodePointAt(0)))
            {
                if (capitalization == DisplayContext.CapitalizationForBeginningOfSentence ||
                      (capitalization == DisplayContext.CapitalizationForUIListOrMenu && capitalizationForListOrMenu) ||
                      (capitalization == DisplayContext.CapitalizationForStandalone && capitalizationForStandAlone))
                {
                    if (capitalizationBrkIter == null)
                    {
                        // should only happen when deserializing, etc.
                        capitalizationBrkIter = BreakIterator.GetSentenceInstance(locale);
                    }
                    return UChar.ToTitleCase(locale, result, capitalizationBrkIter,
                                    UChar.TitleCaseNoLowerCase | UChar.TitleCaseNoBreakAdjustment);
                }
            }
            return result;
        }

        /**
         * Returns the named rule set.  Throws an IllegalArgumentException
         * if this formatter doesn't have a rule set with that name.
         * @param name The name of the desired rule set
         * @return The rule set with that name
         */
        internal NFRuleSet FindRuleSet(string name)
        {
            if (!ruleSetsMap.TryGetValue(name, out NFRuleSet result) || result == null)
            {
                throw new ArgumentException("No rule set named " + name);
            }
            return result;
        }
    }
}
