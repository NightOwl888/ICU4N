<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Where(x => x.Value != "ValueStringBuilder").Select(x => x.Value).ToArray();

    int paramCount = 16;
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class SimpleFormatter
    {
        #region Format

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values.
        /// </summary>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">The <#=GetOrdinalString(j + 1)#> argument value.</param>
<# } #>
        /// <stable>ICU 57</stable>
        public string Format(<#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            return SimpleFormatterImpl.FormatCompiledPattern(compiledPattern.AsSpan(), <#=GenerateValuesParams(i + 1)#>);
        }

<# } #>
        #endregion Format

        #region TryFormat

<# for (int i = 0; i < paramCount; i++) { #>
        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <param name="destination">When this method returns successfully, contains the formatted text.</param>
        /// <param name="charsLength">When this method returns <c>true</c>, contains the number of characters that are
        /// usable in <paramref name="destination"/>; otherwise, this is the length of <paramref name="destination"/> 
        /// that will need to be allocated to succeed in another attempt.</param>
<# for (int j = 0; j <= i; j++) { #>
        /// <param name="value<#=j#>">
        /// The <#=GetOrdinalString(j + 1)#> argument value.
        /// An argument value must not be the same memory location as <paramref name="destination"/>.
        /// </param>
<# } #>
        /// <returns><c>true</c> if the operation was successful; otherwise, <c>false</c>.</returns>
        /// <draft>ICU 60.1</draft>
        public bool TryFormat(Span<char> destination, out int charsLength, <#=GenerateValuesParams(i + 1, "ReadOnlySpan<char>")#>)
        {
            return SimpleFormatterImpl.TryFormatCompiledPattern(compiledPattern.AsSpan(), destination, out charsLength, <#=GenerateValuesParams(i + 1)#>);
        }

<# } #>

        #endregion TryFormat
    }
}
<#+
    public string GenerateValuesParams(int count, string typeName = null) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                result.Append(", ");
            }
            if (!string.IsNullOrEmpty(typeName)) {
                result.Append(typeName);
                result.Append(' ');
            }
            result.Append("value");
            result.Append(i);
        }
        return result.ToString();
    }
    public string GetOrdinalString(int count)
    {
        switch (count)
        {
            case 1:
                return "first";
            case 2:
                return "second";
            case 3:
                return "third";
            case 4:
                return "fourth";
            case 5:
                return "fifth";
            case 6:
                return "sixth";
            case 7:
                return "seventh";
            case 8:
                return "eighth";
            case 9:
                return "ninth";
            case 10:
                return "tenth";
            case 11:
                return "eleventh";
            case 12:
                return "twelveth";
            case 13:
                return "thirteenth";
            case 14:
                return "fourteenth";
            case 15:
                return "fifteenth";
            case 16:
                return "sixteenth";
            default:
                return string.Empty;
        }
    }
#>