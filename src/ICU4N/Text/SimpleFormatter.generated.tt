<#@ output extension=".cs" #>
<#@ include file="../../../codegen/FilterDeclarations.tt" #>
<#
CharSequenceFilter = (c) => c.Name != "ReadOnlySpan<char>";
AppendableFilter = (a) => a.Name != "ValueStringBuilder";
string codeGenerationRelativePath = @"../../../codegen";
#><#@ include file="../../../codegen/DataLoader.tt" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class SimpleFormatter
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Creates a formatter from the pattern string.
        /// </summary>
        /// <param name="pattern">The pattern string.</param>
        /// <returns>The new <see cref="SimpleFormatter"/> object.</returns>
        /// <exception cref="ArgumentException">For bad argument syntax.</exception>
        /// <stable>ICU 57</stable>
        <#=charSequence.Accessibility#> static SimpleFormatter Compile(<#=charSequence#> pattern)
        {
            return CompileMinMaxArguments(pattern, 0, int.MaxValue);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Creates a formatter from the pattern string.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">The pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <returns>The new <see cref="SimpleFormatter"/> object.</returns>
        /// <exception cref="ArgumentException">For bad argument syntax and too few or too many arguments.</exception>
        /// <stable>ICU 57</stable>
        <#=charSequence.Accessibility#> static SimpleFormatter CompileMinMaxArguments(<#=charSequence#> pattern, int min, int max)
        {
            StringBuilder sb = new StringBuilder();
            string compiledPattern = SimpleFormatterImpl.CompileToStringMinMaxArguments(pattern, sb, min, max);
            return new SimpleFormatter(compiledPattern);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <stable>ICU 57</stable>
<# if (charSequence.Name == "char[]") { #>
        [CLSCompliant(false)]
<# } #>
        <#=charSequence.Accessibility#> string Format(params <#=charSequence#>[] values)
        {
            return SimpleFormatterImpl.FormatCompiledPattern(compiledPattern, values);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// offsets[i] receives the offset of where
        /// values[i] replaced pattern argument {i}.
        /// Can be null, or can be shorter or longer than values.
        /// If there is no {i} in the pattern, then offsets[i] is set to -1.
        /// </param>
        /// <param name="values">
        /// The argument values.
        /// An argument value must not be the same object as appendTo.
        /// values.Length must be at least <see cref="ArgumentLimit"/>.
        /// Can be null if <see cref="ArgumentLimit"/>==0.
        /// </param>
        /// <returns><paramref name="appendTo"/></returns>
        /// <stable>ICU 57</stable>
<# if (charSequence.Name == "char[]") { #>
        [CLSCompliant(false)]
<# } #>
        <#=charSequence.Accessibility#> StringBuilder FormatAndAppend(
            StringBuilder appendTo, int[] offsets, params <#=charSequence#>[] values)
        {
            return SimpleFormatterImpl.FormatAndAppend(compiledPattern, appendTo, offsets, values);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// offsets[i] receives the offset of where
        /// values[i] replaced pattern argument {i}.
        /// Can be null, or can be shorter or longer than values.
        /// If there is no {i} in the pattern, then offsets[i] is set to -1.
        /// </param>
        /// <param name="values">
        /// The argument values.
        /// An argument value may be the same object as result.
        /// values.Length must be at least <see cref="ArgumentLimit"/>.
        /// </param>
        /// <returns><paramref name="result"/></returns>
        /// <stable>ICU 57</stable>
<# if (charSequence.Name == "char[]") { #>
        [CLSCompliant(false)]
<# } #>
        <#=charSequence.Accessibility#> StringBuilder FormatAndReplace(
            StringBuilder result, int[] offsets, params <#=charSequence#>[] values)
        {
            return SimpleFormatterImpl.FormatAndReplace(compiledPattern, result, offsets, values);
        }
<#= GetEndFeature(charSequence) #>
<# } #>

    }
}
<#@ include file="../../../codegen/SharedObjects.tt" #>