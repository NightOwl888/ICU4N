<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Where(x => x.Value != "ReadOnlySpan<char>").Select(x => x.Value).ToArray(); // ICU4N TODO: API - ReadOnlySpan<char>
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class SimpleFormatter
    {
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Creates a formatter from the pattern string.
        /// </summary>
        /// <param name="pattern">The pattern string.</param>
        /// <returns>The new <see cref="SimpleFormatter"/> object.</returns>
        /// <exception cref="ArgumentException">For bad argument syntax.</exception>
        /// <stable>ICU 57</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static SimpleFormatter Compile(<#=charSequence#> pattern)
        {
            return CompileMinMaxArguments(pattern, 0, int.MaxValue);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Creates a formatter from the pattern string.
        /// The number of arguments checked against the given limits is the
        /// highest argument number plus one, not the number of occurrences of arguments.
        /// </summary>
        /// <param name="pattern">The pattern string.</param>
        /// <param name="min">The pattern must have at least this many arguments.</param>
        /// <param name="max">The pattern must have at most this many arguments.</param>
        /// <returns>The new <see cref="SimpleFormatter"/> object.</returns>
        /// <exception cref="ArgumentException">For bad argument syntax and too few or too many arguments.</exception>
        /// <stable>ICU 57</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static SimpleFormatter CompileMinMaxArguments(<#=charSequence#> pattern, int min, int max)
        {
            StringBuilder sb = new StringBuilder();
            string compiledPattern = SimpleFormatterImpl.CompileToStringMinMaxArguments(pattern, sb, min, max);
            return new SimpleFormatter(compiledPattern);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Formats the given values.
        /// </summary>
        /// <stable>ICU 57</stable>
<# if (charSequence == "char[]") { #>
		[CLSCompliant(false)]
<# } #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Format(params <#=charSequence#>[] values)
        {
            return SimpleFormatterImpl.FormatCompiledPattern(compiledPattern, values);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Formats the given values, appending to the <paramref name="appendTo"/> builder.
        /// </summary>
        /// <param name="appendTo">Gets the formatted pattern and values appended.</param>
        /// <param name="offsets">
        /// offsets[i] receives the offset of where
        /// values[i] replaced pattern argument {i}.
        /// Can be null, or can be shorter or longer than values.
        /// If there is no {i} in the pattern, then offsets[i] is set to -1.
        /// </param>
        /// <param name="values">
        /// The argument values.
        /// An argument value must not be the same object as appendTo.
        /// values.Length must be at least <see cref="ArgumentLimit"/>.
        /// Can be null if <see cref="ArgumentLimit"/>==0.
        /// </param>
        /// <returns><paramref name="appendTo"/></returns>
        /// <stable>ICU 57</stable>
<# if (charSequence == "char[]") { #>
		[CLSCompliant(false)]
<# } #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> StringBuilder FormatAndAppend(
            StringBuilder appendTo, int[] offsets, params <#=charSequence#>[] values)
        {
            return SimpleFormatterImpl.FormatAndAppend(compiledPattern, appendTo, offsets, values);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Formats the given values, replacing the contents of the result builder.
        /// May optimize by actually appending to the result if it is the same object
        /// as the value corresponding to the initial argument in the pattern.
        /// </summary>
        /// <param name="result">Gets its contents replaced by the formatted pattern and values.</param>
        /// <param name="offsets">
        /// offsets[i] receives the offset of where
        /// values[i] replaced pattern argument {i}.
        /// Can be null, or can be shorter or longer than values.
        /// If there is no {i} in the pattern, then offsets[i] is set to -1.
        /// </param>
        /// <param name="values">
        /// The argument values.
        /// An argument value may be the same object as result.
        /// values.Length must be at least <see cref="ArgumentLimit"/>.
        /// </param>
        /// <returns><paramref name="result"/></returns>
        /// <stable>ICU 57</stable>
<# if (charSequence == "char[]") { #>
		[CLSCompliant(false)]
<# } #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> StringBuilder FormatAndReplace(
            StringBuilder result, int[] offsets, params <#=charSequence#>[] values)
        {
            return SimpleFormatterImpl.FormatAndReplace(compiledPattern, result, offsets, values);
        }
<# } #>

	}
}