<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Where(x => x.Value != "ReadOnlySpan<char>").Select(x => x.Value).ToArray(); // ICU4N TODO: API - ReadOnlySpan<char>
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Support.Text;
using J2N.Text;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class Normalizer
    {
        private sealed partial class CharsAppendable : IAppendable
        {
<# foreach (var charSequence in charSequences) { #>

            public IAppendable Append(<#=charSequence#> s)
            {
                return Append(s, 0, s.Length);
            }

            public IAppendable Append(<#=charSequence#> s, int sStart, int sLength)
            {
                int sLimit = sStart + sLength;
                if (sLength <= (limit - offset))
                {
                    while (sStart < sLimit)
                    {  // TODO: Is there a better way to copy the characters?
                        chars[offset++] = s[sStart++];
                    }
                }
                else
                {
                    offset += sLength;
                }
                return this;
            }
<# } #>

        }
    }
}