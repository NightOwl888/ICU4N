//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Support.Text;
using J2N.Text;
using System;
using System.Text;
using static ICU4N.Text.UnicodeSet;

namespace ICU4N.Text
{
    public partial class UnicodeSetSpanner
    {

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(string sequence)
        {
            return CountIn(sequence, CountMethod.MinElements, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(StringBuilder sequence)
        {
            return CountIn(sequence, CountMethod.MinElements, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(char[] sequence)
        {
            return CountIn(sequence, CountMethod.MinElements, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        internal virtual int CountIn(ICharSequence sequence)
        {
            return CountIn(sequence, CountMethod.MinElements, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(string sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(StringBuilder sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(char[] sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        internal virtual int CountIn(ICharSequence sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.Simple"/> or <see cref="SpanCondition.Contained"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NotContained"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(string sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WholeSpan)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
#pragma warning disable 612, 618
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
#pragma warning restore 612, 618
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.Simple"/> or <see cref="SpanCondition.Contained"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NotContained"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(StringBuilder sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WholeSpan)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
#pragma warning disable 612, 618
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
#pragma warning restore 612, 618
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.Simple"/> or <see cref="SpanCondition.Contained"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NotContained"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        public virtual int CountIn(char[] sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WholeSpan)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
#pragma warning disable 612, 618
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
#pragma warning restore 612, 618
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.Simple"/> or <see cref="SpanCondition.Contained"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NotContained"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        internal virtual int CountIn(ICharSequence sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WholeSpan)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
#pragma warning disable 612, 618
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
#pragma warning restore 612, 618
                    count += spanCount;
                }
            }
            return count;
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(string sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, SpanCondition.Simple);
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(StringBuilder sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, SpanCondition.Simple);
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(char[] sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, SpanCondition.Simple);
        }

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string DeleteFrom(ICharSequence sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, SpanCondition.Simple);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.Contained"/> or <see cref="SpanCondition.Simple"/>) 
        /// or the non-matching (<see cref="SpanCondition.NotContained"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(string sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, spanCondition);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.Contained"/> or <see cref="SpanCondition.Simple"/>) 
        /// or the non-matching (<see cref="SpanCondition.NotContained"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(StringBuilder sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, spanCondition);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.Contained"/> or <see cref="SpanCondition.Simple"/>) 
        /// or the non-matching (<see cref="SpanCondition.NotContained"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string DeleteFrom(char[] sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, spanCondition);
        }

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.Contained"/> or <see cref="SpanCondition.Simple"/>) 
        /// or the non-matching (<see cref="SpanCondition.NotContained"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string DeleteFrom(ICharSequence sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, spanCondition);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(string sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(StringBuilder sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(char[] sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, string replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, StringBuilder replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, char[] replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, ICharSequence replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(string sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(StringBuilder sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(char[] sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, string replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, StringBuilder replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, char[] replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, ICharSequence replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(string sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(string sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(StringBuilder sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(StringBuilder sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        public virtual string ReplaceFrom(char[] sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(char[] sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
        
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, string replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, StringBuilder replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, char[] replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        internal virtual string ReplaceFrom(ICharSequence sequence, ICharSequence replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.Subsequence(endModify, endCopy - endModify)); // ICU4N: Corrected 2nd parameter
            }
            return result.ToString();
        }
    
        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.Both"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(string sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.Both, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.Both"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(StringBuilder sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.Both, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.Both"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(char[] sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.Both, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.Both"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(ICharSequence sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.Both, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(string sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(StringBuilder sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(char[] sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(ICharSequence sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.Simple);
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.Simple"/>, <see cref="SpanCondition.Contained"/> or 
        /// <see cref="SpanCondition.NotContained"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(string sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.Trailing)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".AsCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.Leading)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ?
                sequence.AsCharSequence() :
                sequence.Subsequence(endLeadContained, startTrailContained - endLeadContained); // ICU4N: Corrected 2nd parameter
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.Simple"/>, <see cref="SpanCondition.Contained"/> or 
        /// <see cref="SpanCondition.NotContained"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(StringBuilder sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.Trailing)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".AsCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.Leading)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ?
                sequence.AsCharSequence() :
                sequence.Subsequence(endLeadContained, startTrailContained - endLeadContained); // ICU4N: Corrected 2nd parameter
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.Simple"/>, <see cref="SpanCondition.Contained"/> or 
        /// <see cref="SpanCondition.NotContained"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(char[] sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.Trailing)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".AsCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.Leading)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ?
                sequence.AsCharSequence() :
                sequence.Subsequence(endLeadContained, startTrailContained - endLeadContained); // ICU4N: Corrected 2nd parameter
        }

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.Subsequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.Simple"/>, <see cref="SpanCondition.Contained"/> or 
        /// <see cref="SpanCondition.NotContained"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        internal virtual ICharSequence Trim(ICharSequence sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.Trailing)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".AsCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.Leading)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ?
                sequence :
                sequence.Subsequence(endLeadContained, startTrailContained - endLeadContained); // ICU4N: Corrected 2nd parameter
        }

    }
}