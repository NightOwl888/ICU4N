using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Text
{
    /// <summary>
    /// A post-processor for Chinese text.
    /// </summary>
    internal class RbnfChinesePostProcessor : IRbnfPostProcessor
    {
        //private NFRuleSet lastRuleSet;
        private bool longForm;
        private int format;

        private static readonly string[] rulesetNames = {
            "%traditional", "%simplified", "%accounting", "%time"
        };

        /// <summary>
        /// Initialization routine for this instance, called once
        /// immediately after first construction and never again.
        /// </summary>
        public void Init(RuleBasedNumberFormat formatter, string rules)
        {
        }

        /// <summary>
        /// Work routine.  Post process the output, which was generated by the
        /// ruleset with the given name.
        /// </summary>
        /// <exception cref="InvalidOperationException"></exception>
        public void Process(StringBuilder buf, NFRuleSet ruleSet)
        {
            // markers depend on what rule set we are using

            // Commented by johnvu on the if statement since lastRuleSet is never initialized
            //if (ruleSet != lastRuleSet) {
            string name = ruleSet.Name;
            for (int i = 0; i < rulesetNames.Length; ++i)
            {
                if (rulesetNames[i].Equals(name, StringComparison.Ordinal))
                {
                    format = i;
                    longForm = i == 1 || i == 3;
                    break;
                }
            }
            //}

            if (longForm)
            {
                for (int i = buf.IndexOf("*", StringComparison.Ordinal); i != -1; i = buf.IndexOf("*", i, StringComparison.Ordinal))
                {
                    buf.Delete(i, 1); // ICU4N: Checked 2nd parameter
                }
                return;
            }

            string DIAN = "\u9ede"; // decimal point

            string[][] markers = {
                new string[] { "\u842c", "\u5104", "\u5146", "\u3007" }, // marker chars, last char is the 'zero'
                new string[] { "\u4e07", "\u4ebf", "\u5146", "\u3007" },
                new string[] { "\u842c", "\u5104", "\u5146", "\u96f6" }
                // need markers for time?
            };

            // remove unwanted lings
            // a '0' (ling) with * might be removed
            // mark off 10,000 'chunks', markers are Z, Y, W (zhao, yii, and wan)
            // already, we avoid two lings in the same chunk -- ling without * wins
            // now, just need  to avoid optional lings in adjacent chunks
            // process right to left

            // decision matrix:
            // state, situation
            //     state         none       opt.          req.
            //     -----         ----       ----          ----
            // none to right     none       opt.          req.  
            // opt. to right     none   clear, none  clear right, req.
            // req. to right     none   clear, none       req.

            // mark chunks with '|' for convenience
            {
                string[] m = markers[format];
                for (int i = 0; i < m.Length - 1; ++i)
                {
                    int n2 = buf.IndexOf(m[i], StringComparison.Ordinal);
                    if (n2 != -1)
                    {
                        buf.Insert(n2 + m[i].Length, '|');
                    }
                }
            }

            int x = buf.IndexOf(DIAN, StringComparison.Ordinal);
            if (x == -1)
            {
                x = buf.Length;
            }
            int s = 0; // 0 = none to right, 1 = opt. to right, 2 = req. to right
            int n = -1; // previous optional ling
            string ling = markers[format][3];
            while (x >= 0)
            {
                int m = buf.LastIndexOf("|", x, StringComparison.Ordinal);
                int nn = buf.LastIndexOf(ling, x, StringComparison.Ordinal);
                int ns = 0;
                if (nn > m)
                {
                    ns = (nn > 0 && buf[nn - 1] != '*') ? 2 : 1;
                }
                x = m - 1;

                // actually much simpler, but leave this verbose for now so it's easier to follow
                switch (s * 3 + ns)
                {
                    case 0: /* none, none */
                        s = ns; // redundant
                        n = -1;
                        break;
                    case 1: /* none, opt. */
                        s = ns;
                        n = nn; // remember optional ling to right
                        break;
                    case 2: /* none, req. */
                        s = ns;
                        n = -1;
                        break;
                    case 3: /* opt., none */
                        s = ns;
                        n = -1;
                        break;
                    case 4: /* opt., opt. */
                        buf.Delete(nn - 1, (nn + ling.Length) - (nn - 1)); // delete current optional ling // ICU4N: Corrected 2nd parameter
                        s = 0;
                        n = -1;
                        break;
                    case 5: /* opt., req. */
                        buf.Delete(n - 1, (n + ling.Length) - (n - 1)); // delete previous optional ling // ICU4N: Corrected 2nd parameter
                        s = ns;
                        n = -1;
                        break;
                    case 6: /* req., none */
                        s = ns;
                        n = -1;
                        break;
                    case 7: /* req., opt. */
                        buf.Delete(nn - 1, (nn + ling.Length) - (nn - 1)); // delete current optional ling
                        s = 0;
                        n = -1;
                        break;
                    case 8: /* req., req. */
                        s = ns;
                        n = -1;
                        break;
                    default:
                        throw new InvalidOperationException(); // ICU4N TODO: Remove for TryFormat/TryParse
                }
            }

            for (int i = buf.Length; --i >= 0;)
            {
                char c = buf[i];
                if (c == '*' || c == '|')
                {
                    buf.Delete(i, 1); // ICU4N: Corrected 2nd parameter
                }
            }
        }
    }
}
