<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
    string appendableAccessibility = document.XPathSelectElement(@"//codeGen/appendableAccessibility").Value;
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using J2N.Text;
using System.Globalization;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class LowerCaseMap : CaseMap
    {
<# foreach (var charSequence in charSequences) { #>

        // ICU4N specific overload for convenience
        /// <summary>
        /// Lowercases a string.
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.ToLower(CultureInfo, string)"/>
        /// <draft>ICU4N 60.1.0</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(<#=charSequence#> src)
        {
            return CaseMapImpl.ToLower(GetCaseLocale(null), internalOptions, src);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Lowercases a string.
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="locale">The locale ID. Can be null for <see cref="CultureInfo.CurrentCulture"/>.</param>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.ToLower(CultureInfo, string)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(CultureInfo locale, <#=charSequence#> src)
        {
            return CaseMapImpl.ToLower(GetCaseLocale(locale), internalOptions, src);
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        // ICU4N specific overload for convenience
        /// <summary>
        /// Lowercases a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="edits"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.ToLower(CultureInfo, string)"/>
        /// <draft>ICU4N 60.1.0</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            return CaseMapImpl.ToLower(GetCaseLocale(null), internalOptions, src, dest, edits);
        }
    <# } #>
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Lowercases a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="locale">The locale ID. Can be null for <see cref="CultureInfo.CurrentCulture"/>.</param>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="edits"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.ToLower(CultureInfo, string)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            CultureInfo locale, <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            CultureInfo locale, <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            return CaseMapImpl.ToLower(GetCaseLocale(locale), internalOptions, src, dest, edits);
        }
    <# } #>
<# } #>
    }

    public sealed partial class UpperCaseMap : CaseMap
    {
<# foreach (var charSequence in charSequences) { #>

        // ICU4N specific overload for convenience
        /// <summary>
        /// Uppercases a string.
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.ToUpper(CultureInfo, string)"/>
        /// <draft>ICU4N 60.1.0</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(<#=charSequence#> src)
        {
            return CaseMapImpl.ToUpper(GetCaseLocale(null), internalOptions, src);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Uppercases a string.
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="locale">The locale ID. Can be null for <see cref="CultureInfo.CurrentCulture"/>.</param>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.ToUpper(CultureInfo, string)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(CultureInfo locale, <#=charSequence#> src)
        {
            return CaseMapImpl.ToUpper(GetCaseLocale(locale), internalOptions, src);
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        // ICU4N specific overload for convenience
        /// <summary>
        /// Uppercases a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="dest"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.ToUpper(CultureInfo, string)"/>
        /// <draft>ICU4N 60.1.0</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            return CaseMapImpl.ToUpper(GetCaseLocale(null), internalOptions, src, dest, edits);
        }
    <# } #>
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Uppercases a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <param name="locale">The locale ID. Can be null for <see cref="CultureInfo.CurrentCulture"/>.</param>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="dest"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.ToUpper(CultureInfo, string)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            CultureInfo locale, <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            CultureInfo locale, <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            return CaseMapImpl.ToUpper(GetCaseLocale(locale), internalOptions, src, dest, edits);
        }
    <# } #>
<# } #>
    }

    public sealed partial class TitleCaseMap : CaseMap
    {
<# foreach (var charSequence in charSequences) { #>

        // ICU4N specific overload for convenience
        /// <summary>
        /// Titlecases a string.
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <remarks>
        /// Titlecasing uses a break iterator to find the first characters of words
        /// that are to be titlecased. It titlecases those characters and lowercases
        /// all others. (This can be modified with options bits.)
        /// </remarks>
        /// <param name="iter">
        /// A break iterator to find the first characters of words that are to be titlecased.
        /// It is set to the source string (SetText())
        /// and used one or more times for iteration (First() and Next()).
        /// If null, then a word break iterator for the locale is used
        /// (or something equivalent).
        /// </param>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.ToTitleCase(CultureInfo, string, BreakIterator, int)"/>
        /// <draft>ICU4N 60.1.0</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(BreakIterator iter, <#=charSequence#> src)
        {
            CultureInfo locale = CultureInfo.CurrentCulture;
            iter = CaseMapImpl.GetTitleBreakIterator(locale, internalOptions, iter);
            iter.SetText(src);
            return CaseMapImpl.ToTitle(GetCaseLocale(locale), internalOptions, iter, src);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Titlecases a string.
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <remarks>
        /// Titlecasing uses a break iterator to find the first characters of words
        /// that are to be titlecased. It titlecases those characters and lowercases
        /// all others. (This can be modified with options bits.)
        /// </remarks>
        /// <param name="locale">The locale ID. Can be null for <see cref="CultureInfo.CurrentCulture"/>.</param>
        /// <param name="iter">
        /// A break iterator to find the first characters of words that are to be titlecased.
        /// It is set to the source string (SetText())
        /// and used one or more times for iteration (First() and Next()).
        /// If null, then a word break iterator for the locale is used
        /// (or something equivalent).
        /// </param>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.ToTitleCase(CultureInfo, string, BreakIterator, int)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(CultureInfo locale, BreakIterator iter, <#=charSequence#> src)
        {
            if (iter == null && locale == null)
            {
                locale = CultureInfo.CurrentCulture;
            }
            iter = CaseMapImpl.GetTitleBreakIterator(locale, internalOptions, iter);
            iter.SetText(src);
            return CaseMapImpl.ToTitle(GetCaseLocale(locale), internalOptions, iter, src);
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        // ICU4N specific overload for convenience
        /// <summary>
        /// Titlecases a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <remarks>
        /// Titlecasing uses a break iterator to find the first characters of words
        /// that are to be titlecased. It titlecases those characters and lowercases
        /// all others. (This can be modified with options bits.)
        /// </remarks>
        /// <param name="iter">
        /// A break iterator to find the first characters of words that are to be titlecased.
        /// It is set to the source string (SetText())
        /// and used one or more times for iteration (First() and Next()).
        /// If null, then a word break iterator for the locale is used
        /// (or something equivalent).
        /// </param>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">
        /// Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="edits"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.ToTitleCase(CultureInfo, string, BreakIterator, int)"/>
        /// <draft>ICU4N 60.1.0</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            BreakIterator iter, <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            BreakIterator iter, <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            CultureInfo locale = CultureInfo.CurrentCulture;
            iter = CaseMapImpl.GetTitleBreakIterator(locale, internalOptions, iter);
            iter.SetText(src);
            return CaseMapImpl.ToTitle(
                    GetCaseLocale(locale), internalOptions, iter, src, dest, edits);
        }

    <# } #>
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Titlecases a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// Casing is locale-dependent and context-sensitive.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <remarks>
        /// Titlecasing uses a break iterator to find the first characters of words
        /// that are to be titlecased. It titlecases those characters and lowercases
        /// all others. (This can be modified with options bits.)
        /// </remarks>
        /// <param name="locale">The locale ID. Can be null for <see cref="CultureInfo.CurrentCulture"/>.</param>
        /// <param name="iter">
        /// A break iterator to find the first characters of words that are to be titlecased.
        /// It is set to the source string (SetText())
        /// and used one or more times for iteration (First() and Next()).
        /// If null, then a word break iterator for the locale is used
        /// (or something equivalent).
        /// </param>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">
        /// Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="edits"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.ToTitleCase(CultureInfo, string, BreakIterator, int)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            CultureInfo locale, BreakIterator iter, <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            CultureInfo locale, BreakIterator iter, <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            if (iter == null && locale == null)
            {
                locale = CultureInfo.CurrentCulture;
            }
            iter = CaseMapImpl.GetTitleBreakIterator(locale, internalOptions, iter);
            iter.SetText(src);
            return CaseMapImpl.ToTitle(
                    GetCaseLocale(locale), internalOptions, iter, src, dest, edits);
        }

    <# } #>
<# } #>
    }

    public sealed partial class FoldCaseMap : CaseMap
    {
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Case-folds a string.
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <remarks>
        /// Case-folding is locale-independent and not context-sensitive,
        /// but there is an option for whether to include or exclude mappings for dotted I
        /// and dotless i that are marked with 'T' in CaseFolding.txt.
        /// </remarks>
        /// <param name="src">The original string.</param>
        /// <returns>The result string.</returns>
        /// <seealso cref="UChar.FoldCase(string, Globalization.FoldCase)"/>
        /// <draft>ICU 60</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> string Apply(<#=charSequence#> src)
        {
            return CaseMapImpl.Fold(internalOptions, src);
        }
<# } #>
<# foreach (var appendable in appendables) { #>
    <# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Case-folds a string and optionally records edits (see <see cref="OmitUnchangedText"/>).
        /// The result may be longer or shorter than the original.
        /// </summary>
        /// <remarks>
        /// Case-folding is locale-independent and not context-sensitive,
        /// but there is an option for whether to include or exclude mappings for dotted I
        /// and dotless i that are marked with 'T' in CaseFolding.txt.
        /// </remarks>
        /// <param name="src">The original string.</param>
        /// <param name="dest">A buffer for the result string. Must not be null.</param>
        /// <param name="edits">
        /// Records edits for index mapping, working with styled text,
        /// and getting only changes (if any).
        /// This function calls <see cref="Edits.Reset()"/> first. <paramref name="edits"/> can be null.
        /// </param>
        /// <returns><paramref name="dest"/> with the result string (or only changes) appended.</returns>
        /// <seealso cref="UChar.FoldCase(string, Globalization.FoldCase)"/>
        /// <draft>ICU 59</draft>
        /// <provisional>This API might change or be removed in a future release.</provisional>
<# if (appendable == "IAppendable") { #>
        <#=appendableAccessibility#> T Apply<T>(
            <#=charSequence#> src, T dest, Edits edits) where T : <#=appendable#>
<# } else { #>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> <#=appendable#> Apply(
            <#=charSequence#> src, <#=appendable#> dest, Edits edits)
<# } #>
        {
            return CaseMapImpl.Fold(internalOptions, src, dest, edits);
        }
    <# } #>
<# } #>

    }
}