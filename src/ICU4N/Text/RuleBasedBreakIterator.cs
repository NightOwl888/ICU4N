using ICU4N.Impl;
using ICU4N.Globalization;
using ICU4N.Support;
using ICU4N.Support.IO;
using ICU4N.Support.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;

namespace ICU4N.Text
{
    /// <summary>
    /// Rule Based Break Iterator
    /// <para/>
    /// This is a port of the C++ class RuleBasedBreakIterator from ICU4C.
    /// </summary>
    /// <stable>ICU 2.0</stable>
    public partial class RuleBasedBreakIterator : BreakIterator
    {
        //=======================================================================
        // Constructors & Factories
        //=======================================================================

        /// <summary>
        /// Private constructor.
        /// </summary>
        private RuleBasedBreakIterator()
        {
            fBreakCache = new BreakCache(this);
            fDictionaryCache = new DictionaryCache(this);
            fDictionaryCharCount = 0;
            lock (gAllBreakEngines)
            {
                fBreakEngines = new List<ILanguageBreakEngine>(gAllBreakEngines);
            }
        }

        /// <summary>
        /// Create a break iterator from a precompiled set of break rules.
        /// <para/>
        /// Creating a break iterator from the binary rules is much faster than
        /// creating one from source rules.
        /// <para/>
        /// The binary rules are generated by the <see cref="RuleBasedBreakIterator.CompileRules(string, Stream)"/> function.
        /// Binary break iterator rules are not guaranteed to be compatible between
        /// different versions of ICU.
        /// </summary>
        /// <param name="input">An input stream supplying the compiled binary rules.</param>
        /// <exception cref="IOException">If there is an error while reading the rules from the <see cref="Stream"/>.</exception>
        /// <seealso cref="CompileRules(string, Stream)"/>
        /// <stable>ICU 4.8</stable>
        public static RuleBasedBreakIterator GetInstanceFromCompiledRules(Stream input)
        {
            RuleBasedBreakIterator This = new RuleBasedBreakIterator();
            This.fRData = RBBIDataWrapper.Get(ICUBinary.GetByteBufferFromStreamAndDisposeStream(input));
            return This;
        }

        /// <summary>
        /// Create a break iterator from a precompiled set of break rules.
        /// <para/>
        /// Creating a break iterator from the binary rules is much faster than
        /// creating one from source rules.
        /// <para/>
        /// The binary rules are generated by the <see cref="RuleBasedBreakIterator.CompileRules(string, Stream)"/> function.
        /// Binary break iterator rules are not guaranteed to be compatible between
        /// different versions of ICU.
        /// </summary>
        /// <param name="bytes">A buffer supplying the compiled binary rules.</param>
        /// <exception cref="IOException">If there is an error while reading the rules from the buffer.</exception>
        /// <seealso cref="CompileRules(string, Stream)"/>
        [Obsolete("This API is ICU internal only.")]
        public static RuleBasedBreakIterator GetInstanceFromCompiledRules(ByteBuffer bytes)
        {
            RuleBasedBreakIterator This = new RuleBasedBreakIterator();
            This.fRData = RBBIDataWrapper.Get(bytes);
            return This;
        }

        /// <summary>
        /// Construct a <see cref="RuleBasedBreakIterator"/> from a set of rules supplied as a string.
        /// </summary>
        /// <param name="rules">The break rules to be used.</param>
        /// <stable>ICU 2.2</stable>
        public RuleBasedBreakIterator(string rules)
            : this()
        {
            try
            {
                MemoryStream ruleOS = new MemoryStream();
                CompileRules(rules, ruleOS);
                fRData = RBBIDataWrapper.Get(ByteBuffer.Wrap(ruleOS.ToArray()));
            }
            catch (IOException e)
            {
                //CLOVER:OFF
                // An IO exception can only arrive here if there is a bug in the RBBI Rule compiler,
                //  causing bogus compiled rules to be produced, but with no compile error raised.
                Exception rte = new Exception("RuleBasedBreakIterator rule compilation internal error: "
                        + e.Message, e);
                throw rte;
                //CLOVER:ON
            }
        }

        //=======================================================================
        // Boilerplate
        //=======================================================================

        /// <summary>
        /// Clones this iterator.
        /// </summary>
        /// <returns>A newly-constructed <see cref="RuleBasedBreakIterator"/> with the same
        /// behavior as this one.</returns>
        /// <stable>ICU 2.0</stable>
        public override object Clone()
        {
            RuleBasedBreakIterator result;
            result = (RuleBasedBreakIterator)base.Clone();
            if (fText != null)
            {
                result.fText = (CharacterIterator)(fText.Clone());
            }
            lock (gAllBreakEngines)
            {
                result.fBreakEngines = new List<ILanguageBreakEngine>(gAllBreakEngines);
            }
            result.fLookAheadMatches = new LookAheadResults();
            result.fBreakCache = new BreakCache(result, fBreakCache);
            result.fDictionaryCache = new DictionaryCache(result, fDictionaryCache);
            return result;
        }

        /// <summary>
        /// Returns true if both <see cref="BreakIterator"/>s are of the same class, have the same
        /// rules, and iterate over the same text.
        /// </summary>
        /// <stable>ICU 2.0</stable>
        public override bool Equals(object that)
        {
            if (that == null)
            {
                return false;
            }
            if (this == that)
            {
                return true;
            }
            try
            {
                RuleBasedBreakIterator other = (RuleBasedBreakIterator)that;
                if (fRData != other.fRData && (fRData == null || other.fRData == null))
                {
                    return false;
                }
                if (fRData != null && other.fRData != null &&
                        (!fRData.fRuleSource.Equals(other.fRData.fRuleSource)))
                {
                    return false;
                }
                if (fText == null && other.fText == null)
                {
                    return true;
                }
                if (fText == null || other.fText == null || !fText.Equals(other.fText))
                {
                    return false;
                }
                return fPosition == other.fPosition;
            }
            catch (InvalidCastException)
            {
                return false;
            }
        }

        /// <summary>
        /// Returns the description (rules) used to create this iterator.
        /// (In ICU4C, the same function is RuleBasedBreakIterator::getRules())
        /// </summary>
        /// <stable>ICU 2.0</stable>
        public override string ToString()
        {
            string retStr = "";
            if (fRData != null)
            {
                retStr = fRData.fRuleSource;
            }
            return retStr;
        }

        /// <summary>
        /// Compute a hashcode for this <see cref="BreakIterator"/>.
        /// </summary>
        /// <returns>A hash code.</returns>
        /// <stable>ICU 2.0</stable>
        public override int GetHashCode()
        {
            return fRData.fRuleSource.GetHashCode();
        }


        private static readonly int START_STATE = 1;     // The state number of the starting state
        private static readonly int STOP_STATE = 0;     // The state-transition value indicating "stop"

        // RBBIRunMode - the state machine runs an extra iteration at the beginning and end
        //               of user text.  A variable with this enum type keeps track of where we
        //               are.  The state machine only fetches user text input while in RUN mode.
        private static readonly int RBBI_START = 0;
        private static readonly int RBBI_RUN = 1;
        private static readonly int RBBI_END = 2;

        /// <summary>
        /// The character iterator through which this <see cref="BreakIterator"/> accesses the text.
        /// </summary>
        private CharacterIterator fText = new StringCharacterIterator("");

        /// <summary>
        /// The rule data for this <see cref="BreakIterator"/> instance. Package private.
        /// </summary>
        RBBIDataWrapper fRData;

        /// <summary>
        /// The iteration state - current position, rule status for the current position,
        ///                       and whether the iterator ran off the end, yielding <see cref="BreakIterator.Done"/>.
        ///                       Current position is pinned to be 0 &lt; position &lt;= text.Length.
        ///                       Current position is always set to a boundary.
        /// <para/>
        /// The current  position of the iterator. Pinned, 0 &lt; fPosition &lt;= text.Length.
        /// Never has the value <see cref="BreakIterator.Done"/> (-1).
        /// </summary>
        private int fPosition;

        /// <summary>
        /// Index of the Rule {tag} values for the most recent match.
        /// </summary>
        private int fRuleStatusIndex;

        /// <summary>
        /// True when iteration has run off the end, and iterator functions should return UBRK_DONE.
        /// </summary>
        private bool fDone;

        /// <summary>
        /// Cache of previously determined boundary positions.
        /// </summary>
        // ICU4N specific - this is set in the constructor
        private BreakCache fBreakCache;

        /// <summary>
        /// Counter for the number of characters encountered with the "dictionary"
        /// flag set.  Normal RBBI iterators don't use it, although the code
        /// for updating it is live.  Dictionary Based break iterators (a subclass
        /// of us) access this field directly.
        /// </summary>
        /// <internal/>
        private int fDictionaryCharCount;

        // ICU4N specific - this is set in the constructor
        private DictionaryCache fDictionaryCache;

        /// <summary>
        /// ICU debug argument name for RBBI
        /// </summary>
        private static readonly string RBBI_DEBUG_ARG = "rbbi";

        /// <summary>
        /// Debugging flag.  Trace operation of state machine when true.
        /// </summary>
        private static readonly bool TRACE = ICUDebug.Enabled(RBBI_DEBUG_ARG)
                && ICUDebug.Value(RBBI_DEBUG_ARG).IndexOf("trace") >= 0;

        /// <summary>
        /// What kind of break iterator this is.
        /// Defaulting <see cref="BreakType"/> to word gives reasonable dictionary behavior for
        /// Break Iterators that are built from rules.
        /// </summary>
        private int fBreakType = KIND_WORD;

        /// <summary>
        /// The "default" break engine - just skips over ranges of dictionary words,
        /// producing no breaks. Should only be used if characters need to be handled
        /// by a dictionary but we have no dictionary implementation for them.
        /// <para/>
        /// Only one instance; shared by all break iterators.
        /// </summary>
        private static readonly UnhandledBreakEngine gUnhandledBreakEngine;

        /// <summary>
        /// List of all known break engines, common for all break iterators.
        /// Lazily updated as break engines are needed, because instantiation of
        /// break engines is expensive.
        /// <para/>
        /// Because <see cref="gAllBreakEngines"/> can be referenced concurrently from different
        /// <see cref="BreakIterator"/> instances, all access is synchronized.
        /// </summary>
        private static readonly IList<ILanguageBreakEngine> gAllBreakEngines;

        static RuleBasedBreakIterator()
        {
            gUnhandledBreakEngine = new UnhandledBreakEngine();
            gAllBreakEngines = new List<ILanguageBreakEngine>();
            gAllBreakEngines.Add(gUnhandledBreakEngine);
        }

        /// <summary>
        /// List of all known break engines. Similar to <see cref="gAllBreakEngines"/>, but local to a
        /// break iterator, allowing it to be used without synchronization.
        /// </summary>
        private IList<ILanguageBreakEngine> fBreakEngines;

        /// <summary>
        /// Dump the contents of the state table and character classes for this break iterator.
        /// For debugging only.
        /// </summary>
        /// <internal/>
        [Obsolete("This API is ICU internal only.")]
        public void Dump(TextWriter output)
        {
            if (output == null)
            {
                output = Console.Out;
            }
            this.fRData.Dump(output);
        }

        /// <summary>
        /// Compile a set of source break rules into the binary state tables used
        /// by the break iterator engine.  Creating a break iterator from precompiled
        /// rules is much faster than creating one from source rules.
        /// <para/>
        /// Binary break rules are not guaranteed to be compatible between different
        /// versions of ICU.
        /// </summary>
        /// <param name="rules">The source form of the break rules.</param>
        /// <param name="ruleBinary">An output stream to receive the compiled rules.</param>
        /// <exception cref="IOException">If there is an error writing the output.</exception>
        /// <seealso cref="GetInstanceFromCompiledRules(Stream)"/>
        /// <stable>ICU 4.8</stable>
        public static void CompileRules(string rules, Stream ruleBinary)
        {
            RBBIRuleBuilder.CompileRules(rules, ruleBinary);
        }

        //=======================================================================
        // BreakIterator overrides
        //=======================================================================

        /// <summary>
        /// Sets the current iteration position to the beginning of the text.
        /// (i.e., the <see cref="CharacterIterator"/>'s starting offset).
        /// </summary>
        /// <returns>The offset of the beginning of the text.</returns>
        /// <stable>ICU 2.0</stable>
        public override int First()
        {
            if (fText == null)
            {
                return BreakIterator.Done;
            }
            fText.First();
            int start = fText.Index;
            if (!fBreakCache.Seek(start))
            {
                fBreakCache.PopulateNear(start);
            }
            fBreakCache.Current();
            Debug.Assert(fPosition == start);
            return fPosition;
        }

        /// <summary>
        /// Sets the current iteration position to the end of the text.
        /// (i.e., the <see cref="CharacterIterator"/>'s ending offset).
        /// </summary>
        /// <returns>The text's past-the-end offset.</returns>
        /// <stable>ICU 2.0</stable>
        public override int Last()
        {
            if (fText == null)
            {
                return BreakIterator.Done;
            }
            int endPos = fText.EndIndex;
            bool endShouldBeBoundary = IsBoundary(endPos);      // Has side effect of setting iterator position.
            Debug.Assert(endShouldBeBoundary);
            if (fPosition != endPos)
            {
                Debug.Assert(fPosition == endPos);
            }
            return endPos;
        }

        /// <summary>
        /// Advances the iterator either forward or backward the specified number of steps.
        /// Negative values move backward, and positive values move forward.  This is
        /// equivalent to repeatedly calling <see cref="Next()"/> or <see cref="Previous()"/>.
        /// </summary>
        /// <param name="n">The number of steps to move.  The sign indicates the direction
        /// (negative is backwards, and positive is forwards).</param>
        /// <returns>The character offset of the boundary position n boundaries away from
        /// the current one.</returns>
        /// <stable>ICU 2.0</stable>
        public override int Next(int n)
        {
            int result = 0;
            if (n > 0)
            {
                for (; n > 0 && result != Done; --n)
                {
                    result = Next();
                }
            }
            else if (n < 0)
            {
                for (; n < 0 && result != Done; ++n)
                {
                    result = Previous();
                }
            }
            else
            {
                result = Current;
            }
            return result;
        }

        /// <summary>
        /// Advances the iterator to the next boundary position.
        /// </summary>
        /// <returns>The position of the first boundary after this one.</returns>
        /// <stable>ICU 2.0</stable>
        public override int Next()
        {
            fBreakCache.Next();
            return fDone ? Done : fPosition;
        }

        /// <summary>
        /// Moves the iterator backwards, to the boundary preceding the current one.
        /// </summary>
        /// <returns>The position of the boundary position immediately preceding the starting position.</returns>
        /// <stable>ICU 2.0</stable>
        public override int Previous()
        {
            fBreakCache.Previous();
            return fDone ? Done : fPosition;
        }

        /// <summary>
        /// Sets the iterator to refer to the first boundary position following
        /// the specified position.
        /// </summary>
        /// <param name="startPos">The position from which to begin searching for a break position.</param>
        /// <returns>The position of the first break after the current position.</returns>
        /// <stable>ICU 2.0</stable>
        public override int Following(int startPos)
        {
            // if the supplied position is before the beginning, return the
            // text's starting offset
            if (startPos < fText.BeginIndex)
            {
                return First();
            }

            // Move requested offset to a code point start. It might be on a trail surrogate.
            // Or it may be beyond the end of the text.
            startPos = CISetIndex32(fText, startPos);
            fBreakCache.Following(startPos);
            return fDone ? Done : fPosition;
        }

        /// <summary>
        /// Sets the iterator to refer to the last boundary position before the
        /// specified position.
        /// </summary>
        /// <param name="offset">The position to begin searching for a break from.</param>
        /// <returns>The position of the last boundary before the starting position.</returns>
        /// <stable>ICU 2.0</stable>
        public override int Preceding(int offset)
        {
            if (fText == null || offset > fText.EndIndex)
            {
                return Last();
            }
            else if (offset < fText.BeginIndex)
            {
                return First();
            }

            // Move requested offset to a code point start. It might be on a trail surrogate.
            // int adjustedOffset = CISetIndex32(fText, offset);    // TODO: restore to match ICU4C behavior.
            int adjustedOffset = offset;
            fBreakCache.Preceding(adjustedOffset);
            return fDone ? Done : fPosition;
        }

        /// <exception cref="ArgumentException">Unless begin &lt;= offset &lt; end.</exception>
        /// <stable>ICU 2.0</stable>
        protected static void CheckOffset(int offset, CharacterIterator text)
        {
            if (offset < text.BeginIndex || offset > text.EndIndex)
            {
                throw new ArgumentException("offset out of bounds");
            }
        }

        /// <summary>
        /// Returns true if the specified position is a boundary position.  As a side
        /// effect, leaves the iterator pointing to the first boundary position at
        /// or after "<paramref name="offset"/>".
        /// </summary>
        /// <param name="offset">The offset to check.</param>
        /// <returns>True if "<paramref name="offset"/>" is a boundary position.</returns>
        /// <stable>ICU 2.0</stable>
        public override bool IsBoundary(int offset)
        {
            // TODO: behavior difference with ICU4C, which considers out-of-range offsets
            //       to not be boundaries, and to not be errors.
            CheckOffset(offset, fText);

            // Adjust offset to be on a code point boundary and not beyond the end of the text.
            // Note that isBoundary() is always be false for offsets that are not on code point boundaries.
            // But we still need the side effect of leaving iteration at the following boundary.
            int adjustedOffset = CISetIndex32(fText, offset);

            bool result = false;
            if (fBreakCache.Seek(adjustedOffset) || fBreakCache.PopulateNear(adjustedOffset))
            {
                result = (fBreakCache.Current() == offset);
            }

            if (!result)
            {
                // Not on a boundary. isBoundary() must leave iterator on the following boundary.
                // fBreakCache.seek(), above, left us on the preceding boundary, so advance one.
                Next();
            }
            return result;
        }

        /// <summary>
        /// Returns the current iteration position.  Note that <see cref="BreakIterator.Done"/> is never
        /// returned from this function; if iteration has run to the end of a
        /// string, <see cref="Current"/> will return the length of the string while
        /// <see cref="Next()"/> will return <see cref="BreakIterator.Done"/>.
        /// </summary>
        /// <stable>ICU 2.0</stable>
        public override int Current
        {
            get { return (fText != null) ? fPosition : BreakIterator.Done; }
        }

        /// <summary>
        /// Gets the status tag from the break rule that determined the most recently
        /// returned break position.
        /// </summary>
        /// <remarks>
        /// The values appear in the rule source
        /// within brackets, {123}, for example.  For rules that do not specify a
        /// status, a default value of 0 is returned.  If more than one rule applies,
        /// the numerically largest of the possible status values is returned.
        /// <para/>
        /// Of the standard types of ICU break iterators, only the word and line break
        /// iterator provides status values.  The values are defined in
        /// class <see cref="RuleBasedBreakIterator"/>, and allow distinguishing between words
        /// that contain alphabetic letters, "words" that appear to be numbers,
        /// punctuation and spaces, words containing ideographic characters, and
        /// more.  Call <see cref="RuleStatus"/> after obtaining a boundary
        /// position from <see cref="Next()"/>, <see cref="Previous()"/>, or
        /// any other break iterator functions that returns a boundary position.
        /// </remarks>
        /// <stable>ICU 60</stable>
        public override RuleStatus RuleStatus
        {
            get
            {
                //   Status records have this form:
                //           Count N         <--  fLastRuleStatusIndex points here.
                //           Status val 0
                //           Status val 1
                //              ...
                //           Status val N-1  <--  the value we need to return
                //   The status values are sorted in ascending order.
                //   This function returns the last (largest) of the array of status values.
                int idx = fRuleStatusIndex + fRData.fStatusTable[fRuleStatusIndex];
                int tagVal = fRData.fStatusTable[idx];
                return (RuleStatus)tagVal;
            }
        }

        /// <summary>
        /// Get the status (tag) values from the break rule(s) that determined the most
        /// recently returned break position.  
        /// </summary>
        /// <remarks>
        /// The values appear in the rule source
        /// within brackets, {123}, for example.  The default status value for rules
        /// that do not explicitly provide one is zero.
        /// <para/>
        /// The status values used by the standard ICU break rules are defined
        /// as public constants in class <see cref="RuleBasedBreakIterator"/>.
        /// <para/>
        /// If the size  of the output array is insufficient to hold the data,
        /// the output will be truncated to the available length.  No exception
        /// will be thrown.
        /// </remarks>
        /// <param name="fillInArray">An array to be filled in with the status values.</param>
        /// <returns>
        /// The number of rule status values from rules that determined
        /// the most recent boundary returned by the break iterator.
        /// In the event that the array is too small, the return value
        /// is the total number of status values that were available,
        /// not the reduced number that were actually returned.
        /// </returns>
        /// <stable>ICU 60</stable>
        public override int GetRuleStatusVec(int[] fillInArray)
        {
            int numStatusVals = fRData.fStatusTable[fRuleStatusIndex];
            if (fillInArray != null)
            {
                int numToCopy = Math.Min(numStatusVals, fillInArray.Length);
                for (int i = 0; i < numToCopy; i++)
                {
                    fillInArray[i] = fRData.fStatusTable[fRuleStatusIndex + i + 1];
                }
            }
            return numStatusVals;
        }

        /// <summary>
        /// Gets a <see cref="CharacterIterator"/> over the text being analyzed.  This version
        /// of this property returns the actual <see cref="CharacterIterator"/> we're using internally.
        /// Changing the state of this iterator can have undefined consequences.  If
        /// you need to change it, clone it first.
        /// </summary>
        /// <returns>An iterator over the text being analyzed.</returns>
        /// <stable>ICU 2.0</stable>
        public override CharacterIterator Text
        {
            get { return fText; }
        }

        /// <summary>
        /// Set the iterator to analyze a new piece of text.  This function resets
        /// the current iteration position to the beginning of the text.
        /// </summary>
        /// <param name="newText">An iterator over the text to analyze.</param>
        /// <stable>ICU 2.0</stable>
        public override void SetText(CharacterIterator newText)
        {
            if (newText != null)
            {
                fBreakCache.Reset(newText.BeginIndex, 0);
            }
            else
            {
                fBreakCache.Reset();
            }
            fDictionaryCache.Reset();
            fText = newText;
            this.First();
        }

        /// <summary>
        /// Internal.
        /// </summary>
        internal int BreakType
        {
            get { return fBreakType; }
            set { fBreakType = value; }
        }

        /// <summary>
        /// Control debug, trace and dump options.
        /// </summary>
        /// <internal/>
        internal static readonly string fDebugEnv = ICUDebug.Enabled(RBBI_DEBUG_ARG) ?
                                            ICUDebug.Value(RBBI_DEBUG_ARG) : null;


        private ILanguageBreakEngine GetLanguageBreakEngine(int c)
        {

            // We have a dictionary character.
            // Does an already instantiated break engine handle it?
            foreach (ILanguageBreakEngine candidate in fBreakEngines)
            {
                if (candidate.Handles(c, fBreakType))
                {
                    return candidate;
                }
            }

            lock (gAllBreakEngines)
            {
                // This break iterator's list of break engines didn't handle the character.
                // Check the global list, another break iterator may have instantiated the
                // desired engine.
                foreach (ILanguageBreakEngine candidate in gAllBreakEngines)
                {
                    if (candidate.Handles(c, fBreakType))
                    {
                        fBreakEngines.Add(candidate);
                        return candidate;
                    }
                }

                // The global list doesn't have an existing engine, build one.
                int script = UChar.GetIntPropertyValue(c, UProperty.Script);
                if (script == UScript.Katakana || script == UScript.Hiragana)
                {
                    // Katakana, Hiragana and Han are handled by the same dictionary engine.
                    // Fold them together for mapping from script -> engine.
                    script = UScript.Han;
                }

                ILanguageBreakEngine eng;
                try
                {
                    switch (script)
                    {
                        case UScript.Thai:
                            eng = new ThaiBreakEngine();
                            break;
                        case UScript.Lao:
                            eng = new LaoBreakEngine();
                            break;
                        case UScript.Myanmar:
                            eng = new BurmeseBreakEngine();
                            break;
                        case UScript.Khmer:
                            eng = new KhmerBreakEngine();
                            break;
                        case UScript.Han:
                            if (BreakType == KIND_WORD)
                            {
                                eng = new CjkBreakEngine(false);
                            }
                            else
                            {
                                gUnhandledBreakEngine.HandleChar(c, BreakType);
                                eng = gUnhandledBreakEngine;
                            }
                            break;
                        case UScript.Hangul:
                            if (BreakType == KIND_WORD)
                            {
                                eng = new CjkBreakEngine(true);
                            }
                            else
                            {
                                gUnhandledBreakEngine.HandleChar(c, BreakType);
                                eng = gUnhandledBreakEngine;
                            }
                            break;
                        default:
                            gUnhandledBreakEngine.HandleChar(c, BreakType);
                            eng = gUnhandledBreakEngine;
                            break;
                    }
                }
                catch (IOException)
                {
                    eng = null;
                }

                if (eng != null && eng != gUnhandledBreakEngine)
                {
                    gAllBreakEngines.Add(eng);
                    fBreakEngines.Add(eng);
                }
                return eng;
            }   // end synchronized(gAllBreakEngines)
        }

        private static readonly int kMaxLookaheads = 8;
        private class LookAheadResults
        {
            int fUsedSlotLimit;
            int[] fPositions;
            int[] fKeys;

            internal LookAheadResults()
            {
                fUsedSlotLimit = 0;
                fPositions = new int[kMaxLookaheads];
                fKeys = new int[kMaxLookaheads];
            }

            internal int GetPosition(int key)
            {
                for (int i = 0; i < fUsedSlotLimit; ++i)
                {
                    if (fKeys[i] == key)
                    {
                        return fPositions[i];
                    }
                }
                Debug.Assert(false);
                return -1;
            }

            internal void SetPosition(int key, int position)
            {
                int i;
                for (i = 0; i < fUsedSlotLimit; ++i)
                {
                    if (fKeys[i] == key)
                    {
                        fPositions[i] = position;
                        return;
                    }
                }
                if (i >= kMaxLookaheads)
                {
                    Debug.Assert(false);
                    i = kMaxLookaheads - 1;
                }
                fKeys[i] = key;
                fPositions[i] = position;
                Debug.Assert(fUsedSlotLimit == i);
                fUsedSlotLimit = i + 1;
            }

            internal void Reset()
            {
                fUsedSlotLimit = 0;
            }
        };
        private LookAheadResults fLookAheadMatches = new LookAheadResults();

        /// <summary>
        /// The State Machine Engine for moving forward is here.
        /// This function is the heart of the RBBI run time engine.
        /// </summary>
        /// <remarks>
        /// <code>
        /// Input
        ///    fPosition, the position in the text to begin from.
        /// Output
        ///    fPosition:           the boundary following the starting position.
        ///    fDictionaryCharCount the number of dictionary characters encountered.
        ///                         If > 0, the segment will be further subdivided
        ///    fRuleStatusIndex     Info from the state table indicating which rules caused the boundary.
        /// </code>
        /// <para/>
        /// A note on supplementary characters and the position of underlying
        /// <see cref="CharacterIterator"/>:   Normally, a character iterator is positioned at
        /// the char most recently returned by <see cref="Next()"/>.  Within this function, when
        /// a supplementary char is being processed, the char iterator is left
        /// sitting on the trail surrogate, in the middle of the code point.
        /// This is different from everywhere else, where an iterator always
        /// points at the lead surrogate of a supplementary.
        /// </remarks>
        /// <returns>The new iterator position.</returns>
        private int HandleNext()
        {
            if (TRACE)
            {
                Console.Out.WriteLine("Handle Next   pos      char  state category");
            }

            // handleNext always sets the break tag value.
            // Set the default for it.
            fRuleStatusIndex = 0;
            fDictionaryCharCount = 0;

            // caches for quicker access
            CharacterIterator text = fText;
            Trie2 trie = fRData.fTrie;

            short[] stateTable = fRData.fFTable;
            int initialPosition = fPosition;
            text.SetIndex(initialPosition);
            int result = initialPosition;

            // Set up the starting char
            int c = text.Current;
            if (c >= UTF16.LeadSurrogateMinValue)
            {
                c = CharacterIteration.NextTrail32(text, c);
                if (c == CharacterIteration.Done32)
                {
                    fDone = true;
                    return BreakIterator.Done;
                }
            }

            // Set the initial state for the state machine
            int state = START_STATE;
            int row = fRData.GetRowIndex(state);
            short category = 3;
            int flagsState = fRData.GetStateTableFlags(stateTable);
            int mode = RBBI_RUN;
            if ((flagsState & RBBIDataWrapper.RBBI_BOF_REQUIRED) != 0)
            {
                category = 2;
                mode = RBBI_START;
                if (TRACE)
                {
                    Console.Out.Write("            " + RBBIDataWrapper.Int32ToString(text.Index, 5));
                    Console.Out.Write(RBBIDataWrapper.Int32ToHexString(c, 10));
                    Console.Out.WriteLine(RBBIDataWrapper.Int32ToString(state, 7) + RBBIDataWrapper.Int32ToString(category, 6));
                }
            }
            fLookAheadMatches.Reset();

            // loop until we reach the end of the text or transition to state 0
            while (state != STOP_STATE)
            {
                if (c == CharacterIteration.Done32)
                {
                    // Reached end of input string.
                    if (mode == RBBI_END)
                    {
                        // We have already run the loop one last time with the
                        // character set to the pseudo {eof} value. Now it is time
                        // to unconditionally bail out.
                        break;
                    }
                    // Run the loop one last time with the fake end-of-input character category
                    mode = RBBI_END;
                    category = 1;
                }
                else if (mode == RBBI_RUN)
                {
                    // Get the char category.  An incoming category of 1 or 2 mens that
                    //      we are preset for doing the beginning or end of input, and
                    //      that we shouldn't get a category from an actual text input character.
                    //

                    // look up the current character's character category, which tells us
                    // which column in the state table to look at.
                    //
                    category = (short)trie.Get(c);

                    // Check the dictionary bit in the character's category.
                    //    Counter is only used by dictionary based iterators (subclasses).
                    //    Chars that need to be handled by a dictionary have a flag bit set
                    //    in their category values.
                    //
                    if ((category & 0x4000) != 0)
                    {
                        fDictionaryCharCount++;
                        //  And off the dictionary flag bit.
                        category &= ~0x4000;
                    }

                    if (TRACE)
                    {
                        Console.Out.Write("            " + RBBIDataWrapper.Int32ToString(text.Index, 5));
                        Console.Out.Write(RBBIDataWrapper.Int32ToHexString(c, 10));
                        Console.Out.WriteLine(RBBIDataWrapper.Int32ToString(state, 7) + RBBIDataWrapper.Int32ToString(category, 6));
                    }

                    // Advance to the next character.
                    // If this is a beginning-of-input loop iteration, don't advance.
                    //    The next iteration will be processing the first real input character.
                    c = text.Next();
                    if (c >= UTF16.LeadSurrogateMinValue)
                    {
                        c = CharacterIteration.NextTrail32(text, c);
                    }
                }
                else
                {
                    mode = RBBI_RUN;
                }

                // look up a state transition in the state table
                state = stateTable[row + RBBIDataWrapper.NEXTSTATES + category];
                row = fRData.GetRowIndex(state);

                if (stateTable[row + RBBIDataWrapper.ACCEPTING] == -1)
                {
                    // Match found, common case
                    result = text.Index;
                    if (c >= UTF16.SupplementaryMinValue && c <= UTF16.CodePointMaxValue)
                    {
                        // The iterator has been left in the middle of a surrogate pair.
                        // We want the start of it.
                        result--;
                    }

                    //  Remember the break status (tag) values.
                    fRuleStatusIndex = stateTable[row + RBBIDataWrapper.TAGIDX];
                }

                int completedRule = stateTable[row + RBBIDataWrapper.ACCEPTING];
                if (completedRule > 0)
                {
                    // Lookahead match is completed
                    int lookaheadResult = fLookAheadMatches.GetPosition(completedRule);
                    if (lookaheadResult >= 0)
                    {
                        fRuleStatusIndex = stateTable[row + RBBIDataWrapper.TAGIDX];
                        fPosition = lookaheadResult;
                        return lookaheadResult;
                    }
                }

                int rule = stateTable[row + RBBIDataWrapper.LOOKAHEAD];
                if (rule != 0)
                {
                    // At the position of a '/' in a look-ahead match. Record it.
                    int pos = text.Index;
                    if (c >= UTF16.SupplementaryMinValue && c <= UTF16.CodePointMaxValue)
                    {
                        // The iterator has been left in the middle of a surrogate pair.
                        // We want the beginning  of it.
                        pos--;
                    }
                    fLookAheadMatches.SetPosition(rule, pos);
                }


            }        // End of state machine main loop

            // The state machine is done.  Check whether it found a match...

            // If the iterator failed to advance in the match engine force it ahead by one.
            // This indicates a defect in the break rules, which should always match
            // at least one character.

            if (result == initialPosition)
            {
                if (TRACE)
                {
                    Console.Out.WriteLine("Iterator did not move. Advancing by 1.");
                }
                text.SetIndex(initialPosition);
                CharacterIteration.Next32(text);
                result = text.Index;
                fRuleStatusIndex = 0;
            }

            // Leave the iterator at our result position.
            //   (we may have advanced beyond the last accepting position chasing after
            //    longer matches that never completed.)
            fPosition = result;

            if (TRACE)
            {
                Console.Out.WriteLine("result = " + result);
            }
            return result;
        }

        /// <summary>
        /// Iterate backwards from an arbitrary position in the input text using the Safe Reverse rules.
        /// This locates a "Safe Position" from which the forward break rules
        /// will operate correctly. A Safe Position is not necessarily a boundary itself.
        /// </summary>
        /// <remarks>
        /// The logic of this function is very similar to <see cref="HandleNext()"/>.
        /// </remarks>
        /// <param name="fromPosition">The position in the input text to begin the iteration.</param>
        /// <internal/>
        private int HandlePrevious(int fromPosition)
        {
            if (fText == null)
            {
                return 0;
            }

            int state;
            int category = 0;
            int mode;
            int row;
            int c;
            int result = 0;
            int initialPosition = fromPosition;
            fLookAheadMatches.Reset();
            short[] stateTable = fRData.fSRTable;
            CISetIndex32(fText, fromPosition);
            if (fromPosition == fText.BeginIndex)
            {
                return BreakIterator.Done;
            }

            // set up the starting char
            result = initialPosition;
            c = CharacterIteration.Previous32(fText);

            // Set up the initial state for the state machine
            state = START_STATE;
            row = fRData.GetRowIndex(state);
            category = 3;   // TODO:  obsolete?  from the old start/run mode scheme?
            mode = RBBI_RUN;
            if ((fRData.GetStateTableFlags(stateTable) & RBBIDataWrapper.RBBI_BOF_REQUIRED) != 0)
            {
                category = 2;
                mode = RBBI_START;
            }

            if (TRACE)
            {
                Console.Out.WriteLine("Handle Prev   pos   char  state category ");
            }

            // loop until we reach the beginning of the text or transition to state 0
            //
            //mainLoop:
            for (; ; )
            {
                if (c == CharacterIteration.Done32)
                {
                    // Reached end of input string.
                    if (mode == RBBI_END)
                    {
                        // We have already done the {eof} iteration.  Now is the time
                        // to unconditionally bail out.
                        goto mainLoop_break;
                    }
                    mode = RBBI_END;
                    category = 1;
                }

                if (mode == RBBI_RUN)
                {
                    // look up the current character's category, which tells us
                    // which column in the state table to look at.
                    //
                    //  And off the dictionary flag bit. For reverse iteration it is not used.
                    category = (short)fRData.fTrie.Get(c);
                    category &= ~0x4000;
                }

                if (TRACE)
                {
                    Console.Out.Write("             " + fText.Index + "   ");
                    if (0x20 <= c && c < 0x7f)
                    {
                        Console.Out.Write("  " + c + "  ");
                    }
                    else
                    {
                        Console.Out.Write(" " + (c).ToHexString() + " ");
                    }
                    Console.Out.WriteLine(" " + state + "  " + category + " ");
                }

                // State Transition - move machine to its next state
                //
                state = stateTable[row + RBBIDataWrapper.NEXTSTATES + category];
                row = fRData.GetRowIndex(state);

                if (stateTable[row + RBBIDataWrapper.ACCEPTING] == -1)
                {
                    // Match found, common case, could have lookahead so we move
                    // on to check it
                    result = fText.Index;
                }


                int completedRule = stateTable[row + RBBIDataWrapper.ACCEPTING];
                if (completedRule > 0)
                {
                    // Lookahead match is completed.
                    int lookaheadResult = fLookAheadMatches.GetPosition(completedRule);
                    if (lookaheadResult >= 0)
                    {
                        result = lookaheadResult;
                        goto mainLoop_break;
                    }
                }
                int rule = stateTable[row + RBBIDataWrapper.LOOKAHEAD];
                if (rule != 0)
                {
                    // At the position of a '/' in a look-ahead match. Record it.
                    int pos = fText.Index;
                    fLookAheadMatches.SetPosition(rule, pos);
                }

                if (state == STOP_STATE)
                {
                    // Normal loop exit is here
                    goto mainLoop_break;
                }

                // then move iterator position backwards one character
                //
                if (mode == RBBI_RUN)
                {
                    c = CharacterIteration.Previous32(fText);
                }
                else
                {
                    if (mode == RBBI_START)
                    {
                        mode = RBBI_RUN;
                    }
                }


            }   // End of the main loop.
            mainLoop_break: { }

            // The state machine is done.  Check whether it found a match...
            //
            // If the iterator failed to move in the match engine, force it back by one code point.
            //   (This really indicates a defect in the break rules.  They should always match
            //    at least one character.)
            if (result == initialPosition)
            {
                CISetIndex32(fText, initialPosition);
                CharacterIteration.Previous32(fText);
                result = fText.Index;
            }

            if (TRACE)
            {
                Console.Out.WriteLine("Result = " + result);
            }

            return result;
        }

        /// <summary>
        /// Set the index of a <see cref="CharacterIterator"/>.
        /// Pin the index to the valid range range of <see cref="CharacterIterator.BeginIndex"/> &lt;= index &lt;= <see cref="CharacterIterator.EndIndex"/>.
        /// If the index points to a trail surrogate of a supplementary character, adjust it
        /// to the start (lead surrogate) index.
        /// </summary>
        /// <param name="ci">A <see cref="CharacterIterator"/> to set.</param>
        /// <param name="index">The index to set.</param>
        /// <returns>The resulting index, possibly pinned or adjusted.</returns>
        private static int CISetIndex32(CharacterIterator ci, int index)
        {
            if (index <= ci.BeginIndex)
            {
                ci.First();
            }
            else if (index >= ci.EndIndex)
            {
                ci.SetIndex(ci.EndIndex);
            }
            else if (char.IsLowSurrogate(ci.SetIndex(index)))
            {
                if (!char.IsHighSurrogate(ci.Previous()))
                {
                    ci.Next();
                }
            }
            return ci.Index;
        }

        /// <summary>
        /// <see cref="DictionaryCache"/> stores the boundaries obtained from a run of dictionary characters.
        ///                 Dictionary boundaries are moved first to this cache, then from here
        ///                 to the main <see cref="BreakCache"/>, where they may inter-leave with non-dictionary
        ///                 boundaries. The public <see cref="BreakIterator"/> API always fetches directly
        ///                 from the main <see cref="BreakCache"/>, not from here.
        /// <para/>                 
        ///                 In common situations, the number of boundaries in a single dictionary run
        ///                 should be quite small, it will be terminated by punctuation, spaces,
        ///                 or any other non-dictionary characters. The main BreakCache may end
        ///                 up with boundaries from multiple dictionary based runs.
        /// <para/>                
        ///                 The boundaries are stored in a simple <see cref="List{T}"/> (vector), with the
        ///                 assumption that they will be accessed sequentially.
        /// </summary>
        internal class DictionaryCache
        {
            private readonly RuleBasedBreakIterator outerInstance;

            internal void Reset()
            {
                fPositionInCache = -1;
                fStart = 0;
                fLimit = 0;
                fFirstRuleStatusIndex = 0;
                fOtherRuleStatusIndex = 0;
                fBreaks.RemoveAllElements();
            }

            internal bool Following(int fromPos)
            {
                if (fromPos >= fLimit || fromPos < fStart)
                {
                    fPositionInCache = -1;
                    return false;
                }

                // Sequential iteration, move from previous boundary to the following

                int r = 0;
                if (fPositionInCache >= 0 && fPositionInCache < fBreaks.Count && fBreaks.ElementAt(fPositionInCache) == fromPos)
                {
                    ++fPositionInCache;
                    if (fPositionInCache >= fBreaks.Count)
                    {
                        fPositionInCache = -1;
                        return false;
                    }
                    r = fBreaks.ElementAt(fPositionInCache);
                    Debug.Assert(r > fromPos);
                    fBoundary = r;
                    fStatusIndex = fOtherRuleStatusIndex;
                    return true;
                }

                // Random indexing. Linear search for the boundary following the given position.

                for (fPositionInCache = 0; fPositionInCache < fBreaks.Count; ++fPositionInCache)
                {
                    r = fBreaks.ElementAt(fPositionInCache);
                    if (r > fromPos)
                    {
                        fBoundary = r;
                        fStatusIndex = fOtherRuleStatusIndex;
                        return true;
                    }
                }

                // Internal error. fStart <= fromPos < fLimit, but no cached boundary.
                Debug.Assert(false);
                fPositionInCache = -1;
                return false;
            }

            internal bool Preceding(int fromPos)
            {
                if (fromPos <= fStart || fromPos > fLimit)
                {
                    fPositionInCache = -1;
                    return false;
                }

                if (fromPos == fLimit)
                {
                    fPositionInCache = fBreaks.Count - 1;
                    if (fPositionInCache >= 0)
                    {
                        Debug.Assert(fBreaks.ElementAt(fPositionInCache) == fromPos);
                    }
                }

                int r;
                if (fPositionInCache > 0 && fPositionInCache < fBreaks.Count && fBreaks.ElementAt(fPositionInCache) == fromPos)
                {
                    --fPositionInCache;
                    r = fBreaks.ElementAt(fPositionInCache);
                    Debug.Assert(r < fromPos);
                    fBoundary = r;
                    fStatusIndex = (r == fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
                    return true;
                }

                if (fPositionInCache == 0)
                {
                    fPositionInCache = -1;
                    return false;
                }

                for (fPositionInCache = fBreaks.Count - 1; fPositionInCache >= 0; --fPositionInCache)
                {
                    r = fBreaks.ElementAt(fPositionInCache);
                    if (r < fromPos)
                    {
                        fBoundary = r;
                        fStatusIndex = (r == fStart) ? fFirstRuleStatusIndex : fOtherRuleStatusIndex;
                        return true;
                    }
                }
                Debug.Assert(false);
                fPositionInCache = -1;
                return false;
            }

            /// <summary>
            /// Populate the cache with the dictionary based boundaries within a region of text.
            /// </summary>
            /// <param name="startPos">The start position of a range of text.</param>
            /// <param name="endPos">The end position of a range of text.</param>
            /// <param name="firstRuleStatus">The rule status index that applies to the break at <paramref name="startPos"/>.</param>
            /// <param name="otherRuleStatus">The rule status index that applies to boundaries other than <paramref name="startPos"/>.</param>
            /// <internal/>
            internal void PopulateDictionary(int startPos, int endPos,
                                    int firstRuleStatus, int otherRuleStatus)
            {
                if ((endPos - startPos) <= 1)
                {
                    return;
                }

                Reset();
                fFirstRuleStatusIndex = firstRuleStatus;
                fOtherRuleStatusIndex = otherRuleStatus;

                int rangeStart = startPos;
                int rangeEnd = endPos;

                int category;
                int current;
                int foundBreakCount = 0;

                // Loop through the text, looking for ranges of dictionary characters.
                // For each span, find the appropriate break engine, and ask it to find
                // any breaks within the span.

                outerInstance.fText.SetIndex(rangeStart);
                int c = CharacterIteration.Current32(outerInstance.fText);
                category = (short)outerInstance.fRData.fTrie.Get(c);

                while (true)
                {
                    while ((current = outerInstance.fText.Index) < rangeEnd && (category & 0x4000) == 0)
                    {
                        c = CharacterIteration.Next32(outerInstance.fText);    // pre-increment
                        category = (short)outerInstance.fRData.fTrie.Get(c);
                    }
                    if (current >= rangeEnd)
                    {
                        break;
                    }

                    // We now have a dictionary character. Get the appropriate language object
                    // to deal with it.
                    ILanguageBreakEngine lbe = outerInstance.GetLanguageBreakEngine(c);

                    // Ask the language object if there are any breaks. It will add them to the cache and
                    // leave the text pointer on the other side of its range, ready to search for the next one.
                    if (lbe != null)
                    {
                        foundBreakCount += lbe.FindBreaks(outerInstance.fText, rangeStart, rangeEnd, outerInstance.fBreakType, fBreaks);
                    }

                    // Reload the loop variables for the next go-round
                    c = CharacterIteration.Current32(outerInstance.fText);
                    category = (short)outerInstance.fRData.fTrie.Get(c);
                }

                // If we found breaks, ensure that the first and last entries are
                // the original starting and ending position. And initialize the
                // cache iteration position to the first entry.

                // System.out.printf("foundBreakCount = %d%n", foundBreakCount);
                if (foundBreakCount > 0)
                {
                    Debug.Assert(foundBreakCount == fBreaks.Count);
                    if (startPos < fBreaks.ElementAt(0))
                    {
                        // The dictionary did not place a boundary at the start of the segment of text.
                        // Add one now. This should not commonly happen, but it would be easy for interactions
                        // of the rules for dictionary segments and the break engine implementations to
                        // inadvertently cause it. Cover it here, just in case.
                        fBreaks.Offer(startPos);
                    }
                    if (endPos > fBreaks.Peek())
                    {
                        fBreaks.Push(endPos);
                    }
                    fPositionInCache = 0;
                    // Note: Dictionary matching may extend beyond the original limit.
                    fStart = fBreaks.ElementAt(0);
                    fLimit = fBreaks.Peek();
                }
                else
                {
                    // there were no language-based breaks, even though the segment contained
                    // dictionary characters. Subsequent attempts to fetch boundaries from the dictionary cache
                    // for this range will fail, and the calling code will fall back to the rule based boundaries.
                }

            }


            internal DictionaryCache(RuleBasedBreakIterator outerInstance)
            {
                this.outerInstance = outerInstance;
                fPositionInCache = -1;
                fBreaks = new DictionaryBreakEngine.DequeI();
            }

            /// <summary>
            /// Copy constructor. Used by <see cref="RuleBasedBreakIterator.Clone()"/>.
            /// </summary>
            /// <param name="outerInstance">The <see cref="RuleBasedBreakIterator"/> that owns this instance.</param>
            /// <param name="src">The source object to be copied.</param>
            internal DictionaryCache(RuleBasedBreakIterator outerInstance, DictionaryCache src)
            {
                this.outerInstance = outerInstance;
                fBreaks = (DictionaryBreakEngine.DequeI)src.fBreaks.Clone();
                fPositionInCache = src.fPositionInCache;
                fStart = src.fStart;
                fLimit = src.fLimit;
                fFirstRuleStatusIndex = src.fFirstRuleStatusIndex;
                fOtherRuleStatusIndex = src.fOtherRuleStatusIndex;
                fBoundary = src.fBoundary;
                fStatusIndex = src.fStatusIndex;
            }

            // A data structure containing the boundaries themselves. Essentially a vector of raw ints.
            internal DictionaryBreakEngine.DequeI fBreaks;
            internal int fPositionInCache;       // Index in fBreaks of last boundary returned by following()
                                                 //                                      //    or preceding(). Optimizes sequential access.
            internal int fStart;                 // Text position of first boundary in cache.
            internal int fLimit;                 // Last boundary in cache. Which is the limit of the
                                                 //                                      //    text segment being handled by the dictionary.
            internal int fFirstRuleStatusIndex;  // Rule status info for first boundary.
            internal int fOtherRuleStatusIndex;  // Rule status info for 2nd through last boundaries.
            internal int fBoundary;              // Current boundary. Set by preceding(), following().
            internal int fStatusIndex;           // Current rule status index. Set by preceding, following().
        };

        /// <summary>
        /// Class BreakCache.
        /// </summary>
        /// <remarks>
        /// Cache of break boundary positions and rule status values.
        /// Break iterator API functions, <see cref="Next()"/>, <see cref="Previous()"/>, etc., will use cached results
        /// when possible, and otherwise cache new results as they are obtained.
        /// <para/>
        /// Uniformly caches both dictionary and rule based (non-dictionary) boundaries.
        /// <para/>
        /// The cache is implemented as a single circular buffer.
        /// </remarks>
        internal class BreakCache
        {
            private readonly RuleBasedBreakIterator outerInstance;

            internal BreakCache(RuleBasedBreakIterator outerInstance)
            {
                this.outerInstance = outerInstance;
                Reset();
            }

            internal void Reset(int pos, int ruleStatus)
            {
                fStartBufIdx = 0;
                fEndBufIdx = 0;
                fTextIdx = pos;
                fBufIdx = 0;
                fBoundaries[0] = pos;
                fStatuses[0] = (short)ruleStatus;
            }

            internal void Reset() { Reset(0, 0); }

            internal void Next()
            {
                if (fBufIdx == fEndBufIdx)
                {
                    outerInstance.fDone = !PopulateFollowing();
                    outerInstance.fPosition = fTextIdx;
                    outerInstance.fRuleStatusIndex = fStatuses[fBufIdx];
                }
                else
                {
                    fBufIdx = ModChunkSize(fBufIdx + 1);
                    fTextIdx = outerInstance.fPosition = fBoundaries[fBufIdx];
                    outerInstance.fRuleStatusIndex = fStatuses[fBufIdx];
                }
            }

            internal void Previous()
            {
                int initialBufIdx = fBufIdx;
                if (fBufIdx == fStartBufIdx)
                {
                    // At start of cache. Prepend to it.
                    PopulatePreceding();
                }
                else
                {
                    // Cache already holds the next boundary
                    fBufIdx = ModChunkSize(fBufIdx - 1);
                    fTextIdx = fBoundaries[fBufIdx];
                }
                outerInstance.fDone = (fBufIdx == initialBufIdx);
                outerInstance.fPosition = fTextIdx;
                outerInstance.fRuleStatusIndex = fStatuses[fBufIdx];
                return;
            }

            // Move the iteration state to the position following the startPosition.
            // Input position must be pinned to the input length.
            internal void Following(int startPos)
            {
                if (startPos == fTextIdx || Seek(startPos) || PopulateNear(startPos))
                {
                    // startPos is in the cache. Do a next() from that position.
                    // TODO: an awkward set of interactions with bi->fDone
                    //       seek() does not clear it; it can't because of interactions with populateNear().
                    //       next() does not clear it in the fast-path case, where everything matters. Maybe it should.
                    //       So clear it here, for the case where seek() succeeded on an iterator that had previously run off the end.
                    outerInstance.fDone = false;
                    Next();
                }

            }

            internal void Preceding(int startPos)
            {
                if (startPos == fTextIdx || Seek(startPos) || PopulateNear(startPos))
                {
                    if (startPos == fTextIdx)
                    {
                        Previous();
                    }
                    else
                    {
                        // seek() leaves the BreakCache positioned at the preceding boundary
                        //        if the requested position is between two bounaries.
                        // current() pushes the BreakCache position out to the BreakIterator itself.
                        Debug.Assert(startPos > fTextIdx);
                        Current();
                    }
                }
                return;
            }

            /// <summary>
            /// Update the state of the public <see cref="BreakIterator"/> (fBI) to reflect the
            /// current state of the break iterator cache (this).
            /// </summary>
            internal int Current()
            {
                outerInstance.fPosition = fTextIdx;
                outerInstance.fRuleStatusIndex = fStatuses[fBufIdx];
                outerInstance.fDone = false;
                return fTextIdx;
            }

            /// <summary>
            /// Add boundaries to the cache near the specified position.
            /// </summary>
            /// <remarks>
            /// The given <paramref name="position"/> need not be a boundary itself.
            /// The input <paramref name="position"/> must be within the range of the text, and
            /// on a code point boundary.
            /// If the requested <paramref name="position"/> is a break boundary, leave the iteration
            /// position on it.
            /// If the requested <paramref name="position"/> is not a boundary, leave the iteration
            /// position on the preceding boundary and include both the the
            /// preceding and following boundaries in the cache.
            /// Additional boundaries, either preceding or following, may be added
            /// to the cache as a side effect.
            /// </remarks>
            /// <returns>false if the operation failed.</returns>
            internal bool PopulateNear(int position)
            {
                Debug.Assert(position < fBoundaries[fStartBufIdx] || position > fBoundaries[fEndBufIdx]);

                // Find a boundary somewhere in the vicinity of the requested position.
                // Depending on the safe rules and the text data, it could be either before, at, or after
                // the requested position.


                // If the requested position is not near already cached positions, clear the existing cache,
                // find a near-by boundary and begin new cache contents there.

                if ((position < fBoundaries[fStartBufIdx] - 15) || position > (fBoundaries[fEndBufIdx] + 15))
                {
                    int aBoundary = outerInstance.fText.BeginIndex;
                    int ruleStatusIndex = 0;
                    // TODO: check for position == length of text. Although may still need to back up to get rule status.
                    if (position > aBoundary + 20)
                    {
                        int backupPos = outerInstance.HandlePrevious(position);
                        outerInstance.fPosition = backupPos;
                        aBoundary = outerInstance.HandleNext();                // Ignore dictionary, just finding a rule based boundary.
                        ruleStatusIndex = outerInstance.fRuleStatusIndex;
                    }
                    Reset(aBoundary, ruleStatusIndex);               // Reset cache to hold aBoundary as a single starting point.
                }

                // Fill in boundaries between existing cache content and the new requested position.

                if (fBoundaries[fEndBufIdx] < position)
                {
                    // The last position in the cache precedes the requested position.
                    // Add following position(s) to the cache.
                    while (fBoundaries[fEndBufIdx] < position)
                    {
                        if (!PopulateFollowing())
                        {
                            Debug.Assert(false);
                            return false;
                        }
                    }
                    fBufIdx = fEndBufIdx;                      // Set iterator position to the end of the buffer.
                    fTextIdx = fBoundaries[fBufIdx];           // Required because populateFollowing may add extra boundaries.
                    while (fTextIdx > position)
                    {              // Move backwards to a position at or preceding the requested pos.
                        Previous();
                    }
                    return true;
                }

                if (fBoundaries[fStartBufIdx] > position)
                {
                    // The first position in the cache is beyond the requested position.
                    // back up more until we get a boundary <= the requested position.
                    while (fBoundaries[fStartBufIdx] > position)
                    {
                        PopulatePreceding();
                    }
                    fBufIdx = fStartBufIdx;                    // Set iterator position to the start of the buffer.
                    fTextIdx = fBoundaries[fBufIdx];           // Required because populatePreceding may add extra boundaries.
                    while (fTextIdx < position)
                    {              // Move forwards to a position at or following the requested pos.
                        Next();
                    }
                    if (fTextIdx > position)
                    {
                        // If position is not itself a boundary, the next() loop above will overshoot.
                        // Back up one, leaving cache position at the boundary preceding the requested position.
                        Previous();
                    }
                    return true;
                }

                Debug.Assert(fTextIdx == position);
                return true;

            }

            /// <summary>
            /// Add boundary(s) to the cache following the current last boundary.
            /// Return false if at the end of the text, and no more boundaries can be added.
            /// Leave iteration position at the first newly added boundary, or unchanged if no boundary was added.
            /// </summary>
            internal bool PopulateFollowing()
            {
                int fromPosition = fBoundaries[fEndBufIdx];
                int fromRuleStatusIdx = fStatuses[fEndBufIdx];
                int pos = 0;
                int ruleStatusIdx = 0;

                if (outerInstance.fDictionaryCache.Following(fromPosition))
                {
                    AddFollowing(outerInstance.fDictionaryCache.fBoundary, outerInstance.fDictionaryCache.fStatusIndex, UpdateCachePosition);
                    return true;
                }

                outerInstance.fPosition = fromPosition;
                pos = outerInstance.HandleNext();
                if (pos == BreakIterator.Done)
                {
                    return false;
                }

                ruleStatusIdx = outerInstance.fRuleStatusIndex;
                if (outerInstance.fDictionaryCharCount > 0)
                {
                    // The text segment obtained from the rules includes dictionary characters.
                    // Subdivide it, with subdivided results going into the dictionary cache.
                    outerInstance.fDictionaryCache.PopulateDictionary(fromPosition, pos, fromRuleStatusIdx, ruleStatusIdx);
                    if (outerInstance.fDictionaryCache.Following(fromPosition))
                    {
                        AddFollowing(outerInstance.fDictionaryCache.fBoundary, outerInstance.fDictionaryCache.fStatusIndex, UpdateCachePosition);
                        return true;
                        // TODO: may want to move a sizable chunk of the dictionary cache to the break cache at this point.
                        //       But be careful with interactions with populateNear().
                    }
                }

                // Rule based segment did not include dictionary characters.
                // Or, it did contain dictionary chars, but the dictionary segmenter didn't handle them,
                //    meaning that we didn't take the return, above.
                // Add its end point to the cache.
                AddFollowing(pos, ruleStatusIdx, UpdateCachePosition);

                // Add several non-dictionary boundaries at this point, to optimize straight forward iteration.
                //    (subsequent calls to BreakIterator::next() will take the fast path, getting cached results.
                //
                for (int count = 0; count < 6; ++count)
                {
                    pos = outerInstance.HandleNext();
                    if (pos == BreakIterator.Done || outerInstance.fDictionaryCharCount > 0)
                    {
                        break;
                    }
                    AddFollowing(pos, outerInstance.fRuleStatusIndex, RetainCachePosition);
                }
                return true;
            }

            /// <summary>
            /// Add one or more boundaries to the cache preceding the first currently cached boundary.
            /// Leave the iteration position on the first added boundary.
            /// Return false if no boundaries could be added (if at the start of the text.)
            /// </summary>
            internal bool PopulatePreceding()
            {
                int textBegin = outerInstance.fText.BeginIndex;
                int fromPosition = fBoundaries[fStartBufIdx];
                if (fromPosition == textBegin)
                {
                    return false;
                }

                int position = textBegin;
                int positionStatusIdx = 0;

                if (outerInstance.fDictionaryCache.Preceding(fromPosition))
                {
                    AddPreceding(outerInstance.fDictionaryCache.fBoundary, outerInstance.fDictionaryCache.fStatusIndex, UpdateCachePosition);
                    return true;
                }

                int backupPosition = fromPosition;

                // Find a boundary somewhere preceding the first already-cached boundary
                do
                {
                    backupPosition = backupPosition - 30;
                    if (backupPosition <= textBegin)
                    {
                        backupPosition = textBegin;
                    }
                    else
                    {
                        backupPosition = outerInstance.HandlePrevious(backupPosition);
                    }
                    if (backupPosition == BreakIterator.Done || backupPosition == textBegin)
                    {
                        position = textBegin;
                        positionStatusIdx = 0;
                    }
                    else
                    {
                        outerInstance.fPosition = backupPosition;  // TODO: pass starting position in a clearer way.
                        position = outerInstance.HandleNext();
                        positionStatusIdx = outerInstance.fRuleStatusIndex;

                    }
                } while (position >= fromPosition);

                // Find boundaries between the one we just located and the first already-cached boundary
                // Put them in a side buffer, because we don't yet know where they will fall in the circular cache buffer..

                fSideBuffer.RemoveAllElements();
                fSideBuffer.Push(position);
                fSideBuffer.Push(positionStatusIdx);

                do
                {
                    int prevPosition = outerInstance.fPosition = position;
                    int prevStatusIdx = positionStatusIdx;
                    position = outerInstance.HandleNext();
                    positionStatusIdx = outerInstance.fRuleStatusIndex;
                    if (position == BreakIterator.Done)
                    {
                        break;
                    }

                    bool segmentHandledByDictionary = false;
                    if (outerInstance.fDictionaryCharCount != 0)
                    {
                        // Segment from the rules includes dictionary characters.
                        // Subdivide it, with subdivided results going into the dictionary cache.
                        int dictSegEndPosition = position;
                        outerInstance.fDictionaryCache.PopulateDictionary(prevPosition, dictSegEndPosition, prevStatusIdx, positionStatusIdx);
                        while (outerInstance.fDictionaryCache.Following(prevPosition))
                        {
                            position = outerInstance.fDictionaryCache.fBoundary;
                            positionStatusIdx = outerInstance.fDictionaryCache.fStatusIndex;
                            segmentHandledByDictionary = true;
                            Debug.Assert(position > prevPosition);
                            if (position >= fromPosition)
                            {
                                break;
                            }
                            Debug.Assert(position <= dictSegEndPosition);
                            fSideBuffer.Push(position);
                            fSideBuffer.Push(positionStatusIdx);
                            prevPosition = position;
                        }
                        Debug.Assert(position == dictSegEndPosition || position >= fromPosition);
                    }

                    if (!segmentHandledByDictionary && position < fromPosition)
                    {
                        fSideBuffer.Push(position);
                        fSideBuffer.Push(positionStatusIdx);
                    }
                } while (position < fromPosition);

                // Move boundaries from the side buffer to the main circular buffer.
                bool success = false;
                if (fSideBuffer.Count > 0)
                {
                    positionStatusIdx = fSideBuffer.Pop();
                    position = fSideBuffer.Pop();
                    AddPreceding(position, positionStatusIdx, UpdateCachePosition);
                    success = true;
                }

                while (fSideBuffer.Count > 0)
                {
                    positionStatusIdx = fSideBuffer.Pop();
                    position = fSideBuffer.Pop();
                    if (!AddPreceding(position, positionStatusIdx, RetainCachePosition))
                    {
                        // No space in circular buffer to hold a new preceding result while
                        // also retaining the current cache (iteration) position.
                        // Bailing out is safe; the cache will refill again if needed.
                        break;
                    }
                }
                return success;
            }


            internal static readonly bool RetainCachePosition = false;
            internal static readonly bool UpdateCachePosition = true;

            /// <summary>
            /// Add the boundary following the current position.
            /// The current position can be left as it was, or changed to the newly added boundary,
            /// as specified by the update parameter.
            /// </summary>
            internal void AddFollowing(int position, int ruleStatusIdx, bool update)
            {
                Debug.Assert(position > fBoundaries[fEndBufIdx]);
                Debug.Assert(ruleStatusIdx <= short.MaxValue);
                int nextIdx = ModChunkSize(fEndBufIdx + 1);
                if (nextIdx == fStartBufIdx)
                {
                    fStartBufIdx = ModChunkSize(fStartBufIdx + 6);    // TODO: experiment. Probably revert to 1.
                }
                fBoundaries[nextIdx] = position;
                fStatuses[nextIdx] = (short)ruleStatusIdx;
                fEndBufIdx = nextIdx;
                if (update == UpdateCachePosition)
                {
                    // Set current position to the newly added boundary.
                    fBufIdx = nextIdx;
                    fTextIdx = position;
                }
                else
                {
                    // Retaining the original cache position.
                    // Check if the added boundary wraps around the buffer, and would over-write the original position.
                    // It's the responsibility of callers of this function to not add too many.
                    Debug.Assert(nextIdx != fBufIdx);
                }

            }

            /// <summary>
            /// Add the boundary preceding the current position.
            /// The current position can be left as it was, or changed to the newly added boundary,
            /// as specified by the update parameter.
            /// </summary>
            internal bool AddPreceding(int position, int ruleStatusIdx, bool update)
            {
                Debug.Assert(position < fBoundaries[fStartBufIdx]);
                Debug.Assert(ruleStatusIdx <= short.MaxValue);
                int nextIdx = ModChunkSize(fStartBufIdx - 1);
                if (nextIdx == fEndBufIdx)
                {
                    if (fBufIdx == fEndBufIdx && update == RetainCachePosition)
                    {
                        // Failure. The insertion of the new boundary would claim the buffer position that is the
                        // current iteration position. And we also want to retain the current iteration position.
                        // (The buffer is already completely full of entries that precede the iteration position.)
                        return false;
                    }
                    fEndBufIdx = ModChunkSize(fEndBufIdx - 1);
                }
                fBoundaries[nextIdx] = position;
                fStatuses[nextIdx] = (short)ruleStatusIdx;
                fStartBufIdx = nextIdx;
                if (update == UpdateCachePosition)
                {
                    fBufIdx = nextIdx;
                    fTextIdx = position;
                }
                return true;
            }

            /// <summary>
            /// Set the cache position to the specified position, or, if the position
            /// falls between to cached boundaries, to the preceding boundary.
            /// Fails if the requested position is outside of the range of boundaries currently held by the cache.
            /// The <paramref name="pos"/> must be on a code point boundary.
            /// </summary>
            /// <returns>true if successful, false if the specified position is after
            /// the last cached boundary or before the first.</returns>
            internal bool Seek(int pos)
            {
                if (pos < fBoundaries[fStartBufIdx] || pos > fBoundaries[fEndBufIdx])
                {
                    return false;
                }
                if (pos == fBoundaries[fStartBufIdx])
                {
                    // Common case: seek(0), from BreakIterator::first()
                    fBufIdx = fStartBufIdx;
                    fTextIdx = fBoundaries[fBufIdx];
                    return true;
                }
                if (pos == fBoundaries[fEndBufIdx])
                {
                    fBufIdx = fEndBufIdx;
                    fTextIdx = fBoundaries[fBufIdx];
                    return true;
                }

                int min = fStartBufIdx;
                int max = fEndBufIdx;
                while (min != max)
                {
                    int probe = (min + max + (min > max ? CACHE_SIZE : 0)) / 2;
                    probe = ModChunkSize(probe);
                    if (fBoundaries[probe] > pos)
                    {
                        max = probe;
                    }
                    else
                    {
                        min = ModChunkSize(probe + 1);
                    }
                }
                Debug.Assert(fBoundaries[max] > pos);
                fBufIdx = ModChunkSize(max - 1);
                fTextIdx = fBoundaries[fBufIdx];
                Debug.Assert(fTextIdx <= pos);
                return true;

            }

            /// <summary>
            /// Copy constructor, used from <see cref="RuleBasedBreakIterator.Clone()"/>.
            /// </summary>
            /// <param name="outerInstance">The <see cref="RuleBasedBreakIterator"/> that owns this instance.</param>
            /// <param name="src"></param>
            internal BreakCache(RuleBasedBreakIterator outerInstance, BreakCache src)
            {
                this.outerInstance = outerInstance;
                fStartBufIdx = src.fStartBufIdx;
                fEndBufIdx = src.fEndBufIdx;
                fTextIdx = src.fTextIdx;
                fBufIdx = src.fBufIdx;
                fBoundaries = (int[])src.fBoundaries.Clone();
                fStatuses = (short[])src.fStatuses.Clone();
                fSideBuffer = new DictionaryBreakEngine.DequeI();  // Transient, no need to clone contents.
            }

            internal void DumpCache()
            {
                Console.Out.Write("fTextIdx:%d   fBufIdx:%d%n", fTextIdx, fBufIdx); // ICU4N TODO: String format
                for (int i = fStartBufIdx; ; i = ModChunkSize(i + 1))
                {
                    Console.Out.Write("%d  %d%n", i, fBoundaries[i]); // ICU4N TODO: String format
                    if (i == fEndBufIdx)
                    {
                        break;
                    }
                }
            }

            private int ModChunkSize(int index) { return index & (CACHE_SIZE - 1); }

            internal static readonly int CACHE_SIZE = 128;
            // static_assert((CACHE_SIZE & (CACHE_SIZE-1)) == 0, "CACHE_SIZE must be power of two.");

            internal int fStartBufIdx;
            internal int fEndBufIdx;    // inclusive

            internal int fTextIdx;
            internal int fBufIdx;

            internal int[] fBoundaries = new int[CACHE_SIZE];
            internal short[] fStatuses = new short[CACHE_SIZE];

            DictionaryBreakEngine.DequeI fSideBuffer = new DictionaryBreakEngine.DequeI();
        }
    }
}
