<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
	// Load common settings from the XML file
	string settingsPath = System.IO.Path.Combine(Host.ResolveAssemblyReference("$(SolutionDir)"), "src/CodeGenerationSettings.xml");
	XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
	string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
	string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Support.Text;
using System;
using System.Text;
using static ICU4N.Text.UnicodeSet;

namespace ICU4N.Text
{
    public partial class UnicodeSetSpanner
    {
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, 
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual int CountIn(<#=charSequence#> sequence)
        {
            return CountIn(sequence, CountMethod.MinElements, SpanCondition.Simple);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Returns the number of matching characters found in a character sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">The sequence to count characters in.</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual int CountIn(<#=charSequence#> sequence, CountMethod countMethod)
        {
            return CountIn(sequence, countMethod, SpanCondition.Simple);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Returns the number of matching characters found in a character sequence.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// The sequence to count characters in.
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">the spanCondition to use. <see cref="SpanCondition.Simple"/> or <see cref="SpanCondition.Contained"/> 
        /// means only count the elements in the span; <see cref="SpanCondition.NotContained"/> is the reverse.
        /// <para/>
        /// <b>WARNING: </b> when a <see cref="Text.UnicodeSet"/> contains strings, there may be unexpected behavior in edge cases.
        /// </param>
        /// <returns>The count. Zero if there are none.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual int CountIn(<#=charSequence#> sequence, CountMethod countMethod, SpanCondition spanCondition)
        {
            int count = 0;
            int start = 0;
            SpanCondition skipSpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            int length = sequence.Length;
            int spanCount = 0;
            while (start != length)
            {
                int endOfSpan = unicodeSet.Span(sequence, start, skipSpan);
                if (endOfSpan == length)
                {
                    break;
                }
                if (countMethod == CountMethod.WholeSpan)
                {
                    start = unicodeSet.Span(sequence, endOfSpan, spanCondition);
                    count += 1;
                }
                else
                {
#pragma warning disable 612, 618
                    start = unicodeSet.SpanAndCount(sequence, endOfSpan, spanCondition, out spanCount);
#pragma warning restore 612, 618
                    count += spanCount;
                }
            }
            return count;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Delete all the matching spans in sequence, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual string DeleteFrom(<#=charSequence#> sequence)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, SpanCondition.Simple);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Delete all matching spans in sequence, according to the spanCondition.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// 
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="spanCondition">Specify whether to modify the matching spans 
        /// (<see cref="SpanCondition.Contained"/> or <see cref="SpanCondition.Simple"/>) 
        /// or the non-matching (<see cref="SpanCondition.NotContained"/>).</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual string DeleteFrom(<#=charSequence#> sequence, SpanCondition spanCondition)
        {
            return ReplaceFrom(sequence, "", CountMethod.WholeSpan, spanCondition);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>
	<# foreach (var charSequence2 in charSequences) { #>

        /// <summary>
        /// Replace all matching spans in sequence by the replacement,
        /// counting by <see cref="CountMethod.MinElements"/> using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual string ReplaceFrom(<#=charSequence#> sequence, <#=charSequence2#> replacement)
        {
            return ReplaceFrom(sequence, replacement, CountMethod.MinElements, SpanCondition.Simple);
        }
	<# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>
	<# foreach (var charSequence2 in charSequences) { #>

        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <see cref="CountMethod"/>, using <see cref="SpanCondition.Simple"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual string ReplaceFrom(<#=charSequence#> sequence, <#=charSequence2#> replacement, CountMethod countMethod)
        {
            return ReplaceFrom(sequence, replacement, countMethod, SpanCondition.Simple);
        }
	<# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>
	<# foreach (var charSequence2 in charSequences) { #>

        /// <summary>
        /// Replace all matching spans in sequence by replacement, according to the <paramref name="countMethod"/> and <paramref name="spanCondition"/>.
        /// The code alternates spans; see the class doc for <see cref="UnicodeSetSpanner"/> for a note about boundary conditions.
        /// </summary>
        /// <param name="sequence">Character sequence to replace matching spans in.</param>
        /// <param name="replacement">Replacement sequence. To delete, use "".</param>
        /// <param name="countMethod">Whether to treat an entire span as a match, or individual elements as matches.</param>
        /// <param name="spanCondition">specify whether to modify the matching spans (<see cref="SpanCondition.Contained"/> 
        /// or <see cref="SpanCondition.Simple"/>) or the non-matching (<see cref="SpanCondition.NotContained"/>)</param>
        /// <returns>Modified string.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> virtual string ReplaceFrom(<#=charSequence#> sequence, <#=charSequence2#> replacement, CountMethod countMethod,
            SpanCondition spanCondition)
        {
            SpanCondition copySpan = spanCondition == SpanCondition.NotContained ? SpanCondition.Simple
                    : SpanCondition.NotContained;
            bool remove = replacement.Length == 0;
            StringBuilder result = new StringBuilder();
            // TODO, we can optimize this to
            // avoid this allocation unless needed

            int length = sequence.Length;
            int spanCount = 0;
            for (int endCopy = 0; endCopy != length;)
            {
                int endModify;
                if (countMethod == CountMethod.WholeSpan)
                {
                    endModify = unicodeSet.Span(sequence, endCopy, spanCondition);
                }
                else
                {
#pragma warning disable 612, 618
                    endModify = unicodeSet.SpanAndCount(sequence, endCopy, spanCondition, out spanCount);
#pragma warning restore 612, 618
                }
                if (remove || endModify == 0)
                {
                    // do nothing
                }
                else if (countMethod == CountMethod.WholeSpan)
                {
                    result.Append(replacement);
                }
                else
                {
                    for (int i = spanCount; i > 0; --i)
                    {
                        result.Append(replacement);
                    }
                }
                if (endModify == length)
                {
                    break;
                }
                endCopy = unicodeSet.Span(sequence, endModify, copySpan);
                result.Append(sequence.SubSequence(endModify, endCopy));
            }
            return result.ToString();
        }
	<# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start and
        /// end of the string, using <see cref="TrimOption.Both"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab")
        /// </code>
        /// ... returns <c>"cat"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequenceAccessibility#> virtual ICharSequence Trim(<#=charSequence#> sequence) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, TrimOption.Both, SpanCondition.Simple);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, using the <paramref name="trimOption"/> and <see cref="SpanCondition.Simple"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequenceAccessibility#> virtual ICharSequence Trim(<#=charSequence#> sequence, TrimOption trimOption) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            return Trim(sequence, trimOption, SpanCondition.Simple);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Returns a trimmed sequence (using <see cref="ICharSequence.SubSequence(int, int)"/>), that omits matching elements at the start or
        /// end of the string, depending on the <paramref name="trimOption"/> and <paramref name="spanCondition"/>. For example:
        /// <code>
        ///     new UnicodeSet("[ab]").Trim("abacatbab", TrimOption.Leading, SpanCondition.Simple)
        /// </code>
        /// ... returns <c>"catbab"</c>.
        /// </summary>
        /// <param name="sequence">The sequence to trim.</param>
        /// <param name="trimOption"><see cref="TrimOption.Leading"/>, <see cref="TrimOption.Trailing"/>, 
        /// or <see cref="TrimOption.Both"/>.</param>
        /// <param name="spanCondition"><see cref="SpanCondition.Simple"/>, <see cref="SpanCondition.Contained"/> or 
        /// <see cref="SpanCondition.NotContained"/>.</param>
        /// <returns>A subsequence.</returns>
        /// <stable>ICU 54</stable>
        <#=charSequenceAccessibility#> virtual ICharSequence Trim(<#=charSequence#> sequence, TrimOption trimOption, SpanCondition spanCondition) // ICU4N TODO: API - return string? or return the same datatype that is passed?
        {
            int endLeadContained, startTrailContained;
            int length = sequence.Length;
            if (trimOption != TrimOption.Trailing)
            {
                endLeadContained = unicodeSet.Span(sequence, spanCondition);
                if (endLeadContained == length)
                {
                    return "".ToCharSequence();
                }
            }
            else
            {
                endLeadContained = 0;
            }
            if (trimOption != TrimOption.Leading)
            {
                startTrailContained = unicodeSet.SpanBack(sequence, spanCondition);
            }
            else
            {
                startTrailContained = length;
            }
            return endLeadContained == 0 && startTrailContained == length ? sequence.ToCharSequence() : sequence.SubSequence(
                    endLeadContained, startTrailContained);
        }
<# } #>

	}
}