<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Globalization
{
    internal partial class CharSequences
    {
<# foreach (var charSequence in charSequences) { #>
    <# foreach (var charSequence2 in charSequences) { #>

        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> static int MatchAfter(<#=charSequence#> a, <#=charSequence2#> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> int CodePointLength(<#=charSequence#> s)
        {
            return Character.CodePointCount(s, 0, s.Length);
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool Equals(int codepoint, <#=charSequence#> other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool Equals(<#=charSequence#> other, int codepoint)
        {
            return Equals(codepoint, other);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int Compare(<#=charSequence#> str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int Compare(int codepoint, <#=charSequence#> a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int GetSingleCodePoint(<#=charSequence#> s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>
    <# foreach (var charSequence2 in charSequences) { #>

        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> static int Compare(<#=charSequence#> a, <#=charSequence2#> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>
    <# foreach (var charSequence2 in charSequences) { #>

        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool EqualsChars(<#=charSequence#> a, <#=charSequence2#> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }
    <# } #>
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool OnCharacterBoundary(<#=charSequence#> s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int IndexOf(<#=charSequence#> s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        /// <summary>
        /// Utility function for simplified, more robust loops, such as:
        /// <code>
        ///     foreach (int codePoint in CharSequences.CodePoints(string)) 
        ///     {
        ///         DoSomethingWith(codePoint);
        ///     }
        /// </code>
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int[] CodePoints(<#=charSequence#> s)
        {
            int[] result = new int[s.Length]; // in the vast majority of cases, the length is the same
            int j = 0;
            for (int i = 0; i < s.Length; ++i)
            {
                char cp = s[i];
                if (cp >= 0xDC00 && cp <= 0xDFFF && i != 0)
                { // hand-code for speed
                    char last = (char)result[j - 1];
                    if (last >= 0xD800 && last <= 0xDBFF)
                    {
                        // Note: j-1 is safe, because j can only be zero if i is zero. But i!=0 in this block.
                        result[j - 1] = Character.ToCodePoint(last, cp);
                        continue;
                    }
                }
                result[j++] = cp;
            }
            if (j == result.Length)
            {
                return result;
            }
            int[] shortResult = new int[j];
            System.Array.Copy(result, 0, shortResult, 0, j);
            return shortResult;
        }
<# } #>

    }
}