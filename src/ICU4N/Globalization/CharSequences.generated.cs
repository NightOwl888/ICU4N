//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Globalization
{
    internal partial class CharSequences
    {
    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(string a, string b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(string a, StringBuilder b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(string a, char[] b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(string a, ICharSequence b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(string a, ReadOnlySpan<char> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

        
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(StringBuilder a, string b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(StringBuilder a, StringBuilder b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(StringBuilder a, char[] b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(StringBuilder a, ICharSequence b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(StringBuilder a, ReadOnlySpan<char> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

        
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(char[] a, string b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(char[] a, StringBuilder b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(char[] a, char[] b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(char[] a, ICharSequence b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(char[] a, ReadOnlySpan<char> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

        
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ICharSequence a, string b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ICharSequence a, StringBuilder b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ICharSequence a, char[] b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ICharSequence a, ICharSequence b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ICharSequence a, ReadOnlySpan<char> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

        
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ReadOnlySpan<char> a, string b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ReadOnlySpan<char> a, StringBuilder b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ReadOnlySpan<char> a, char[] b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ReadOnlySpan<char> a, ICharSequence b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int MatchAfter(ReadOnlySpan<char> a, ReadOnlySpan<char> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }

    
        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public int CodePointLength(string s)
        {
            return Character.CodePointCount(s, 0, s.Length);
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }


        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public int CodePointLength(StringBuilder s)
        {
            return Character.CodePointCount(s, 0, s.Length);
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }


        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public int CodePointLength(char[] s)
        {
            return Character.CodePointCount(s, 0, s.Length);
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }


        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public int CodePointLength(ICharSequence s)
        {
            return Character.CodePointCount(s, 0, s.Length);
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }


        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public int CodePointLength(ReadOnlySpan<char> s)
        {
            return Character.CodePointCount(s);
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }

        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(int codepoint, string other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }

        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(int codepoint, StringBuilder other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }

        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(int codepoint, char[] other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }

        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(int codepoint, ICharSequence other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }

        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(int codepoint, ReadOnlySpan<char> other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }

        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(string other, int codepoint)
        {
            return Equals(codepoint, other);
        }

        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(StringBuilder other, int codepoint)
        {
            return Equals(codepoint, other);
        }

        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(char[] other, int codepoint)
        {
            return Equals(codepoint, other);
        }

        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(ICharSequence other, int codepoint)
        {
            return Equals(codepoint, other);
        }

        [Obsolete("This API is ICU internal only.")]
        public static bool Equals(ReadOnlySpan<char> other, int codepoint)
        {
            return Equals(codepoint, other);
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(string str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(StringBuilder str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(char[] str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ICharSequence str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ReadOnlySpan<char> str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(int codepoint, string a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(int codepoint, StringBuilder a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(int codepoint, char[] a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(int codepoint, ICharSequence a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }

        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(int codepoint, ReadOnlySpan<char> a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(string s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(StringBuilder s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(char[] s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(ICharSequence s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }

        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int GetSingleCodePoint(ReadOnlySpan<char> s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(string a, string b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(string a, StringBuilder b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(string a, char[] b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(string a, ICharSequence b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(string a, ReadOnlySpan<char> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

        
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(StringBuilder a, string b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(StringBuilder a, StringBuilder b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(StringBuilder a, char[] b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(StringBuilder a, ICharSequence b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(StringBuilder a, ReadOnlySpan<char> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

        
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(char[] a, string b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(char[] a, StringBuilder b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(char[] a, char[] b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(char[] a, ICharSequence b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(char[] a, ReadOnlySpan<char> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

        
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ICharSequence a, string b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ICharSequence a, StringBuilder b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ICharSequence a, char[] b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ICharSequence a, ICharSequence b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ICharSequence a, ReadOnlySpan<char> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

        
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ReadOnlySpan<char> a, string b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ReadOnlySpan<char> a, StringBuilder b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ReadOnlySpan<char> a, char[] b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ReadOnlySpan<char> a, ICharSequence b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

    
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int Compare(ReadOnlySpan<char> a, ReadOnlySpan<char> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }

                /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(string a, string b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(string a, StringBuilder b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(string a, char[] b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(string a, ICharSequence b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(string a, ReadOnlySpan<char> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

                /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(StringBuilder a, string b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(StringBuilder a, StringBuilder b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(StringBuilder a, char[] b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(StringBuilder a, ICharSequence b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(StringBuilder a, ReadOnlySpan<char> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

                /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(char[] a, string b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(char[] a, StringBuilder b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(char[] a, char[] b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(char[] a, ICharSequence b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(char[] a, ReadOnlySpan<char> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

                /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ICharSequence a, string b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ICharSequence a, StringBuilder b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ICharSequence a, char[] b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ICharSequence a, ICharSequence b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ICharSequence a, ReadOnlySpan<char> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

                /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ReadOnlySpan<char> a, string b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ReadOnlySpan<char> a, StringBuilder b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ReadOnlySpan<char> a, char[] b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ReadOnlySpan<char> a, ICharSequence b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool EqualsChars(ReadOnlySpan<char> a, ReadOnlySpan<char> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }

            /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool OnCharacterBoundary(string s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }

        /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool OnCharacterBoundary(StringBuilder s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }

        /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool OnCharacterBoundary(char[] s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }

        /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool OnCharacterBoundary(ICharSequence s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }

        /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static bool OnCharacterBoundary(ReadOnlySpan<char> s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }

        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int IndexOf(string s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int IndexOf(StringBuilder s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int IndexOf(char[] s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int IndexOf(ICharSequence s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int IndexOf(ReadOnlySpan<char> s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }

        /// <summary>
        /// Utility function for simplified, more robust loops, such as:
        /// <code>
        ///     foreach (int codePoint in CharSequences.CodePoints(string)) 
        ///     {
        ///         DoSomethingWith(codePoint);
        ///     }
        /// </code>
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int[] CodePoints(string s)
        {
            int[] result = new int[s.Length]; // in the vast majority of cases, the length is the same
            int j = 0;
            for (int i = 0; i < s.Length; ++i)
            {
                char cp = s[i];
                if (cp >= 0xDC00 && cp <= 0xDFFF && i != 0)
                { // hand-code for speed
                    char last = (char)result[j - 1];
                    if (last >= 0xD800 && last <= 0xDBFF)
                    {
                        // Note: j-1 is safe, because j can only be zero if i is zero. But i!=0 in this block.
                        result[j - 1] = Character.ToCodePoint(last, cp);
                        continue;
                    }
                }
                result[j++] = cp;
            }
            if (j == result.Length)
            {
                return result;
            }
            int[] shortResult = new int[j];
            System.Array.Copy(result, 0, shortResult, 0, j);
            return shortResult;
        }

        /// <summary>
        /// Utility function for simplified, more robust loops, such as:
        /// <code>
        ///     foreach (int codePoint in CharSequences.CodePoints(string)) 
        ///     {
        ///         DoSomethingWith(codePoint);
        ///     }
        /// </code>
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int[] CodePoints(StringBuilder s)
        {
            int[] result = new int[s.Length]; // in the vast majority of cases, the length is the same
            int j = 0;
            for (int i = 0; i < s.Length; ++i)
            {
                char cp = s[i];
                if (cp >= 0xDC00 && cp <= 0xDFFF && i != 0)
                { // hand-code for speed
                    char last = (char)result[j - 1];
                    if (last >= 0xD800 && last <= 0xDBFF)
                    {
                        // Note: j-1 is safe, because j can only be zero if i is zero. But i!=0 in this block.
                        result[j - 1] = Character.ToCodePoint(last, cp);
                        continue;
                    }
                }
                result[j++] = cp;
            }
            if (j == result.Length)
            {
                return result;
            }
            int[] shortResult = new int[j];
            System.Array.Copy(result, 0, shortResult, 0, j);
            return shortResult;
        }

        /// <summary>
        /// Utility function for simplified, more robust loops, such as:
        /// <code>
        ///     foreach (int codePoint in CharSequences.CodePoints(string)) 
        ///     {
        ///         DoSomethingWith(codePoint);
        ///     }
        /// </code>
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int[] CodePoints(char[] s)
        {
            int[] result = new int[s.Length]; // in the vast majority of cases, the length is the same
            int j = 0;
            for (int i = 0; i < s.Length; ++i)
            {
                char cp = s[i];
                if (cp >= 0xDC00 && cp <= 0xDFFF && i != 0)
                { // hand-code for speed
                    char last = (char)result[j - 1];
                    if (last >= 0xD800 && last <= 0xDBFF)
                    {
                        // Note: j-1 is safe, because j can only be zero if i is zero. But i!=0 in this block.
                        result[j - 1] = Character.ToCodePoint(last, cp);
                        continue;
                    }
                }
                result[j++] = cp;
            }
            if (j == result.Length)
            {
                return result;
            }
            int[] shortResult = new int[j];
            System.Array.Copy(result, 0, shortResult, 0, j);
            return shortResult;
        }

        /// <summary>
        /// Utility function for simplified, more robust loops, such as:
        /// <code>
        ///     foreach (int codePoint in CharSequences.CodePoints(string)) 
        ///     {
        ///         DoSomethingWith(codePoint);
        ///     }
        /// </code>
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int[] CodePoints(ICharSequence s)
        {
            int[] result = new int[s.Length]; // in the vast majority of cases, the length is the same
            int j = 0;
            for (int i = 0; i < s.Length; ++i)
            {
                char cp = s[i];
                if (cp >= 0xDC00 && cp <= 0xDFFF && i != 0)
                { // hand-code for speed
                    char last = (char)result[j - 1];
                    if (last >= 0xD800 && last <= 0xDBFF)
                    {
                        // Note: j-1 is safe, because j can only be zero if i is zero. But i!=0 in this block.
                        result[j - 1] = Character.ToCodePoint(last, cp);
                        continue;
                    }
                }
                result[j++] = cp;
            }
            if (j == result.Length)
            {
                return result;
            }
            int[] shortResult = new int[j];
            System.Array.Copy(result, 0, shortResult, 0, j);
            return shortResult;
        }

        /// <summary>
        /// Utility function for simplified, more robust loops, such as:
        /// <code>
        ///     foreach (int codePoint in CharSequences.CodePoints(string)) 
        ///     {
        ///         DoSomethingWith(codePoint);
        ///     }
        /// </code>
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        public static int[] CodePoints(ReadOnlySpan<char> s)
        {
            int[] result = new int[s.Length]; // in the vast majority of cases, the length is the same
            int j = 0;
            for (int i = 0; i < s.Length; ++i)
            {
                char cp = s[i];
                if (cp >= 0xDC00 && cp <= 0xDFFF && i != 0)
                { // hand-code for speed
                    char last = (char)result[j - 1];
                    if (last >= 0xD800 && last <= 0xDBFF)
                    {
                        // Note: j-1 is safe, because j can only be zero if i is zero. But i!=0 in this block.
                        result[j - 1] = Character.ToCodePoint(last, cp);
                        continue;
                    }
                }
                result[j++] = cp;
            }
            if (j == result.Length)
            {
                return result;
            }
            int[] shortResult = new int[j];
            System.Array.Copy(result, 0, shortResult, 0, j);
            return shortResult;
        }


    }
}