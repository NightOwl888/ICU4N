<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    XElement[] charSequenceElements = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Where(x => x.Value != "ValueStringBuilder").Select(x => x.Value).ToArray();

    string[] charSequences = new string[charSequenceElements.Length];
    string[] charSequenceForDocs = new string[charSequenceElements.Length];
    string[] charSequenceFeatures = new string[charSequenceElements.Length];

    for (int i = 0; i < charSequenceElements.Length; i++) {
        XElement charSequenceElement = charSequenceElements[i];
        charSequences[i] = charSequenceElement.Value;
        charSequenceForDocs[i] = charSequenceElement.Value.Replace("<", "{").Replace(">", "}");

        XAttribute[] featureAttributes = charSequenceElement.Attributes("feature").ToArray();
        charSequenceFeatures[i] = featureAttributes == null ? "" : (featureAttributes.Length > 0 ? featureAttributes[0].Value : "");
    }
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N;
using J2N.Numerics;
using J2N.Text;
using System;
using System.Text;

namespace ICU4N.Globalization
{
    internal static partial class CharSequences
    {
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string feature = charSequenceFeatures[i]; #>
    <# for (int j = 0; j < charSequences.Length; j++) {
        string charSequence2 = charSequences[j];
        if (!string.IsNullOrEmpty(charSequenceFeatures[j])) {
            feature = string.IsNullOrEmpty(feature) || StringComparer.InvariantCulture.Equals(feature, charSequenceFeatures[j]) ? charSequenceFeatures[j] : feature + " || " + charSequenceFeatures[j];
        } #>
<#= !string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine : "" #>
        /// <summary>
        /// Find the longest n such that a[aIndex,n] = b[bIndex,n], and n is on a character boundary.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> static int MatchAfter(<#=charSequence#> a, <#=charSequence2#> b, int aIndex, int bIndex)
        {
            int i = aIndex, j = bIndex;
            int alen = a.Length;
            int blen = b.Length;
            for (; i < alen && j < blen; ++i, ++j)
            {
                char ca = a[i];
                char cb = b[j];
                if (ca != cb)
                {
                    break;
                }
            }
            // if we failed a match make sure that we didn't match half a character
            int result = i - aIndex;
            if (result != 0 && !OnCharacterBoundary(a, i) && !OnCharacterBoundary(b, j))
            {
                --result; // backup
            }
            return result;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
    <# } #>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        /// <summary>
        /// Count the code point length. Unpaired surrogates count as 1.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int CodePointLength(<#=charSequence#> s)
        {
<#  if (charSequence == "ReadOnlySpan<char>") { #>
            return Character.CodePointCount(s);
<# } else { #>
            return Character.CodePointCount(s, 0, s.Length);
<# } #>
            //        int length = s.length();
            //        int result = length;
            //        for (int i = 1; i < length; ++i) {
            //            char ch = s.charAt(i);
            //            if (0xDC00 <= ch && ch <= 0xDFFF) {
            //                char ch0 = s.charAt(i-1);
            //                if (0xD800 <= ch && ch <= 0xDbFF) {
            //                    --result;
            //                }
            //            }
            //        }
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Utility function for comparing codepoint to string without generating new
        /// string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool Equals(int codepoint, <#=charSequence#> other)
        {
            if (other == null)
            {
                return false;
            }
            switch (other.Length)
            {
                case 1: return codepoint == other[0];
                case 2: return codepoint > 0xFFFF && codepoint == Character.CodePointAt(other, 0);
                default: return false;
            }
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool Equals(<#=charSequence#> other, int codepoint)
        {
            return Equals(codepoint, other);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string (with the [ugly] new StringBuilder().AppendCodePoint(codepoint).ToString())
        /// and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int Compare(<#=charSequence#> str, int codePoint)
        {
            if (codePoint < Character.MinCodePoint || codePoint > Character.MaxCodePoint)
            {
                throw new ArgumentException();
            }
            int stringLength = str.Length;
            if (stringLength == 0)
            {
                return -1;
            }
            char firstChar = str[0];
            int offset = codePoint - Character.MinSupplementaryCodePoint;

            if (offset < 0)
            { // BMP codePoint
                int result2 = firstChar - codePoint;
                if (result2 != 0)
                {
                    return result2;
                }
                return stringLength - 1;
            }
            // non BMP
            char lead = (char)((offset.TripleShift(10)) + Character.MinHighSurrogate);
            int result = firstChar - lead;
            if (result != 0)
            {
                return result;
            }
            if (stringLength > 1)
            {
                char trail = (char)((offset & 0x3ff) + Character.MinLowSurrogate);
                result = str[1] - trail;
                if (result != 0)
                {
                    return result;
                }
            }
            return stringLength - 2;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Utility to compare a string to a code point.
        /// Same results as turning the code point into a string and comparing, but much faster (no object creation).
        /// Actually, there is one difference; a null compares as less.
        /// Note that this (=String) order is UTF-16 order -- *not* code point order.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int Compare(int codepoint, <#=charSequence#> a)
        {
            int result = Compare(a, codepoint);
            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Return the value of the first code point, if the string is exactly one code point. Otherwise return <see cref="int.MaxValue"/>.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int GetSingleCodePoint(<#=charSequence#> s)
        {
            int length = s.Length;
            if (length < 1 || length > 2)
            {
                return int.MaxValue;
            }
            int result = Character.CodePointAt(s, 0);
            return (result < 0x10000) == (length == 1) ? result : int.MaxValue;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string feature = charSequenceFeatures[i]; #>
    <# for (int j = 0; j < charSequences.Length; j++) {
        string charSequence2 = charSequences[j];
        if (!string.IsNullOrEmpty(charSequenceFeatures[j])) {
            feature = string.IsNullOrEmpty(feature) || StringComparer.InvariantCulture.Equals(feature, charSequenceFeatures[j]) ? charSequenceFeatures[j] : feature + " || " + charSequenceFeatures[j];
        } #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>
        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> static int Compare(<#=charSequence#> a, <#=charSequence2#> b)
        {
            int alength = a.Length;
            int blength = b.Length;
            int min = alength <= blength ? alength : blength;
            for (int i = 0; i < min; ++i)
            {
                int diff = a[i] - b[i];
                if (diff != 0)
                {
                    return diff;
                }
            }
            return alength - blength;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
    <# } #>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string feature = charSequenceFeatures[i]; #>
    <# for (int j = 0; j < charSequences.Length; j++) {
        string charSequence2 = charSequences[j];
        if (!string.IsNullOrEmpty(charSequenceFeatures[j])) {
            feature = string.IsNullOrEmpty(feature) || StringComparer.InvariantCulture.Equals(feature, charSequenceFeatures[j]) ? charSequenceFeatures[j] : feature + " || " + charSequenceFeatures[j];
        } #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Utility for comparing the contents of character sequences.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" || charSequence2=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool EqualsChars(<#=charSequence#> a, <#=charSequence2#> b)
        {
            // do length test first for fast path
            return a.Length == b.Length && Compare(a, b) == 0;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
    <# } #>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Are we on a character boundary?
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static bool OnCharacterBoundary(<#=charSequence#> s, int i)
        {
            return i <= 0
            || i >= s.Length
            || !char.IsHighSurrogate(s[i - 1])
            || !char.IsLowSurrogate(s[i]);
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>
<# for (int i = 0; i < charSequences.Length; i++) {
    string charSequence = charSequences[i];
    string charSequenceForDoc = charSequenceForDocs[i];
    string feature = charSequenceFeatures[i]; #>
<#=!string.IsNullOrEmpty(feature) ? "#if " + feature + Environment.NewLine: ""#>        /// <summary>
        /// Find code point in string.
        /// </summary>
        [Obsolete("This API is ICU internal only.")]
        <#= charSequence=="ICharSequence" ? charSequenceAccessibility : "public"#> static int IndexOf(<#=charSequence#> s, int codePoint)
        {
            int cp;
            for (int i = 0; i < s.Length; i += Character.CharCount(cp))
            {
                cp = Character.CodePointAt(s, i);
                if (cp == codePoint)
                {
                    return i;
                }
            }
            return -1;
        }
<#=!string.IsNullOrEmpty(feature) ? "#endif " + Environment.NewLine: ""#>
<# } #>

    }
}