<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#+
public class CharSequence : IAccessibility, IFeature
{
    public string Name { get; set; }
    public string NameForDocAsType { get; set; }
    public string NameForDocAsLink { get; set; }
    public string Accessibility { get; set; }
    public string Feature { get; set; }
    public string Modifier { get; set; }
    public bool IsNullable { get; set; }
    public string Nullable => IsNullable ? "?" : "";
    public string SliceMethod { get; set; }
    public string LegacySliceMethod { get; set; }
    public string FromStringFormat { get; set; } // For testing only
    public string ToStringFormat { get; set; }
    public string NameForTest { get; set; }

    public override bool Equals(object obj)
    {
        if (obj is string str)
            return str.Equals(obj);
        if (obj is CharSequence cs)
            return cs.Name.Equals(Name);
        return false;
    }

    public override string ToString() => Name;
    public override int GetHashCode() => Name?.GetHashCode() ?? 0;

    public static bool operator== (CharSequence a, CharSequence b) => a.Equals(b);
    public static bool operator!= (CharSequence a, CharSequence b) => !(a == b);
}

public class Appendable : IAccessibility, IFeature
{
    public string Name { get; set; }
    public string NameForDocAsType { get; set; }
    public string NameForDocAsLink { get; set; }
    public string Accessibility { get; set; }
    public string Feature { get; set; }
    public string Modifier { get; set; }
    public bool IsNullable { get; set; }
    public string Nullable => IsNullable ? "?" : "";

    public override bool Equals(object obj)
    {
        if (obj is string str)
            return str.Equals(obj);
        if (obj is Appendable app)
            return app.Name.Equals(Name);
        return false;
    }

    public override string ToString() => Name;
    public override int GetHashCode() => Name?.GetHashCode() ?? 0;

    public static bool operator== (Appendable a, Appendable b) => a.Equals(b);
    public static bool operator!= (Appendable a, Appendable b) => !(a == b);
}

public class NumericType : IFeature
{
    public string Name { get; set; }
    public bool IsClsCompliant { get; set; }
    public string CSharpName { get; set; }
    public string Feature { get; set; }

    public override bool Equals(object obj)
    {
        if (obj is string str)
            return str.Equals(obj);
        if (obj is NumericType nt)
            return nt.Name.Equals(Name);
        return false;
    }

    public override string ToString() => Name;
    public override int GetHashCode() => Name?.GetHashCode() ?? 0;

    public static bool operator== (NumericType a, NumericType b) => a.Equals(b);
    public static bool operator!= (NumericType a, NumericType b) => !(a == b);
}

public interface IAccessibility
{
    string Accessibility { get; set; }
}

public interface IFeature
{
    string Feature { get; set; }
}

string GetAccessibility(IAccessibility accessibility)
{
    return accessibility.Accessibility;
}

string GetAccessibility(string accessibility1, string accessibility2)
{
    string[] accessibilities = new string[] { accessibility1, accessibility2 };

    if (accessibilities.Contains("private"))
        return "private";
    else if (accessibilities.Contains("internal"))
        return "internal";
    else if (accessibilities.Contains("protected"))
        return "protected";
    else
        return "public";
}

string GetAccessibility(IAccessibility accessibility1, IAccessibility accessibility2)
{
    return GetAccessibility(accessibility1.Accessibility, accessibility2.Accessibility);
}

string GetAccessibility(string accessibility1, string accessibility2, string accessibility3)
{
    string[] accessibilities = new string[] { accessibility1, accessibility2, accessibility3 };

    if (accessibilities.Contains("private"))
        return "private";
    else if (accessibilities.Contains("internal"))
        return "internal";
    else if (accessibilities.Contains("protected"))
        return "protected";
    else
        return "public";
}

string GetAccessibility(IAccessibility accessibility1, IAccessibility accessibility2, IAccessibility accessibility3)
{
    return GetAccessibility(accessibility1.Accessibility, accessibility2.Accessibility, accessibility3.Accessibility);
}


string GetFeature(string feature1, string feature2)
{
    bool feature1Present = !string.IsNullOrWhiteSpace(feature1);
    bool feature2Present = !string.IsNullOrWhiteSpace(feature2);
    if (feature1Present && feature2Present)
        return feature1.Equals(feature2) ? feature1 : feature1 + " || " + feature2;
    else if (feature1Present)
        return feature1;
    else
        return feature2 ?? "";
}

string GetFeature(IFeature feature1, IFeature feature2)
{
    return GetFeature(feature1.Feature, feature2.Feature);
}

string GetFeature(string feature1, string feature2, string feature3)
{
    // Create a HashSet to store unique features
    HashSet<string> uniqueFeatures = new HashSet<string>();

    // Add non-empty features to the HashSet
    if (!string.IsNullOrEmpty(feature1))
        uniqueFeatures.Add(feature1);
    
    if (!string.IsNullOrEmpty(feature2))
        uniqueFeatures.Add(feature2);
    
    if (!string.IsNullOrEmpty(feature3))
        uniqueFeatures.Add(feature3);

    // If there's only one unique feature, return it
    if (uniqueFeatures.Count == 1)
        return uniqueFeatures.First();

    // If there are multiple features, concatenate them with " || "
    if (uniqueFeatures.Count > 1)
        return string.Join(" || ", uniqueFeatures);

    // If no features are present, return an empty string
    return string.Empty;
}

string GetFeature(IFeature feature1, IFeature feature2, IFeature feature3)
{
    return GetFeature(feature1.Feature, feature2.Feature, feature3.Feature);
}

string GetBeginFeature(string feature)
{
    return !string.IsNullOrEmpty(feature) ? "#if " + feature : "";
}

string GetBeginFeature(IFeature feature)
{
    return GetBeginFeature(feature.Feature);
}

string GetEndFeature(string feature)
{
    return !string.IsNullOrEmpty(feature) ? "#endif // " + feature : "";
}

string GetEndFeature(IFeature feature)
{
    return GetEndFeature(feature.Feature);
}

string GetNameForDocAsType(string name) // for use within links to methods that accept this type
{
    return name.Replace("<", "{").Replace(">", "}").Replace("{char}", "{Char}");
}

string GetNameForDocAsLink(string name) // for use as the entire link to a type
{
    return name == "char[]" ? "T:char[]" : name.Replace("<", "{").Replace(">", "}").Replace("{char}", "{Char}");
}
#>
