<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Select(x => x.Value).ToArray();
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using NUnit.Framework;
using System.Collections.Generic;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class UnicodeSetPartialTest
    {
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestSetEquals_<#=GetCharSequenceName(charSequence)#>()
        {
<# if (charSequence == "string") { #>
            var empty = "";
            var equiv1 = "ABCDEF";
            var equiv2 = "BDEFAC";
            var nonEquiv1 = "CDEAZF";
            var nonEquiv2 = "ABCDEFG";
<# } else if (charSequence == "StringBuilder") { #>
            var empty = new StringBuilder("");
            var equiv1 = new StringBuilder("ABCDEF");
            var equiv2 = new StringBuilder("BDEFAC");
            var nonEquiv1 = new StringBuilder("CDEAZF");
            var nonEquiv2 = new StringBuilder("ABCDEFG");
<# } else if (charSequence == "char[]") { #>
            var empty = "".ToCharArray();
            var equiv1 = "ABCDEF".ToCharArray();
            var equiv2 = "BDEFAC".ToCharArray();
            var nonEquiv1 = "CDEAZF".ToCharArray();
            var nonEquiv2 = "ABCDEFG".ToCharArray();
<# } else if (charSequence == "ICharSequence") { #>
            var empty = "".AsCharSequence();
            var equiv1 = "ABCDEF".AsCharSequence();
            var equiv2 = "BDEFAC".AsCharSequence();
            var nonEquiv1 = "CDEAZF".AsCharSequence();
            var nonEquiv2 = "ABCDEFG".AsCharSequence();
<# } #>
            
            string methodName = nameof(UnicodeSet.SetEquals);

            // Test empty set
            assertFalse($"{methodName}: The word sets are equal", aThruFSet.SetEquals(empty));
            assertTrue($"{methodName}: The word sets are not equal", emptySet.SetEquals(empty));

            assertTrue($"{methodName}: The word sets are not equal", aThruFSet.SetEquals(equiv1));
            assertTrue($"{methodName}: The word sets are not equal", aThruFSet.SetEquals(equiv2));
            assertFalse($"{methodName}: The word sets are equal", aThruFSet.SetEquals(nonEquiv1));
            assertFalse($"{methodName}: The word sets are equal", aThruFSet.SetEquals(nonEquiv2));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestSetEquals_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivSet = new List<<#=charSequence#>>();
            string methodName = nameof(UnicodeSet.SetEquals);

            // Test empty set
            assertFalse($"{methodName}: The word sets are equal", thaiWordSet.SetEquals(equivSet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: The word sets are not equal", thaiWordSet.SetEquals(equivSet));
            equivSet.RemoveAt(0);
            assertFalse($"{methodName}: The word sets are equal", thaiWordSet.SetEquals(equivSet));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsSupersetOf_<#=GetCharSequenceName(charSequence)#>()
        {
<# if (charSequence == "string") { #>
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSet2 = "BDEFAC";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";
<# } else if (charSequence == "StringBuilder") { #>
            var equivEmptySet = new StringBuilder("");
            var equivSet = new StringBuilder("ABCDEF");
            var equivSet2 = new StringBuilder("BDEFAC");
            var equivSubset = new StringBuilder("CDEAF");
            var equivSuperset = new StringBuilder("ABCDEFG");
<# } else if (charSequence == "char[]") { #>
            var equivEmptySet = "".ToCharArray();
            var equivSet = "ABCDEF".ToCharArray();
            var equivSet2 = "BDEFAC".ToCharArray();
            var equivSubset = "CDEAF".ToCharArray();
            var equivSuperset = "ABCDEFG".ToCharArray();
<# } else if (charSequence == "ICharSequence") { #>
            var equivEmptySet = "".AsCharSequence();
            var equivSet = "ABCDEF".AsCharSequence();
            var equivSet2 = "BDEFAC".AsCharSequence();
            var equivSubset = "CDEAF".AsCharSequence();
            var equivSuperset = "ABCDEFG".AsCharSequence();
<# } #>
            string setOperation = "superset", methodName = nameof(UnicodeSet.IsSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsSupersetOf(equivEmptySet));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSupersetOf(equivEmptySet));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSet)}", aThruFSet.IsSupersetOf(equivSet));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSet2)}", aThruFSuperset.IsSupersetOf(equivSet2));
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsSupersetOf(equivSubset));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsSupersetOf(equivSuperset));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsSupersetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsSupersetOf_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            string setOperation = "superset", methodName = nameof(UnicodeSet.IsSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsSupersetOf(equivEmptySet));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSupersetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsSupersetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsSupersetOf(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSuperset)}", thaiWordSet.IsSupersetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsProperSupersetOf_<#=GetCharSequenceName(charSequence)#>()
        {
<# if (charSequence == "string") { #>
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSet2 = "BDEFAC";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";
<# } else if (charSequence == "StringBuilder") { #>
            var equivEmptySet = new StringBuilder("");
            var equivSet = new StringBuilder("ABCDEF");
            var equivSet2 = new StringBuilder("BDEFAC");
            var equivSubset = new StringBuilder("CDEAF");
            var equivSuperset = new StringBuilder("ABCDEFG");
<# } else if (charSequence == "char[]") { #>
            var equivEmptySet = "".ToCharArray();
            var equivSet = "ABCDEF".ToCharArray();
            var equivSet2 = "BDEFAC".ToCharArray();
            var equivSubset = "CDEAF".ToCharArray();
            var equivSuperset = "ABCDEFG".ToCharArray();
<# } else if (charSequence == "ICharSequence") { #>
            var equivEmptySet = "".AsCharSequence();
            var equivSet = "ABCDEF".AsCharSequence();
            var equivSet2 = "BDEFAC".AsCharSequence();
            var equivSubset = "CDEAF".AsCharSequence();
            var equivSuperset = "ABCDEFG".AsCharSequence();
<# } #>
            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsProperSupersetOf(equivEmptySet));
            assertFalse($"{methodName}: {nameof(emptySet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSupersetOf(equivEmptySet));

            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSet)}", aThruFSet.IsProperSupersetOf(equivSet));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSet2)}", aThruFSuperset.IsProperSupersetOf(equivSet2));
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsProperSupersetOf(equivSubset));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsProperSupersetOf(equivSuperset));
            assertFalse($"{methodName}: {nameof(aThruFSuperset)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsProperSupersetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsProperSupersetOf_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsProperSupersetOf(equivEmptySet));
            assertFalse($"{methodName}: {nameof(emptySet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSupersetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsProperSupersetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsProperSupersetOf(equivSubset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsSubsetOf_<#=GetCharSequenceName(charSequence)#>()
        {
<# if (charSequence == "string") { #>
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSet2 = "BDEFAC";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";
<# } else if (charSequence == "StringBuilder") { #>
            var equivEmptySet = new StringBuilder("");
            var equivSet = new StringBuilder("ABCDEF");
            var equivSet2 = new StringBuilder("BDEFAC");
            var equivSubset = new StringBuilder("CDEAF");
            var equivSuperset = new StringBuilder("ABCDEFG");
<# } else if (charSequence == "char[]") { #>
            var equivEmptySet = "".ToCharArray();
            var equivSet = "ABCDEF".ToCharArray();
            var equivSet2 = "BDEFAC".ToCharArray();
            var equivSubset = "CDEAF".ToCharArray();
            var equivSuperset = "ABCDEFG".ToCharArray();
<# } else if (charSequence == "ICharSequence") { #>
            var equivEmptySet = "".AsCharSequence();
            var equivSet = "ABCDEF".AsCharSequence();
            var equivSet2 = "BDEFAC".AsCharSequence();
            var equivSubset = "CDEAF".AsCharSequence();
            var equivSuperset = "ABCDEFG".AsCharSequence();
<# } #>
            string setOperation = "subset", methodName = nameof(UnicodeSet.IsSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsSubsetOf(equivEmptySet));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSubsetOf(equivEmptySet));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSet)}", aThruFSet.IsSubsetOf(equivSet));
            assertFalse($"{methodName}: {nameof(aThruFSuperset)} is a {setOperation} of {nameof(equivSet2)}", aThruFSuperset.IsSubsetOf(equivSet2));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsSubsetOf(equivSubset));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsSubsetOf(equivSuperset));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsSubsetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsSubsetOf_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            string setOperation = "subset", methodName = nameof(UnicodeSet.IsSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsSubsetOf(equivEmptySet));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSubsetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsSubsetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsSubsetOf(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSuperset)}", thaiWordSet.IsSubsetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsProperSubsetOf_<#=GetCharSequenceName(charSequence)#>()
        {
<# if (charSequence == "string") { #>
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";
<# } else if (charSequence == "StringBuilder") { #>
            var equivEmptySet = new StringBuilder("");
            var equivSet = new StringBuilder("ABCDEF");
            var equivSubset = new StringBuilder("CDEAF");
            var equivSuperset = new StringBuilder("ABCDEFG");
<# } else if (charSequence == "char[]") { #>
            var equivEmptySet = "".ToCharArray();
            var equivSet = "ABCDEF".ToCharArray();
            var equivSubset = "CDEAF".ToCharArray();
            var equivSuperset = "ABCDEFG".ToCharArray();
<# } else if (charSequence == "ICharSequence") { #>
            var equivEmptySet = "".AsCharSequence();
            var equivSet = "ABCDEF".AsCharSequence();
            var equivSubset = "CDEAF".AsCharSequence();
            var equivSuperset = "ABCDEFG".AsCharSequence();
<# } #>
            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsProperSubsetOf(equivEmptySet));
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSubsetOf(equivEmptySet));

            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSet)}", aThruFSet.IsProperSubsetOf(equivSet));
            assertTrue($"{methodName}: {nameof(aThruFSubset)} is not a {setOperation} of {nameof(equivSet)}", aThruFSubset.IsProperSubsetOf(equivSet));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsProperSubsetOf(equivSubset));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsProperSubsetOf(equivSuperset));
            assertFalse($"{methodName}: {nameof(aThruFSuperset)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsProperSubsetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestIsProperSubsetOf_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsProperSubsetOf(equivEmptySet));
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSubsetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsProperSubsetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsProperSubsetOf(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSuperset)}", thaiWordSet.IsProperSubsetOf(equivSuperset));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestOverlaps_<#=GetCharSequenceName(charSequence)#>()
        {
<# if (charSequence == "string") { #>
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";
<# } else if (charSequence == "StringBuilder") { #>
            var equivEmptySet = new StringBuilder("");
            var equivSet = new StringBuilder("ABCDEF");
            var equivSubset = new StringBuilder("CDEAF");
            var equivSuperset = new StringBuilder("ABCDEFG");
<# } else if (charSequence == "char[]") { #>
            var equivEmptySet = "".ToCharArray();
            var equivSet = "ABCDEF".ToCharArray();
            var equivSubset = "CDEAF".ToCharArray();
            var equivSuperset = "ABCDEFG".ToCharArray();
<# } else if (charSequence == "ICharSequence") { #>
            var equivEmptySet = "".AsCharSequence();
            var equivSet = "ABCDEF".AsCharSequence();
            var equivSubset = "CDEAF".AsCharSequence();
            var equivSuperset = "ABCDEFG".AsCharSequence();
<# } #>
            string setOperation = "overlap", methodName = nameof(UnicodeSet.Overlaps);

            // Test empty set
            assertFalse($"{methodName}: {nameof(aThruFSet)} does {setOperation} with {nameof(equivEmptySet)}", aThruFSet.Overlaps(equivEmptySet));
            assertFalse($"{methodName}: {nameof(emptySet)} does {setOperation} with {nameof(equivEmptySet)}", emptySet.Overlaps(equivEmptySet));

            assertTrue($"{methodName}: {nameof(aThruFSet)} does not {setOperation} with {nameof(equivSet)}", aThruFSet.Overlaps(equivSet));
            assertTrue($"{methodName}: {nameof(aThruFSet)} does not {setOperation} with {nameof(equivSubset)}", aThruFSet.Overlaps(equivSubset));
            assertTrue($"{methodName}: {nameof(aThruFSet)} does not {setOperation} with {nameof(equivSuperset)}", aThruFSet.Overlaps(equivSuperset));
            assertFalse($"{methodName}: {nameof(thaiWordSet)} does {setOperation} with {nameof(equivSet)}", thaiWordSet.Overlaps(equivSet));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestOverlaps_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            var equivBurmeseSet = new List<<#=charSequence#>>();
            string setOperation = "overlap", methodName = nameof(UnicodeSet.Overlaps);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} does {setOperation} with {nameof(equivEmptySet)}", thaiWordSet.Overlaps(equivEmptySet));
            assertFalse($"{methodName}: {nameof(emptySet)} does {setOperation} with {nameof(equivEmptySet)}", emptySet.Overlaps(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} does not {setOperation} with {nameof(equivSet)}", thaiWordSet.Overlaps(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} does not {setOperation} with {nameof(equivSubset)}", thaiWordSet.Overlaps(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} does not {setOperation} with {nameof(equivSuperset)}", thaiWordSet.Overlaps(equivSuperset));

            burmeseWordSet.CopyTo(equivBurmeseSet);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} does {setOperation} with {nameof(equivBurmeseSet)}", thaiWordSet.Overlaps(equivBurmeseSet));
        }
<# } #>
<# foreach (var charSequence in charSequences) { #>

        [Test]
        public void TestSymmetricExceptWith_<#=GetCharSequenceName(charSequence)#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivDThruMSet = new List<<#=charSequence#>>();
            var equivThaiWordSuperset = new List<<#=charSequence#>>();
            string setOperation = "symmetric except with (xOr)", methodName = nameof(UnicodeSet.SymmetricExceptWith);

            // Test empty set
            assertEquals($"{methodName}: {nameof(aThruFSet)} {setOperation} {nameof(equivEmptySet)} is wrong", aThruFSet, aThruFSet.SymmetricExceptWith(equivEmptySet));

            dThruMSet.CopyTo(equivDThruMSet);
            assertEquals($"{methodName}: {nameof(aThruFSet)} {setOperation} {nameof(equivDThruMSet)} is wrong", new UnicodeSet("[A-CG-M]"), aThruFSet.SymmetricExceptWith(equivDThruMSet));

            thaiWordSuperset.CopyTo(equivThaiWordSuperset);
            assertEquals($"{methodName}: {nameof(thaiWordSet)} {setOperation} {nameof(equivThaiWordSuperset)} is wrong", new UnicodeSet("[A]"), thaiWordSet.SymmetricExceptWith(equivThaiWordSuperset));
        }
<# } #>
    }
}

<#+
public string GetCharSequenceName(string charSequence)
{
    switch (charSequence)
    {
        case "string":
            return "String";
        case "char[]":
            return "CharArray";
        case "StringBuilder":
            return "StringBuilder";
        default:
            return "CharSequence";
    }
}
#>