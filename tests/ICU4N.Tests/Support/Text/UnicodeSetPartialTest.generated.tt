<#@ output extension=".cs" #>
<#@ include file="../../../../codegen/FilterDeclarations.tt" #>
<#
AppendableFilter = (a) => a.Name != "ValueStringBuilder";
string codeGenerationRelativePath = @"../../../../codegen";
#><#@ include file="../../../../codegen/DataLoader.tt" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using J2N.Text;
using NUnit.Framework;
using System;
using System.Collections.Generic;
using System.Text;

namespace ICU4N.Text
{
    public sealed partial class UnicodeSetPartialTest
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestSetEquals_<#=charSequence.NameForTest#>()
        {
            var empty = "";
            var equiv1 = "ABCDEF";
            var equiv2 = "BDEFAC";
            var nonEquiv1 = "CDEAZF";
            var nonEquiv2 = "ABCDEFG";
            
            string methodName = nameof(UnicodeSet.SetEquals);

            // Test empty set
            assertFalse($"{methodName}: The word sets are equal", aThruFSet.SetEquals(<#=string.Format(charSequence.FromStringFormat, "empty")#>));
            assertTrue($"{methodName}: The word sets are not equal", emptySet.SetEquals(<#=string.Format(charSequence.FromStringFormat, "empty")#>));

            assertTrue($"{methodName}: The word sets are not equal", aThruFSet.SetEquals(<#=string.Format(charSequence.FromStringFormat, "equiv1")#>));
            assertTrue($"{methodName}: The word sets are not equal", aThruFSet.SetEquals(<#=string.Format(charSequence.FromStringFormat, "equiv2")#>));
            assertFalse($"{methodName}: The word sets are equal", aThruFSet.SetEquals(<#=string.Format(charSequence.FromStringFormat, "nonEquiv1")#>));
            assertFalse($"{methodName}: The word sets are equal", aThruFSet.SetEquals(<#=string.Format(charSequence.FromStringFormat, "nonEquiv2")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestSetEquals_<#=charSequence.NameForTest#>Collection()
        {
            var equivSet = new List<<#=charSequence#>>();
            string methodName = nameof(UnicodeSet.SetEquals);

            // Test empty set
            assertFalse($"{methodName}: The word sets are equal", thaiWordSet.SetEquals(equivSet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: The word sets are not equal", thaiWordSet.SetEquals(equivSet));
            equivSet.RemoveAt(0);
            assertFalse($"{methodName}: The word sets are equal", thaiWordSet.SetEquals(equivSet));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsSupersetOf_<#=charSequence.NameForTest#>()
        {
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSet2 = "BDEFAC";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";

            string setOperation = "superset", methodName = nameof(UnicodeSet.IsSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSet)}", aThruFSet.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSet2)}", aThruFSuperset.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet2")#>));
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSubset")#>));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsSupersetOf_<#=charSequence.NameForTest#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            string setOperation = "superset", methodName = nameof(UnicodeSet.IsSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsSupersetOf(equivEmptySet));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSupersetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsSupersetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsSupersetOf(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSuperset)}", thaiWordSet.IsSupersetOf(equivSuperset));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsProperSupersetOf_<#=charSequence.NameForTest#>()
        {
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSet2 = "BDEFAC";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";

            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));
            assertFalse($"{methodName}: {nameof(emptySet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));

            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSet)}", aThruFSet.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSet2)}", aThruFSuperset.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet2")#>));
            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSubset")#>));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
            assertFalse($"{methodName}: {nameof(aThruFSuperset)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsProperSupersetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsProperSupersetOf_<#=charSequence.NameForTest#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSupersetOf);

            // Test empty set
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsProperSupersetOf(equivEmptySet));
            assertFalse($"{methodName}: {nameof(emptySet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSupersetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsProperSupersetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsProperSupersetOf(equivSubset));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsSubsetOf_<#=charSequence.NameForTest#>()
        {
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSet2 = "BDEFAC";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";

            string setOperation = "subset", methodName = nameof(UnicodeSet.IsSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSet)}", aThruFSet.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
            assertFalse($"{methodName}: {nameof(aThruFSuperset)} is a {setOperation} of {nameof(equivSet2)}", aThruFSuperset.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet2")#>));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSubset")#>));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
            assertTrue($"{methodName}: {nameof(aThruFSuperset)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsSubsetOf_<#=charSequence.NameForTest#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            string setOperation = "subset", methodName = nameof(UnicodeSet.IsSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsSubsetOf(equivEmptySet));
            assertTrue($"{methodName}: {nameof(emptySet)} is not a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsSubsetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsSubsetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsSubsetOf(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSuperset)}", thaiWordSet.IsSubsetOf(equivSuperset));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsProperSubsetOf_<#=charSequence.NameForTest#>()
        {
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";

            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", aThruFSet.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));

            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSet)}", aThruFSet.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
            assertTrue($"{methodName}: {nameof(aThruFSubset)} is not a {setOperation} of {nameof(equivSet)}", aThruFSubset.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
            assertFalse($"{methodName}: {nameof(aThruFSet)} is a {setOperation} of {nameof(equivSubset)}", aThruFSet.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSubset")#>));

            assertTrue($"{methodName}: {nameof(aThruFSet)} is not a {setOperation} of {nameof(equivSuperset)}", aThruFSet.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
            assertFalse($"{methodName}: {nameof(aThruFSuperset)} is a {setOperation} of {nameof(equivSuperset)}", aThruFSuperset.IsProperSubsetOf(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestIsProperSubsetOf_<#=charSequence.NameForTest#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            string setOperation = "proper superset", methodName = nameof(UnicodeSet.IsProperSubsetOf);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", thaiWordSet.IsProperSubsetOf(equivEmptySet));
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivEmptySet)}", emptySet.IsProperSubsetOf(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSet)}", thaiWordSet.IsProperSubsetOf(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} is a {setOperation} of {nameof(equivSubset)}", thaiWordSet.IsProperSubsetOf(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} is not a {setOperation} of {nameof(equivSuperset)}", thaiWordSet.IsProperSubsetOf(equivSuperset));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestOverlaps_<#=charSequence.NameForTest#>()
        {
            var equivEmptySet = "";
            var equivSet = "ABCDEF";
            var equivSubset = "CDEAF";
            var equivSuperset = "ABCDEFG";

            string setOperation = "overlap", methodName = nameof(UnicodeSet.Overlaps);

            // Test empty set
            assertFalse($"{methodName}: {nameof(aThruFSet)} does {setOperation} with {nameof(equivEmptySet)}", aThruFSet.Overlaps(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));
            assertFalse($"{methodName}: {nameof(emptySet)} does {setOperation} with {nameof(equivEmptySet)}", emptySet.Overlaps(<#=string.Format(charSequence.FromStringFormat, "equivEmptySet")#>));

            assertTrue($"{methodName}: {nameof(aThruFSet)} does not {setOperation} with {nameof(equivSet)}", aThruFSet.Overlaps(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
            assertTrue($"{methodName}: {nameof(aThruFSet)} does not {setOperation} with {nameof(equivSubset)}", aThruFSet.Overlaps(<#=string.Format(charSequence.FromStringFormat, "equivSubset")#>));
            assertTrue($"{methodName}: {nameof(aThruFSet)} does not {setOperation} with {nameof(equivSuperset)}", aThruFSet.Overlaps(<#=string.Format(charSequence.FromStringFormat, "equivSuperset")#>));
            assertFalse($"{methodName}: {nameof(thaiWordSet)} does {setOperation} with {nameof(equivSet)}", thaiWordSet.Overlaps(<#=string.Format(charSequence.FromStringFormat, "equivSet")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestOverlaps_<#=charSequence.NameForTest#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivSet = new List<<#=charSequence#>>();
            var equivSubset = new List<<#=charSequence#>>();
            var equivSuperset = new List<<#=charSequence#>>();
            var equivBurmeseSet = new List<<#=charSequence#>>();
            string setOperation = "overlap", methodName = nameof(UnicodeSet.Overlaps);

            // Test empty set
            assertFalse($"{methodName}: {nameof(thaiWordSet)} does {setOperation} with {nameof(equivEmptySet)}", thaiWordSet.Overlaps(equivEmptySet));
            assertFalse($"{methodName}: {nameof(emptySet)} does {setOperation} with {nameof(equivEmptySet)}", emptySet.Overlaps(equivEmptySet));

            thaiWordSet.CopyTo(equivSet);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} does not {setOperation} with {nameof(equivSet)}", thaiWordSet.Overlaps(equivSet));

            thaiWordSubset.CopyTo(equivSubset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} does not {setOperation} with {nameof(equivSubset)}", thaiWordSet.Overlaps(equivSubset));

            thaiWordSuperset.CopyTo(equivSuperset);
            assertTrue($"{methodName}: {nameof(thaiWordSet)} does not {setOperation} with {nameof(equivSuperset)}", thaiWordSet.Overlaps(equivSuperset));

            burmeseWordSet.CopyTo(equivBurmeseSet);
            assertFalse($"{methodName}: {nameof(thaiWordSet)} does {setOperation} with {nameof(equivBurmeseSet)}", thaiWordSet.Overlaps(equivBurmeseSet));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
    <# if (charSequence.Name != "ReadOnlySpan<char>") { #>
<#= GetBeginFeature(charSequence) #>

        [Test]
        public void TestSymmetricExceptWith_<#=charSequence.NameForTest#>Collection()
        {
            var equivEmptySet = new List<<#=charSequence#>>();
            var equivDThruMSet = new List<<#=charSequence#>>();
            var equivThaiWordSuperset = new List<<#=charSequence#>>();
            string setOperation = "symmetric except with (xOr)", methodName = nameof(UnicodeSet.SymmetricExceptWith);

            // Test empty set
            assertEquals($"{methodName}: {nameof(aThruFSet)} {setOperation} {nameof(equivEmptySet)} is wrong", aThruFSet, aThruFSet.SymmetricExceptWith(equivEmptySet));

            dThruMSet.CopyTo(equivDThruMSet);
            assertEquals($"{methodName}: {nameof(aThruFSet)} {setOperation} {nameof(equivDThruMSet)} is wrong", new UnicodeSet("[A-CG-M]"), aThruFSet.SymmetricExceptWith(equivDThruMSet));

            thaiWordSuperset.CopyTo(equivThaiWordSuperset);
            assertEquals($"{methodName}: {nameof(thaiWordSet)} {setOperation} {nameof(equivThaiWordSuperset)} is wrong", new UnicodeSet("[A]"), thaiWordSet.SymmetricExceptWith(equivThaiWordSuperset));
        }
<#= GetEndFeature(charSequence) #>
    <# } #>
<# } #>
    }
}
<#@ include file="../../../../codegen/SharedObjects.tt" #>