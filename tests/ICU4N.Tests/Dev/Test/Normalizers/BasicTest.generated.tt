<#@ output extension=".cs" #>
<#@ include file="../../../../../codegen/FilterDeclarations.tt" #>
<#
AppendableFilter = (a) => a.Name != "ValueStringBuilder";
string codeGenerationRelativePath = @"../../../../../codegen";
#><#@ include file="../../../../../codegen/DataLoader.tt" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Text;
using J2N;
using J2N.Text;
using NUnit.Framework;
using System;
using System.Reflection;
using System.Text;


namespace ICU4N.Dev.Test.Normalizers
{
    public partial class BasicTest
    {
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestCustomComp_<#=charSequence.NameForTest#>()
        {
            string[][] pairs ={
                new string[] { "\\uD801\\uE000\\uDFFE", "" },
                new string[] { "\\uD800\\uD801\\uE000\\uDFFE\\uDFFF", "\\uD7FF\\uFFFF" },
                new string[] { "\\uD800\\uD801\\uDFFE\\uDFFF", "\\uD7FF\\U000107FE\\uFFFF" },
                new string[] { "\\uE001\\U000110B9\\u0345\\u0308\\u0327", "\\uE002\\U000110B9\\u0327\\u0345" },
                new string[] { "\\uE010\\U000F0011\\uE012", "\\uE011\\uE012" },
                new string[] { "\\uE010\\U000F0011\\U000F0011\\uE012", "\\uE011\\U000F0010" },
                new string[] { "\\uE111\\u1161\\uE112\\u1162", "\\uAE4C\\u1102\\u0062\\u1162" },
                new string[] { "\\uFFF3\\uFFF7\\U00010036\\U00010077", "\\U00010037\\U00010037\\uFFF6\\U00010037" }
            };
            Normalizer2 customNorm2;
            Assembly assembly = typeof(BasicTest).Assembly;
            customNorm2 =
                Normalizer2.GetInstance(
                    //BasicTest.class.getResourceAsStream("/com/ibm/icu/dev/data/testdata/testnorm.nrm"),
                    assembly.GetManifestResourceStream("ICU4N.Dev.Data.TestData.testnorm.nrm"),
                        "testnorm",
                        Normalizer2Mode.Compose);
            for (int i = 0; i < pairs.Length; ++i)
            {
                string[] pair = pairs[i];
                string input = Utility.Unescape(pair[0]);
                string expected = Utility.Unescape(pair[1]);
                string result = customNorm2.Normalize(<#=string.Format(charSequence.FromStringFormat, "input")#>);
                if (!result.Equals(expected))
                {
                    Errln("custom compose Normalizer2 did not normalize input " + i + " as expected");
                }
            }
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestCustomFCC_<#=charSequence.NameForTest#>()
        {
            string[][] pairs ={
                new string[] { "\\uD801\\uE000\\uDFFE", "" },
                new string[] { "\\uD800\\uD801\\uE000\\uDFFE\\uDFFF", "\\uD7FF\\uFFFF" },
                new string[] { "\\uD800\\uD801\\uDFFE\\uDFFF", "\\uD7FF\\U000107FE\\uFFFF" },
                // The following expected result is different from CustomComp
                // because of only-contiguous composition.
                new string[] { "\\uE001\\U000110B9\\u0345\\u0308\\u0327", "\\uE001\\U000110B9\\u0327\\u0308\\u0345" },
                new string[] { "\\uE010\\U000F0011\\uE012", "\\uE011\\uE012" },
                new string[] { "\\uE010\\U000F0011\\U000F0011\\uE012", "\\uE011\\U000F0010" },
                new string[] { "\\uE111\\u1161\\uE112\\u1162", "\\uAE4C\\u1102\\u0062\\u1162" },
                new string[] { "\\uFFF3\\uFFF7\\U00010036\\U00010077", "\\U00010037\\U00010037\\uFFF6\\U00010037" }
            };
            Assembly assembly = typeof(BasicTest).Assembly;
            Normalizer2 customNorm2;
            customNorm2 =
                Normalizer2.GetInstance(
                    //BasicTest.class.getResourceAsStream("/com/ibm/icu/dev/data/testdata/testnorm.nrm"),
                    assembly.GetManifestResourceStream("ICU4N.Dev.Data.TestData.testnorm.nrm"),
                        "testnorm",
                        Normalizer2Mode.ComposeContiguous);
            for (int i = 0; i < pairs.Length; ++i)
            {
                string[] pair = pairs[i];
                string input = Utility.Unescape(pair[0]);
                string expected = Utility.Unescape(pair[1]);
                string result = customNorm2.Normalize(<#=string.Format(charSequence.FromStringFormat, "input")#>);
                if (!result.Equals(expected))
                {
                    Errln("custom FCC Normalizer2 did not normalize input " + i + " as expected");
                }
            }
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestFilteredNormalizer2_<#=charSequence.NameForTest#>()
        {
            Normalizer2 nfcNorm2 = Normalizer2.NFCInstance;
            UnicodeSet filter = new UnicodeSet("[^\u00a0-\u00ff\u0310-\u031f]");
            FilteredNormalizer2 fn2 = new FilteredNormalizer2(nfcNorm2, filter);
            int c;
            for (c = 0; c <= 0x3ff; ++c)
            {
                int expectedCC = filter.Contains(c) ? nfcNorm2.GetCombiningClass(c) : 0;
                int cc = fn2.GetCombiningClass(c);
                assertEquals(
                        "FilteredNormalizer2(NFC, ^A0-FF,310-31F).getCombiningClass(U+" + Hex(c) +
                        ")==filtered NFC.getCC()",
                        expectedCC, cc);
            }

            // More coverage.
            StringBuilder sb = new StringBuilder();
            string input = "a\u0308ä\u0304";
            assertEquals("filtered normalize()", "ää\u0304",
                    fn2.Normalize(<#=string.Format(charSequence.FromStringFormat, "input")#>, sb).ToString());
            assertTrue("filtered hasBoundaryAfter()", fn2.HasBoundaryAfter('ä'));
            assertTrue("filtered isInert()", fn2.IsInert(0x0313));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestFilteredAppend_<#=charSequence.NameForTest#>()
        {
            Normalizer2 nfcNorm2 = Normalizer2.NFCInstance;
            UnicodeSet filter = new UnicodeSet("[^\u00a0-\u00ff\u0310-\u031f]");
            FilteredNormalizer2 fn2 = new FilteredNormalizer2(nfcNorm2, filter);

            // Append two strings that each contain a character outside the filter set.
            StringBuilder sb = new StringBuilder("a\u0313a");
            string second = "\u0301\u0313";
            assertEquals("append()", "a\u0313á\u0313", fn2.Append(sb, <#=string.Format(charSequence.FromStringFormat, "second")#>).ToString());

            // Same, and also normalize the second string.
            sb.Replace(0, 0x7fffffff - 0, "a\u0313a"); // ICU4N: Checked 2nd parameter
            assertEquals(
                "normalizeSecondAndAppend()",
                "a\u0313á\u0313", fn2.NormalizeSecondAndAppend(sb, <#=string.Format(charSequence.FromStringFormat, "second")#>).ToString());

            // Normalizer2.Normalize(string) uses spanQuickCheckYes() and normalizeSecondAndAppend().
            string input = "a\u0313a\u0301\u0313";
            assertEquals("normalize()", "a\u0313á\u0313", fn2.Normalize(<#=string.Format(charSequence.FromStringFormat, "input")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestGetEasyToUseInstance_<#=charSequence.NameForTest#>()
        {
            // Test input string:
            // U+00A0 -> <noBreak> 0020
            // U+00C7 0301 = 1E08 = 0043 0327 0301
            string @in = "\u00A0\u00C7\u0301";
            Normalizer2 n2 = Normalizer2.NFCInstance;
            string @out = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "@in")#>);
            assertEquals(
                    "getNFCInstance() did not return an NFC instance " +
                    "(normalizes to " + Prettify(@out) + ')',
                    "\u00A0\u1E08", @out);

            n2 = Normalizer2.NFDInstance;
            @out = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "@in")#>);
            assertEquals(
                    "getNFDInstance() did not return an NFD instance " +
                    "(normalizes to " + Prettify(@out) + ')',
                    "\u00A0C\u0327\u0301", @out);

            n2 = Normalizer2.NFKCInstance;
            @out = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "@in")#>);
            assertEquals(
                    "getNFKCInstance() did not return an NFKC instance " +
                    "(normalizes to " + Prettify(@out) + ')',
                    " \u1E08", @out);

            n2 = Normalizer2.NFKDInstance;
            @out = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "@in")#>);
            assertEquals(
                    "getNFKDInstance() did not return an NFKD instance " +
                    "(normalizes to " + Prettify(@out) + ')',
                    " C\u0327\u0301", @out);

            n2 = Normalizer2.NFKCCaseFoldInstance;
            @out = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "@in")#>);
            assertEquals(
                    "getNFKCCasefoldInstance() did not return an NFKC_Casefold instance " +
                    "(normalizes to " + Prettify(@out) + ')',
                    " \u1E09", @out);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestLowMappingToEmpty_D_<#=charSequence.NameForTest#>()
        {
            Normalizer2 n2 = Normalizer2.GetInstance(null, "nfkc_cf", Normalizer2Mode.Decompose);
            checkLowMappingToEmpty(n2);
            
            string sh = "\u00AD";
            assertFalse("soft hyphen is not normalized", n2.IsNormalized(<#=string.Format(charSequence.FromStringFormat, "sh")#>));
            string result = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "sh")#>);
            assertTrue("soft hyphen normalizes to empty", result == string.Empty);
            assertEquals("soft hyphen QC=No", QuickCheckResult.No, n2.QuickCheck(<#=string.Format(charSequence.FromStringFormat, "sh")#>));
            assertEquals("soft hyphen spanQuickCheckYes", 0, n2.SpanQuickCheckYes(<#=string.Format(charSequence.FromStringFormat, "sh")#>));

            string s = "\u00ADÄ\u00AD\u0323";
            result = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "s")#>);
            assertEquals("normalize string with soft hyphens", "a\u0323\u0308", result);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestLowMappingToEmpty_FCD_<#=charSequence.NameForTest#>()
        {
            Normalizer2 n2 = Normalizer2.GetInstance(null, "nfkc_cf", Normalizer2Mode.FCD);
            checkLowMappingToEmpty(n2);

            string sh = "\u00AD";
            assertTrue("soft hyphen is FCD", n2.IsNormalized(<#=string.Format(charSequence.FromStringFormat, "sh")#>));

            string s = "\u00ADÄ\u00AD\u0323";
            string result = n2.Normalize(<#=string.Format(charSequence.FromStringFormat, "s")#>);
            assertEquals("normalize string with soft hyphens", "\u00ADa\u0323\u0308", result);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestNormalizeIllFormedText_<#=charSequence.NameForTest#>()
        {
            Normalizer2 nfkc_cf = Normalizer2.NFKCCaseFoldInstance;
            // Normalization behavior for ill-formed text is not defined.
            // ICU currently treats ill-formed sequences as normalization-inert
            // and copies them unchanged.
            string src = "  A\uD800ÄA\u0308\uD900A\u0308\u00ad\u0323\uDBFFÄ\u0323," +
                    "\u00ad\uDC00\u1100\u1161가\u11A8가\u3133  \uDFFF";
            string expected = "  a\uD800ää\uD900ạ\u0308\uDBFFạ\u0308,\uDC00가각갃  \uDFFF";
            string result = nfkc_cf.Normalize(<#=string.Format(charSequence.FromStringFormat, "src")#>);
            assertEquals("normalize", expected, result);
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestComposeJamoTBase_<#=charSequence.NameForTest#>()
        {
            // Algorithmic composition of Hangul syllables must not combine with JAMO_T_BASE = U+11A7
            // which is not a conjoining Jamo Trailing consonant.
            Normalizer2 nfkc = Normalizer2.NFKCInstance;
            string s = "\u1100\u1161\u11A7\u1100\u314F\u11A7가\u11A7";
            string expected = "가\u11A7가\u11A7가\u11A7";
            string result = nfkc.Normalize(<#=string.Format(charSequence.FromStringFormat, "s")#>);
            assertEquals("normalize(LV+11A7)", expected, result);
            assertFalse("isNormalized(LV+11A7)", nfkc.IsNormalized(<#=string.Format(charSequence.FromStringFormat, "s")#>));
            assertTrue("isNormalized(normalized)", nfkc.IsNormalized(<#=string.Format(charSequence.FromStringFormat, "result")#>));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestComposeBoundaryAfter_<#=charSequence.NameForTest#>()
        {
            Normalizer2 nfkc = Normalizer2.NFKCInstance;
            // U+02DA and U+FB2C do not have compose-boundaries-after.
            string s = "\u02DA\u0339 \uFB2C\u05B6";
            string expected = " \u0339\u030A \u05E9\u05B6\u05BC\u05C1";
            string result = nfkc.Normalize(<#=string.Format(charSequence.FromStringFormat, "s")#>);
            assertEquals("nfkc", expected, result);
            assertFalse("U+02DA boundary-after", nfkc.HasBoundaryAfter(0x2DA));
            assertFalse("U+FB2C boundary-after", nfkc.HasBoundaryAfter(0xFB2C));
        }
<#= GetEndFeature(charSequence) #>
<# } #>
<# foreach (var charSequence in CharSequences) { #>
<#= GetBeginFeature(charSequence) #>
        [Test]
        public void TestNoopNormalizer2_<#=charSequence.NameForTest#>()
        {
            // Use the internal class directly for coverage of methods that are not publicly reachable.
            Normalizer2 noop = Norm2AllModes.NoopNormalizer2;
            string input = "\u0327";
            assertEquals("noop.normalizeSecondAndAppend()", "ä\u0327",
                    noop.NormalizeSecondAndAppend(new StringBuilder("ä"), <#=string.Format(charSequence.FromStringFormat, "input")#>).ToString());
            assertEquals("noop.getDecomposition()", null, noop.GetDecomposition('ä'));
            assertTrue("noop.hasBoundaryAfter()", noop.HasBoundaryAfter(0x0308));
            assertTrue("noop.isInert()", noop.IsInert(0x0308));
        }
<#= GetEndFeature(charSequence) #>
<# } #>


    }
}
<#@ include file="../../../../../codegen/SharedObjects.tt" #>