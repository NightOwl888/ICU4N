<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Xml.XPath" #>
<#@ output extension=".cs" #>
<#
    // Load common settings from the XML file using relative path
    string settingsPath = System.IO.Path.GetFullPath(System.IO.Path.Combine(Host.ResolvePath(string.Empty), @"../../../../../src/CodeGenerationSettings.xml"));
    XDocument document = XDocument.Load(settingsPath);
    string[] charSequences = document.XPathSelectElements(@"//codeGen/charSequences/charSequence").Select(x => x.Value).ToArray();
    string charSequenceAccessibility = document.XPathSelectElement(@"//codeGen/charSequenceAccessibility").Value;
    string[] appendables = document.XPathSelectElements(@"//codeGen/appendables/appendable").Where(x => x.Value != "ValueStringBuilder").Select(x => x.Value).ToArray();

    int paramCount = 16;
#><#= "\uFEFF" #>//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using ICU4N.Impl;
using ICU4N.Text;
using J2N.Text;
using NUnit.Framework;
using System;
using System.Text;

namespace ICU4N.Dev.Test.Util
{
    public partial class SimpleFormatterTest
    {
        #region FormatRawPattern

<# for (int i = 0; i < paramCount; i++) { #>
        [Test]
        public void TestFormatRawPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan()
        {
            string expected = "<#=GetResultString(i + 1)#>";
            ReadOnlySpan<char> pattern = "<#=GetPatternString(i + 1)#>".AsSpan();
            string actual = SimpleFormatterImpl.FormatRawPattern(pattern, 0, int.MaxValue, <#=GenerateTestParams(i + 1)#>);
            assertEquals("TestFormatRawPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan", expected, actual);
        }

<# } #>
        #endregion FormatRawPattern

        #region TryFormatRawPattern

<# for (int i = 0; i < paramCount; i++) { #>
        [Test]
        public void TestTryFormatRawPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan()
        {
            string expected = "<#=GetResultString(i + 1)#>";
            ReadOnlySpan<char> pattern = "<#=GetPatternString(i + 1)#>".AsSpan();
            Span<char> actual = stackalloc char[expected.Length];
            assertTrue("Result was false", SimpleFormatterImpl.TryFormatRawPattern(pattern, actual, out int charsLength, 0, int.MaxValue, <#=GenerateTestParams(i + 1)#>));
            assertEquals("TestTryFormatRawPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan", expected, actual.Slice(0, charsLength).ToString());
        }

<# } #>
        #endregion TryFormatRawPattern

        #region FormatCompiledPattern

<# for (int i = 0; i < paramCount; i++) { #>
        [Test]
        public void TestFormatCompiledPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan()
        {
            string expected = "<#=GetResultString(i + 1)#>";
            string pattern = SimpleFormatterImpl.CompileToStringMinMaxArguments("<#=GetPatternString(i + 1)#>".AsSpan(), 0, int.MaxValue);
            string actual = SimpleFormatterImpl.FormatCompiledPattern(pattern.AsSpan(), <#=GenerateTestParams(i + 1)#>);
            assertEquals("TestFormatCompiledPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan", expected, actual);
        }

<# } #>
        #endregion FormatCompiledPattern

        #region TryFormatCompiledPattern

<# for (int i = 0; i < paramCount; i++) { #>
        [Test]
        public void TestTryFormatCompiledPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan()
        {
            string expected = "<#=GetResultString(i + 1)#>";
            Span<char> compiledPattern = stackalloc char[128];
            assertTrue("Compile pattern result was false", SimpleFormatterImpl.TryCompileToStringMinMaxArguments("<#=GetPatternString(i + 1)#>".AsSpan(), compiledPattern, out int patternLength, 0, int.MaxValue));
            Span<char> actual = stackalloc char[expected.Length];
            assertTrue("Result was false", SimpleFormatterImpl.TryFormatCompiledPattern(compiledPattern.Slice(0, patternLength), actual, out int charsLength, <#=GenerateTestParams(i + 1)#>));
            assertEquals("TestTryFormatCompiledPattern_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan", expected, actual.Slice(0, charsLength).ToString());
        }

<# } #>
        #endregion TryFormatCompiledPattern

        #region FormatAndAppend

<# for (int i = 0; i < paramCount; i++) { #>
        [Test]
        public void TestFormatAndAppend_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan()
        {
            string expected = "prefix|<#=GetResultString(i + 1)#>";
            int[] expectedOffsets = { 22 };
            string pattern = SimpleFormatterImpl.CompileToStringMinMaxArguments("<#=GetPatternString(i + 1)#>".AsSpan(), 0, int.MaxValue);
            string actual;
            int[] offsets = new int[1];
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[64]);
            try
            {
                sb.Append("prefix|");
                SimpleFormatterImpl.FormatAndAppend(pattern.AsSpan(), ref sb, offsets, <#=GenerateTestParams(i + 1)#>);
                actual = sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
            assertEquals("TestFormatAndAppend_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan", expected, actual);
            assertEquals("Offsets", expectedOffsets, offsets);
        }

<# } #>
        #endregion FormatAndAppend

        #region FormatAndReplace

<# for (int i = 0; i < paramCount; i++) { #>
        [Test]
        public void TestFormatAndReplace_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan()
        {
            string expected = "<#=GetResultString(i + 1)#>";
            int[] expectedOffsets = { 15 };
            string pattern = SimpleFormatterImpl.CompileToStringMinMaxArguments("<#=GetPatternString(i + 1)#>".AsSpan(), 0, int.MaxValue);
            string actual;
            int[] offsets = new int[1];
            ValueStringBuilder sb = new ValueStringBuilder(stackalloc char[64]);
            try
            {
                sb.Append("prefix|");
                SimpleFormatterImpl.FormatAndReplace(pattern.AsSpan(), ref sb, offsets, <#=GenerateTestParams(i + 1)#>);
                actual = sb.ToString();
            }
            finally
            {
                sb.Dispose();
            }
            assertEquals("TestFormatAndReplace_<#= SpellOut(i + 1)#>Arguments_ReadOnlySpan", expected, actual);
            assertEquals("Offsets", expectedOffsets, offsets);
        }

<# } #>
        #endregion FormatAndReplace
    }
}
<#+
    public string GenerateTestParams(int count) {
        StringBuilder result = new StringBuilder();
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                result.Append(", ");
            }
            result.Append("\"");
            result.Append(GetOrdinalString(i + 1));
            result.Append("\".AsSpan()");
        }
        return result.ToString();
    }
    public string GetOrdinalString(int count)
    {
        switch (count)
        {
            case 1:
                return "first";
            case 2:
                return "second";
            case 3:
                return "third";
            case 4:
                return "fourth";
            case 5:
                return "fifth";
            case 6:
                return "sixth";
            case 7:
                return "seventh";
            case 8:
                return "eighth";
            case 9:
                return "ninth";
            case 10:
                return "tenth";
            case 11:
                return "eleventh";
            case 12:
                return "twelveth";
            case 13:
                return "thirteenth";
            case 14:
                return "fourteenth";
            case 15:
                return "fifteenth";
            case 16:
                return "sixteenth";
            default:
                return string.Empty;
        }
    }
    public string SpellOut(int count)
    {
        switch (count)
        {
            case 1:
                return "One";
            case 2:
                return "Two";
            case 3:
                return "Three";
            case 4:
                return "Four";
            case 5:
                return "Five";
            case 6:
                return "Six";
            case 7:
                return "Seven";
            case 8:
                return "Eight";
            case 9:
                return "Nine";
            case 10:
                return "Ten";
            case 11:
                return "Eleven";
            case 12:
                return "Twelve";
            case 13:
                return "Thirteen";
            case 14:
                return "Fourteen";
            case 15:
                return "Fifteen";
            case 16:
                return "Sixteen";
            default:
                return string.Empty;
        }
    }
    public string GetResultString(int count)
    {
        StringBuilder result = new StringBuilder("The result is: ");
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                result.Append(", ");
            }
            result.Append(GetOrdinalString(i + 1));
        }
        return result.ToString();
    }
    public string GetPatternString(int count)
    {
        StringBuilder result = new StringBuilder("The result is: ");
        for (int i = 0; i < count; i++) {
            if (i > 0) {
                result.Append(", ");
            }
            result.Append('{');
            result.Append(i);
            result.Append('}');
        }
        return result.ToString();
    }
#>